// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"aYHqc":[function(require,module,exports) {
"use strict";
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "9808432d9aa0ef6a";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, globalThis, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/"); // Web extension context
    var extCtx = typeof chrome === "undefined" ? typeof browser === "undefined" ? null : browser : chrome; // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    } // $FlowFixMe
    ws.onmessage = async function(event) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        acceptedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH); // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear(); // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] ‚ú® Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          üö® ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>üìù <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", link.getAttribute("href").split("?")[0] + "?" + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension bugfix for Chromium
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1255412#c12
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3) {
                        if (typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                            extCtx.runtime.reload();
                            return;
                        }
                        asset.url = extCtx.runtime.getURL("/__parcel_hmr_proxy__?url=" + encodeURIComponent(asset.url + "?t=" + Date.now()));
                        return hmrDownload(asset);
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
             // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id]; // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) return true;
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"c1sIO":[function(require,module,exports) {
/**
 * by bitbof (bitbof.com)
 */ var _polyfills = require("./polyfills");
var _bb = require("./bb/bb");
var _kl = require("./klecks/kl");
var _klHistory = require("./klecks/history/kl-history");
var _klApp = require("./app/kl-app");
var _language = require("./language/language");
function initError(e) {
    let el = document.createElement("div");
    el.style.textAlign = "center";
    el.style.background = "#fff";
    el.style.padding = "20px";
    el.innerHTML = "<h1>App failed to initialize</h1>";
    el.innerHTML += "Error: " + (e.message ? e.message : "" + e);
    document.body.append(el);
    console.error(e);
}
(async ()=>{
    let klApp;
    let domIsLoaded = false;
    try {
        (0, _bb.BB).addEventListener(window, "DOMContentLoaded", ()=>{
            domIsLoaded = true;
        });
        await (0, _language.initLANG)();
    } catch (e) {
        initError(e);
        return;
    }
    function onProjectLoaded(project, projectStore) {
        if (klApp) throw "onKlProjectObjLoaded called more than once";
        let loadingScreenEl = document.getElementById("loading-screen");
        try {
            // in case an extension screwed with the page
            loadingScreenEl.parentNode.removeChild(loadingScreenEl);
        } catch (e) {}
        const saveReminder = new (0, _kl.KL).SaveReminder((0, _klHistory.klHistory), true, true, ()=>klApp.saveAsPsd(), ()=>{
            return klApp ? klApp.isDrawing() : false;
        }, null, null);
        klApp = new (0, _klApp.KlApp)(project, {
            saveReminder,
            projectStore
        });
        saveReminder.init();
        if (project) setTimeout(()=>{
            klApp.out((0, _language.LANG)("file-storage-restored"));
        }, 100);
        document.body.appendChild(klApp.getEl());
    }
    async function onDomLoaded() {
        try {
            (0, _bb.BB).removeEventListener(window, "DOMContentLoaded", onDomLoaded);
            let projectStore = new (0, _kl.KL).ProjectStore();
            let project = null;
            try {
                const readResult = await projectStore.read();
                if (readResult) project = readResult.project;
            } catch (e) {
                let message;
                if (e.message.indexOf("db-error") === 0) message = "Failed to access Browser Storage";
                else if (e.message.indexOf("format-error") === 0) message = "Failed to restore from Browser Storage";
                else message = "Failed to restore from Browser Storage";
                if (message) setTimeout(function() {
                    klApp && klApp.out(message);
                    throw new Error("Initial browser storage error, " + e);
                }, 100);
            }
            onProjectLoaded(project, projectStore);
        } catch (e1) {
            initError(e1);
        }
    }
    if (domIsLoaded) onDomLoaded();
    else (0, _bb.BB).addEventListener(window, "DOMContentLoaded", onDomLoaded);
})();

},{"./polyfills":"h6V9O","./bb/bb":"dcQKo","./klecks/kl":"8nmWp","./klecks/history/kl-history":"klzEn","./app/kl-app":"1tywk","./language/language":"iiYGN"}],"h6V9O":[function(require,module,exports) {
// import 'core-js';
var _nodePrototypeAppend = require("mdn-polyfills/Node.prototype.append");
var _nodePrototypePrepend = require("mdn-polyfills/Node.prototype.prepend");
var _stringPrototypePadStart = require("mdn-polyfills/String.prototype.padStart");
var _arrayPrototypeFindIndex = require("mdn-polyfills/Array.prototype.findIndex");
if (!("scrollTo" in Element.prototype)) Object.defineProperty(Element.prototype, "scrollTo", {
    value: function(x, y) {
        this.scrollLeft = x;
        this.scrollTop = y;
    }
});
if (!("scrollBy" in Element.prototype)) Object.defineProperty(Element.prototype, "scrollBy", {
    value: function(x, y) {
        this.scrollLeft += x;
        this.scrollTop += y;
    }
});
// sometimes Android WebView has no localStorage
if (!("localStorage" in window)) try {
    window["localStorage"] = {
        getItem: ()=>null,
        setItem: ()=>{},
        removeItem: ()=>{}
    };
} catch (e) {
// maybe it doesn't let me set this
}

},{"mdn-polyfills/Node.prototype.append":"L3T5Q","mdn-polyfills/Node.prototype.prepend":"88hN8","mdn-polyfills/String.prototype.padStart":"1K2W5","mdn-polyfills/Array.prototype.findIndex":"cbNyr"}],"L3T5Q":[function(require,module,exports) {
!function() {
    function t() {
        var e = Array.prototype.slice.call(arguments), n = document.createDocumentFragment();
        e.forEach(function(e) {
            var t = e instanceof Node;
            n.appendChild(t ? e : document.createTextNode(String(e)));
        }), this.appendChild(n);
    }
    [
        Element.prototype,
        Document.prototype,
        DocumentFragment.prototype
    ].forEach(function(e) {
        e.hasOwnProperty("append") || Object.defineProperty(e, "append", {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            value: t
        });
    });
}();

},{}],"88hN8":[function(require,module,exports) {
!function() {
    function t() {
        var e = Array.prototype.slice.call(arguments), n = document.createDocumentFragment();
        e.forEach(function(e) {
            var t = e instanceof Node;
            n.appendChild(t ? e : document.createTextNode(String(e)));
        }), this.insertBefore(n, this.firstChild);
    }
    [
        Element.prototype,
        Document.prototype,
        DocumentFragment.prototype
    ].forEach(function(e) {
        e.hasOwnProperty("prepend") || Object.defineProperty(e, "prepend", {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            value: t
        });
    });
}();

},{}],"1K2W5":[function(require,module,exports) {
String.prototype.padStart || (String.prototype.padStart = function(t, n) {
    return t >>= 0, n = String(n || " "), this.length > t ? String(this) : ((t -= this.length) > n.length && (n += n.repeat(t / n.length)), n.slice(0, t) + String(this));
});

},{}],"cbNyr":[function(require,module,exports) {
Array.prototype.findIndex || Object.defineProperty(Array.prototype, "findIndex", {
    value: function(r) {
        if (null == this) throw new TypeError('"this" is null or not defined');
        var e = Object(this), t = e.length >>> 0;
        if ("function" != typeof r) throw new TypeError("predicate must be a function");
        for(var n = arguments[1], o = 0; o < t;){
            var i = e[o];
            if (r.call(n, i, o, e)) return o;
            o++;
        }
        return -1;
    }
});

},{}],"dcQKo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BB", ()=>BB);
var _eventListener = require("./input/event-listener");
var _base = require("./base/base");
var _browser = require("./base/browser");
var _keyListener = require("./input/key-listener");
var _pointerListener = require("./input/pointer-listener");
var _eventChain = require("./input/event-chain");
var _canvas = require("./base/canvas");
var _matrix = require("./math/matrix");
var _vec2 = require("./math/vec2");
var _line = require("./math/line");
var _color = require("./color/color");
var _ui = require("./base/ui");
var _math = require("./math/math");
var _createCanvas = require("./base/create-canvas");
var _bbLog = require("./base/bb-log");
var _localStorage = require("./base/local-storage");
const BB = {
    eventUsesHighResTimeStamp: // ---- browser ----
    (0, _browser.eventUsesHighResTimeStamp),
    mouseEventHasMovement: (0, _browser.mouseEventHasMovement),
    hasPointerEvents: (0, _browser.hasPointerEvents),
    hasWebGl: (0, _browser.hasWebGl),
    getVisitor: (0, _browser.getVisitor),
    isCssMinMaxSupported: (0, _browser.isCssMinMaxSupported),
    canShareFiles: (0, _browser.canShareFiles),
    insertAfter: // ---- base ----
    (0, _base.insertAfter),
    loadImage: (0, _base.loadImage),
    css: (0, _base.css),
    setAttributes: (0, _base.setAttributes),
    append: (0, _base.append),
    fitInto: (0, _base.fitInto),
    centerWithin: (0, _base.centerWithin),
    getDate: (0, _base.getDate),
    gcd: (0, _base.gcd),
    reduce: (0, _base.reduce),
    decToFraction: (0, _base.decToFraction),
    imageBlobToUrl: (0, _base.imageBlobToUrl),
    dateDayDifference: (0, _base.dateDayDifference),
    copyObj: (0, _base.copyObj),
    shareCanvas: (0, _base.shareCanvas),
    handleClick: (0, _base.handleClick),
    createSvg: (0, _base.createSvg),
    BbLog: (0, _bbLog.BbLog),
    LocalStorage: (0, _localStorage.LocalStorage),
    mix: // ---- math ----
    (0, _math.mix),
    dist: (0, _math.dist),
    distSquared: (0, _math.distSquared),
    lenSquared: (0, _math.lenSquared),
    pointsToAngleRad: (0, _math.pointsToAngleRad),
    pointsToAngleDeg: (0, _math.pointsToAngleDeg),
    isInsideRect: (0, _math.isInsideRect),
    clamp: (0, _math.clamp),
    rotate: (0, _math.rotate),
    rotateAround: (0, _math.rotateAround),
    Matrix: (0, _matrix.Matrix),
    Vec2: (0, _vec2.Vec2),
    intDxy: (0, _math.intDxy),
    roundEven: (0, _math.roundEven),
    roundUneven: (0, _math.roundUneven),
    round: (0, _math.round),
    updateBounds: (0, _math.updateBounds),
    boundsInArea: (0, _math.boundsInArea),
    projectPointOnLine: // ---- line ----
    (0, _line.projectPointOnLine),
    PointLine: (0, _line.PointLine),
    BezierLine: (0, _line.BezierLine),
    SplineInterpolator: (0, _line.SplineInterpolator),
    quadraticSplineInput: (0, _line.quadraticSplineInput),
    // ---- canvas ----
    canvas: (0, _createCanvas.createCanvas),
    copyCanvas: (0, _canvas.copyCanvas),
    testShouldPixelate: (0, _canvas.testShouldPixelate),
    drawTransformedImageWithBounds: (0, _canvas.drawTransformedImageWithBounds),
    drawTransformedImageOnCanvas: (0, _canvas.drawTransformedImageOnCanvas),
    createCheckerCanvas: (0, _canvas.createCheckerCanvas),
    createCheckerDataUrl: (0, _canvas.createCheckerDataUrl),
    resizeCanvas: (0, _canvas.resizeCanvas),
    convertToAlphaChannelCanvas: (0, _canvas.convertToAlphaChannelCanvas),
    freeCanvas: (0, _canvas.freeCanvas),
    canvasBounds: (0, _canvas.canvasBounds),
    HSV: // ---- color ----
    (0, _color.HSV),
    RGB: (0, _color.RGB),
    CMYK: (0, _color.CMYK),
    ColorConverter: (0, _color.ColorConverter),
    testIsWhiteBestContrast: (0, _color.testIsWhiteBestContrast),
    appendTextDiv: // ---- UI ----
    (0, _ui.appendTextDiv),
    clearSelection: (0, _ui.clearSelection),
    makeUnfocusable: (0, _ui.makeUnfocusable),
    el: (0, _ui.el),
    destroyEl: (0, _ui.destroyEl),
    isInputFocused: (0, _ui.isInputFocused),
    unfocusAnyInput: (0, _ui.unfocusAnyInput),
    // ---- events / input ----
    addEventListener: _eventListener.addEventListener,
    removeEventListener: _eventListener.removeEventListener,
    setEventListener: _eventListener.setEventListener,
    KeyListener: (0, _keyListener.KeyListener),
    PointerListener: (0, _pointerListener.PointerListener),
    sameKeys: (0, _keyListener.sameKeys),
    EventChain: _eventChain
};

},{"./input/event-listener":"7bxtC","./base/base":"k6nNY","./base/browser":"jZRZU","./input/key-listener":"r1p1Z","./input/pointer-listener":"5fbd0","./input/event-chain":"3yNW8","./base/canvas":"d7Vt7","./math/matrix":"k5NsM","./math/vec2":"eFVNh","./math/line":"ewgfM","./color/color":"iVNo9","./base/ui":"2nyzl","./math/math":"7w6MZ","./base/create-canvas":"4BLUK","./base/bb-log":"lSCOF","./base/local-storage":"04p5O","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7bxtC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setEventListener", ()=>setEventListener);
parcelHelpers.export(exports, "addEventListener", ()=>addEventListener);
parcelHelpers.export(exports, "removeEventListener", ()=>removeEventListener);
var _browser = require("../base/browser");
const listenerFuncObj = {}; // for debugging
const setEventListener = function(DomEl, type, listener) {
    if (!(0, _browser.hasPointerEvents)) type = type.replace("pointer", "mouse");
    DomEl[type] = listener;
};
const addEventListener = function(DomEl, type, listener, options) {
    if (!(0, _browser.hasPointerEvents)) type = type.replace("pointer", "mouse");
    /*if (!(type in listenerFuncObj)) {
        listenerFuncObj[type] = [];
    }
    listenerFuncObj[type].push(listener);*/ DomEl.addEventListener(type, listener, options);
};
const removeEventListener = function(DomEl, type, listener, options) {
    if (!(0, _browser.hasPointerEvents)) type = type.replace("pointer", "mouse");
    /*if (type in listenerFuncObj) {
        for (let i = 0; i < listenerFuncObj[type].length; i++) {
            if (listenerFuncObj[type][i] === listener) {
                listenerFuncObj[type].splice(i, 1);
                i--;
            }
        }
    }*/ DomEl.removeEventListener(type, listener, options);
};

},{"../base/browser":"jZRZU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jZRZU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isFirefox", ()=>isFirefox);
parcelHelpers.export(exports, "eventUsesHighResTimeStamp", ()=>eventUsesHighResTimeStamp);
parcelHelpers.export(exports, "mouseEventHasMovement", ()=>mouseEventHasMovement);
parcelHelpers.export(exports, "hasPointerEvents", ()=>hasPointerEvents);
parcelHelpers.export(exports, "hasWebGl", ()=>hasWebGl);
parcelHelpers.export(exports, "getVisitor", ()=>getVisitor);
parcelHelpers.export(exports, "isCssMinMaxSupported", ()=>isCssMinMaxSupported);
parcelHelpers.export(exports, "canShareFiles", ()=>canShareFiles);
var _createCanvas = require("./create-canvas");
const isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
const eventUsesHighResTimeStamp = function() {
    let eventUsesHighResTimeStamp = null;
    if (document.body) (function() {
        const event = new Event("");
        eventUsesHighResTimeStamp = event.timeStamp < 3600000;
    })();
    else window.addEventListener("DOMContentLoaded", function(event) {
        eventUsesHighResTimeStamp = event.timeStamp < 3600000;
    });
    return function() {
        if (eventUsesHighResTimeStamp === null) throw "eventUsesHighResTimeStamp not initialized";
        return eventUsesHighResTimeStamp;
    };
}();
const mouseEventHasMovement = (()=>{
    // no support: IE, Safari, Safari iOS
    // supported but broken: Firefox
    if (!("MouseEvent" in window)) return false;
    let mouseEvent;
    try {
        mouseEvent = new MouseEvent("mousemove"); // browsers not supporting the constructor don't have it
    } catch (e) {
        return false;
    }
    if (!("movementX" in mouseEvent)) return false; // likely safari
    return !isFirefox;
})();
const hasPointerEvents = !!window.PointerEvent;
const hasWebGl = function() {
    const hasWebgl = function() {
        const canvas = (0, _createCanvas.createCanvas)();
        try {
            canvas.getContext("experimental-webgl", {
                premultipliedAlpha: false
            });
            return true;
        } catch (e) {
            return false;
        }
    }();
    return function() {
        return hasWebgl;
    };
}();
const getVisitor = function() {
    const visitor = {
        chrome: false,
        gl: false
    };
    //Chrome
    if (window.chrome && window.chrome.app) visitor.chrome = true;
    //WebGL
    visitor.gl = hasWebGl();
    return function() {
        return JSON.parse(JSON.stringify(visitor));
    };
}();
const isCssMinMaxSupported = function() {
    let result = null;
    function test() {
        const div = document.createElement("div");
        div.style.position = "absolute";
        div.style.top = "0";
        div.style.left = "max(0px, 25px)";
        document.body.appendChild(div);
        setTimeout(function() {
            result = div.offsetLeft === 25;
            document.body.removeChild(div);
        }, 25);
    }
    if (document.body) test();
    else window.addEventListener("DOMContentLoaded", function() {
        test();
    });
    return function() {
        if (result === null) throw new Error("isCssMinMaxSupported not initialized");
        return result;
    };
}();
const canShareFiles = function() {
    return "share" in navigator && "canShare" in navigator;
};

},{"./create-canvas":"4BLUK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4BLUK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/*window['canvases'] = [];

window['printCanvases'] = () => {
    let total = 0;

    console.log(window['canvases'].map(item => {
        total += item.width * item.height;
        return {w: item.width, h: item.height};
    }));

    console.log('total: ' + (total * 4 / 1000 / 1000) + 'mb');
};*/ parcelHelpers.export(exports, "createCanvas", ()=>createCanvas);
function createCanvas(w, h) {
    const result = document.createElement("canvas");
    if (w && h) {
        result.width = w;
        result.height = h;
    }
    // window['canvases'].push(result);
    return result;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"k6nNY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "insertAfter", ()=>insertAfter);
parcelHelpers.export(exports, "loadImage", ()=>loadImage);
parcelHelpers.export(exports, "css", ()=>css);
parcelHelpers.export(exports, "setAttributes", ()=>setAttributes);
/**
 * appendChild with an array
 * @param target
 * @param els
 */ parcelHelpers.export(exports, "append", ()=>append);
/**
 * a needs to fit into b
 * @param aw
 * @param ah
 * @param bw
 * @param bh
 * @param min
 */ parcelHelpers.export(exports, "fitInto", ()=>fitInto);
/**
 * center b in a
 * @param aw
 * @param ah
 * @param bw
 * @param bh
 */ parcelHelpers.export(exports, "centerWithin", ()=>centerWithin);
parcelHelpers.export(exports, "getDate", ()=>getDate);
parcelHelpers.export(exports, "gcd", ()=>gcd);
parcelHelpers.export(exports, "reduce", ()=>reduce);
parcelHelpers.export(exports, "decToFraction", ()=>decToFraction);
/**
 * blobObj isn't always a Blob, but rather an object, because Blob doesn't exist.
 * @param blobObj
 * @returns {string}
 */ parcelHelpers.export(exports, "imageBlobToUrl", ()=>imageBlobToUrl);
parcelHelpers.export(exports, "dateDayDifference", ()=>dateDayDifference);
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
parcelHelpers.export(exports, "copyObj", ()=>copyObj);
/**
 * triggers Web Share API - share feature on mobile devices
 * Only works if they support file sharing - e.g. Safari can't do this yet
 * only call if BB.canShareFiles() -> true
 *
 * p = {
 *     canvas: Canvas,
 *     fileName: string,
 *     title: string
 * }
 *
 * @param p
 */ parcelHelpers.export(exports, "shareCanvas", ()=>shareCanvas);
/**
 * Prevent ipad from zooming in when double tapping. iPadOS 13 bug.
 * Give it your click event
 *
 * @param clickEvent
 * @returns {boolean}
 */ parcelHelpers.export(exports, "handleClick", ()=>handleClick);
/**
 * @param el {elementType: string, childrenArr: []el, ...svg attributes...}
 * @returns svg element tree
 */ parcelHelpers.export(exports, "createSvg", ()=>createSvg);
function insertAfter(referenceNode, newNode) {
    if (referenceNode.parentNode) referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
}
function loadImage(im, callback) {
    let counter = 0;
    function check() {
        if (counter === 1000) {
            alert("couldn't load");
            return;
        }
        if (im.complete) {
            counter++;
            callback();
        } else setTimeout(check, 1);
    }
    check();
}
function css(el, styleObj) {
    const keyArr = Object.keys(styleObj);
    let keyStr;
    const style = el.style;
    for(let i = 0; i < keyArr.length; i++){
        keyStr = keyArr[i];
        style[keyStr] = styleObj[keyStr];
        style.alignContent = "true";
        if (keyStr === "userSelect") style.webkitUserSelect = styleObj[keyStr]; // safari
    }
}
function setAttributes(el, attrObj) {
    const keyArr = Object.keys(attrObj);
    let keyStr;
    for(let i = 0; i < keyArr.length; i++){
        keyStr = keyArr[i];
        el.setAttribute(keyStr, attrObj[keyStr]);
    }
}
function append(target, els) {
    const fragment = document.createDocumentFragment();
    els.forEach((item)=>item ? fragment.append(item) : null);
    target.append(fragment);
}
function fitInto(aw, ah, bw, bh, min) {
    let width = aw * bw, height = ah * bw;
    if (width > bw) {
        height = bw / width * height;
        width = bw;
    }
    if (height > bh) {
        width = bh / height * width;
        height = bh;
    }
    if (min) {
        width = Math.max(min, width);
        height = Math.max(min, height);
    }
    return {
        width,
        height
    };
}
function centerWithin(aw, ah, bw, bh) {
    return {
        x: aw / 2 - bw / 2,
        y: ah / 2 - bh / 2
    };
}
function getDate() {
    const date = new Date();
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, "0");
    const day = date.getDate().toString().padStart(2, "0");
    const minutes = (date.getHours() * 60 + date.getMinutes()).toString(36).padStart(3, "0");
    return year + "_" + month + "_" + day + "_" + minutes + "_";
}
function gcd(a, b) {
    return b ? gcd(b, a % b) : a;
}
function reduce(numerator, denominator) {
    const g = gcd(numerator, denominator);
    return [
        numerator / g,
        denominator / g
    ];
}
function decToFraction(decimalNumber) {
    const len = decimalNumber.toString().length - 2;
    const denominator = Math.pow(10, len);
    const numerator = decimalNumber * denominator;
    return reduce(numerator, denominator);
}
function imageBlobToUrl(blobObj) {
    if (!blobObj) throw new Error("blobObj is undefined or null");
    if (window.Blob && blobObj instanceof Blob) return URL.createObjectURL(blobObj); // object url
    else if (blobObj.constructor.name === "Object") {
        const fauxBlob = blobObj;
        return "data:" + fauxBlob.type + ";" + fauxBlob.encoding + "," + fauxBlob.data; // data url
    } else throw new Error("unknown blob format");
}
function dateDayDifference(dateA, dateB) {
    dateA = new Date(dateA);
    dateB = new Date(dateB);
    dateA.setHours(0, 0, 0, 0);
    dateB.setHours(0, 0, 0, 0);
    return (dateB.getTime() - dateA.getTime()) / 86400000;
}
function copyObj(obj) {
    return JSON.parse(JSON.stringify(obj));
}
function shareCanvas(p) {
    const mimetype = "image/png";
    const err = ()=>alert("sharing not supported");
    p.canvas.toBlob(function(blob) {
        if (blob === null) {
            err();
            p.callback();
            return;
        }
        try {
            const filesArray = [
                new File([
                    blob
                ], p.fileName, {
                    type: mimetype
                })
            ];
            navigator.share({
                title: p.title,
                files: filesArray
            }).then((r)=>{}).catch((e)=>{
                err();
            });
        } catch (e) {
            err();
        }
        p.callback();
    }, mimetype);
}
function handleClick(clickEvent) {
    const target = clickEvent.target;
    if (!target) return false;
    if ([
        "A",
        "LABEL",
        "INPUT"
    ].includes(target.tagName) || target.allowClick) return true;
    clickEvent.preventDefault();
    return false;
}
function createSvg(el) {
    const result = document.createElementNS("http://www.w3.org/2000/svg", el.elementType);
    const keyArr = Object.keys(el);
    let keyStr;
    for(let i = 0; i < keyArr.length; i++){
        keyStr = keyArr[i];
        if (keyStr === "childrenArr") for(let e = 0; e < el.childrenArr.length; e++)result.appendChild(createSvg(el.childrenArr[e]));
        else if (keyStr !== "elementType") result.setAttribute(keyStr, el[keyStr]);
    }
    return result;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"r1p1Z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Listens to key events in window. Makes combos easier - e.g. ctrl + z
 *
 * keyStr - see in implementation - my representation of a key. e.g. 'r' can be 'r' and 'R'
 * comboStr - string joins currently pressed keyStr with a +
 *              e.g. 'ctrl+z'
 *
 */ parcelHelpers.export(exports, "KeyListener", ()=>KeyListener);
parcelHelpers.export(exports, "sameKeys", ()=>sameKeys);
var _eventListener = require("./event-listener");
const globalKey = (()=>{
    const keyStrToKeyObj = {
        "space": [
            " ",
            "Spacebar"
        ],
        "alt": [
            "Alt",
            "AltGraph"
        ],
        "shift": "Shift",
        "ctrl": "Control",
        "cmd": [
            "Meta",
            "MetaLeft",
            "MetaRight"
        ],
        "enter": "Enter",
        "esc": "Escape",
        "backspace": "Backspace",
        "delete": "Delete",
        "sqbr_open": "[",
        "sqbr_close": "]",
        "a": [
            "a",
            "A"
        ],
        "b": [
            "b",
            "B"
        ],
        "c": [
            "c",
            "C"
        ],
        "e": [
            "e",
            "E"
        ],
        "f": [
            "f",
            "F"
        ],
        "g": [
            "g",
            "G"
        ],
        "r": [
            "r",
            "R"
        ],
        "s": [
            "s",
            "S"
        ],
        "t": [
            "t",
            "T"
        ],
        "u": [
            "u",
            "U"
        ],
        "x": [
            "x",
            "X"
        ],
        "y": [
            "y",
            "Y"
        ],
        "z": [
            "z",
            "Z"
        ],
        "plus": "+",
        "minus": "-",
        "left": "ArrowLeft",
        "right": "ArrowRight",
        "up": "ArrowUp",
        "down": "ArrowDown",
        "home": "Home",
        "end": "End"
    };
    const keyToKeyStrArr = Object.keys(keyStrToKeyObj);
    const isDownObj = {};
    const keyToKeyStrObj = {}; // event.key to keyStr { ArrowLeft: 'left', ... }
    let comboArr = [];
    //a physical key's "key" can change as other keys get pressed. to keep track, need to also track the code
    let codeIsDownObj = {}; // { KeyE: 'e', KeyF: null } - null not down, string, the associated keyStr
    const listenerArr = [];
    for(let i = 0; i < keyToKeyStrArr.length; i++){
        isDownObj[keyToKeyStrArr[i]] = false;
        const code = keyStrToKeyObj[keyToKeyStrArr[i]];
        if (typeof code === "string") keyToKeyStrObj[keyStrToKeyObj[keyToKeyStrArr[i]]] = keyToKeyStrArr[i];
        else for(let e = 0; e < code.length; e++)keyToKeyStrObj[code[e]] = keyToKeyStrArr[i];
    }
    function emitDown(a, b, c, d) {
        listenerArr.forEach((item)=>{
            if (!item[0]) return;
            item[0](a, b, c, d);
        });
    }
    function emitUp(a, b, c) {
        listenerArr.forEach((item)=>{
            if (!item[1]) return;
            item[1](a, b, c);
        });
    }
    function emitBlur() {
        listenerArr.forEach((item)=>{
            if (!item[2]) return;
            item[2]();
        });
    }
    function keyDown(e) {
        const key = e.key;
        const code = "code" in e ? e.code : e.keyCode; // ie doesn't have code
        if (key in keyToKeyStrObj) {
            const keyStr = keyToKeyStrObj[key];
            if (isDownObj[keyStr]) {
                emitDown(keyStr, e, comboArr.join("+"), true);
                return;
            }
            isDownObj[keyStr] = true;
            codeIsDownObj[code] = keyStr;
            //add to combo
            comboArr.push(keyStr);
            emitDown(keyStr, e, comboArr.join("+"));
        }
    }
    function keyUp(e) {
        const key = e.key;
        const code = "code" in e ? e.code : e.keyCode; // ie doesn't have code
        const oldComboStr = comboArr.join("+");
        // because of a macOS bug: when meta key is down, keyup of other keys does not fire.
        // https://stackoverflow.com/questions/25438608/javascript-keyup-isnt-called-when-command-and-another-is-pressed
        if ([
            "Meta",
            "MetaLeft",
            "MetaRight",
            "OSLeft",
            "OSRight"
        ].includes(code)) {
            blur(null);
            return;
        }
        if (code in codeIsDownObj && codeIsDownObj[code] !== null) {
            const keyStr = codeIsDownObj[code];
            isDownObj[keyStr] = false;
            codeIsDownObj[code] = null;
            //remove from combo
            for(let i = 0; i < comboArr.length; i++)if (comboArr[i] == keyStr) {
                comboArr.splice(i, 1);
                i--;
            }
            emitUp(keyStr, e, oldComboStr);
        }
    }
    function blur(event) {
        const oldComboStr = comboArr.join("+");
        comboArr = [];
        codeIsDownObj = {};
        const eventArr = [];
        for(let i = 0; i < keyToKeyStrArr.length; i++)if (isDownObj[keyToKeyStrArr[i]]) {
            isDownObj[keyToKeyStrArr[i]] = false;
            eventArr.push(keyToKeyStrArr[i]);
        }
        for(let i1 = 0; i1 < eventArr.length; i1++)emitUp(eventArr[i1], {
            preventDefault: function() {},
            stopPropagation: function() {}
        }, oldComboStr);
        emitBlur();
    }
    return {
        add: (keyListener)=>{
            if (listenerArr.includes(keyListener)) return;
            const first = listenerArr.length === 0;
            listenerArr.push(keyListener);
            if (first) {
                (0, _eventListener.addEventListener)(document, "keydown", keyDown);
                (0, _eventListener.addEventListener)(document, "keyup", keyUp);
                (0, _eventListener.addEventListener)(window, "blur", blur);
            }
        },
        remove: (keyListener)=>{
            if (!listenerArr.includes(keyListener)) return;
            const last = listenerArr.length === 1;
            for(let i = 0; i < listenerArr.length; i++)if (listenerArr[i] === keyListener) {
                listenerArr.splice(i, 1);
                break;
            }
            if (last) {
                (0, _eventListener.removeEventListener)(document, "keydown", keyDown);
                (0, _eventListener.removeEventListener)(document, "keyup", keyUp);
                (0, _eventListener.removeEventListener)(window, "blur", blur);
            }
        },
        getIsDown: ()=>{
            return isDownObj;
        },
        getCombo: ()=>{
            return comboArr;
        }
    };
})();
class KeyListener {
    constructor(p){
        this.onDown = p.onDown;
        this.onUp = p.onUp;
        this.onBlur = p.onBlur;
        this.ref = [
            this.onDown,
            this.onUp,
            this.onBlur
        ];
        globalKey.add(this.ref);
    }
    isPressed(keyStr) {
        if (!(keyStr in globalKey.getIsDown())) throw 'key "' + keyStr + '" not found';
        return globalKey.getIsDown()[keyStr];
    }
    getComboStr() {
        return globalKey.getCombo().join("+");
    }
    comboOnlyContains(keyStrArr) {
        for(let i = 0; i < globalKey.getCombo().length; i++){
            if (!keyStrArr.includes(globalKey.getCombo()[i])) return false;
        }
        return true;
    }
    destroy() {
        globalKey.remove(this.ref);
    }
}
function sameKeys(comboAStr, comboBStr) {
    return comboAStr.split("+").sort().join("+") === comboBStr.split("+").sort().join("+");
}

},{"./event-listener":"7bxtC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5fbd0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PointerListener", ()=>PointerListener);
var _eventListener = require("./event-listener");
/**
 * Filters wheel events. removes swipe scrolling and pinch scrolling that trackpads do. (as best as it can)
 * Normalizes regular scrolls.
 *
 * Why:
 * - trackpad scrolling is different from old school mouse scrolling
 * - but there is not way to learn from the browser if it's trackpad scrolling
 * - browsers don't even give access to the raw swiping or pinching movement, but some abstraction on top, making the scrolling
 *      continue an arbitrary amount, at an arbitrary scale
 * - each browser does this differently. So you can't offer a coherent experience
 *
 * - also trackpads are painful to draw with. So supporting a trackpad-based workflow makes not much sense.
 *
 * @param callback - func({deltaY: number, pageX: number, pageY: number, clientX: number, clientY: number}
 * @constructor
 */ var _browser = require("../base/browser");
var _math = require("../math/math");
const WheelCleaner = function(callback) {
    const sequenceTimeoutMs = 200;
    const knownUnitArr = [
        100
    ];
    let sequenceLength = 0;
    let sequenceUnit = null;
    let endSequenceTimeout;
    let toEmitDelta = null;
    let position = null;
    function emit(delta) {
        callback({
            deltaY: Math.round(delta / sequenceUnit),
            pageX: position.pageX,
            pageY: position.pageY,
            clientX: position.clientX,
            clientY: position.clientY
        });
    }
    function endSequence() {
        if (toEmitDelta !== null) {
            emit(toEmitDelta);
            toEmitDelta = null;
        }
        if (sequenceUnit !== null && !knownUnitArr.includes(sequenceUnit)) knownUnitArr.push(sequenceUnit);
        sequenceLength = 0;
        sequenceUnit = null;
    }
    // --- interface ---
    this.process = function(event) {
        position = {
            pageX: event.pageX,
            pageY: event.pageY,
            clientX: event.clientX,
            clientY: event.clientY
        };
        clearTimeout(endSequenceTimeout);
        endSequenceTimeout = setTimeout(endSequence, sequenceTimeoutMs);
        //prep delta
        let delta = event.deltaY;
        if ("deltaMode" in event && event.deltaMode === 1) delta *= 100 / 3;
        const absDelta = Math.abs(delta);
        if (sequenceLength > 0 && sequenceUnit === null) {
            //previously determined dirty sequence
            toEmitDelta = null;
            return;
        }
        //sequence begins
        if (sequenceLength === 0) {
            sequenceLength++;
            if (absDelta < 50) //dirty - probably a swipe scroll or pinch scroll on trackpad
            return;
            sequenceUnit = absDelta;
            if (knownUnitArr.includes(sequenceUnit)) //we know this unit - emit right away
            emit(delta);
            else //unknown unit - wait until next event or sequence end, to have more certainty that it's clean
            toEmitDelta = delta;
            return;
        }
        //sequence continues
        if (absDelta === 0) //ignore zero scroll
        return;
        if (absDelta === sequenceUnit || absDelta / sequenceUnit % 1 < 0.0001 // a multiple
        ) ;
        else if (sequenceUnit / absDelta % 1 < 0.0001) //unit was actually a multiple - update it
        sequenceUnit = absDelta;
        else if (absDelta !== sequenceUnit) {
            //not clean - delta is varying - probably a swipe scroll or pinch scroll on trackpad
            sequenceUnit = null;
            toEmitDelta = null;
            return;
        }
        if (toEmitDelta !== null) {
            emit(toEmitDelta);
            toEmitDelta = null;
        }
        emit(delta);
    };
};
const PointerListener = function() {
    //keeping track of pointers for movement fallback
    const pointerArr = [];
    function addPointer(event) {
        const pointerObj = {
            pointerId: event.pointerId,
            lastPageX: null,
            lastPageY: null
        };
        pointerArr.push(pointerObj);
        if (pointerArr.length > 15) pointerArr.shift();
        return pointerObj;
    }
    function getPointer(event) {
        for(let i = pointerArr.length - 1; i >= 0; i--){
            if (event.pointerId === pointerArr[i].pointerId) return pointerArr[i];
        }
        return null;
    }
    let pressureNormalizeAvgCount = 0;
    let pressureNormalizeAvgPressure = null;
    let pressureNormalizeIsComplete = false;
    let pressureNormalizeFactor = 1;
    return function(p) {
        const targetElement = p.target;
        const onPointerCallback = p.onPointer;
        const onWheelCallback = p.onWheel;
        const onEnterLeaveCallback = p.onEnterLeave;
        const maxPointers = "maxPointers" in p ? p.maxPointers : 1;
        const buttonsToStr = {
            "1": "left",
            "2": "right",
            "4": "middle"
        };
        const wheelCleaner = new WheelCleaner(function(wheelEvent) {
            if (isDestroyed) return;
            if (onWheelCallback) {
                const bounds = targetElement.getBoundingClientRect();
                wheelEvent.relX = wheelEvent.clientX - bounds.left + targetElement.scrollLeft;
                wheelEvent.relY = wheelEvent.clientY - bounds.top + targetElement.scrollTop;
                onWheelCallback(wheelEvent);
            }
        });
        let isDestroyed = false;
        const timeStampOffset = (0, _browser.eventUsesHighResTimeStamp)() ? 0 : -performance.timing.navigationStart;
        //to circumvent a chrome input glitch
        let lastPointerType = "";
        let didSkip = false;
        /*
        pointers that are pressing a button
        dragObj = {
            pointerId: long,
            pointerType: 'mouse'|'pen'|'touch',
            downPageX: number, //where was pointer when down-event occurred
            downPageY: number,
            button: long,
            lastPageX: number, //pageX in previous event - only for touch events, because they don't have movementX/Y
            lastPageY: number,
            lastTimeStamp: number
        }
         */ const dragObjArr = [];
        const dragPointerIdArr = [];
        function getDragObj(pointerId) {
            for(let i = 0; i < dragObjArr.length; i++){
                if (pointerId === dragObjArr[i].pointerId) return dragObjArr[i];
            }
            return null;
        }
        function removeDragObj(pointerId) {
            let removedDragObj = null;
            for(let i = 0; i < dragPointerIdArr.length; i++)if (dragPointerIdArr[i] === pointerId) {
                removedDragObj = dragObjArr[i];
                dragObjArr.splice(i, 1);
                dragPointerIdArr.splice(i, 1);
                i--;
            }
            return removedDragObj;
        }
        function normalizePressure(pressure, type) {
            if (pressure === 0 || pressure === 1) return pressure;
            // was this there to prevent some glitch?
            /*if (pressureNormalizeIsComplete && type === 'pointerdown' && pressure !== 1) {
                pressure *= 0.004;
            }*/ if (pressureNormalizeAvgCount < 60) {
                if (pressureNormalizeAvgCount === 0) pressureNormalizeAvgPressure = pressure;
                else pressureNormalizeAvgPressure = (0, _math.mix)(pressure, pressureNormalizeAvgPressure, 0.95);
                pressureNormalizeAvgCount++;
            } else if (!pressureNormalizeIsComplete) {
                pressureNormalizeIsComplete = true;
                //BB.throwOut('avg pressure decision!' + pressureNormalizeAvgPressure);
                if (pressureNormalizeAvgPressure < 0.13) pressureNormalizeFactor = 2.3;
            }
            return Math.pow(pressure, 1 / pressureNormalizeFactor);
        }
        /**
         *
         * More trustworthy pointer attributes. that behave the same across browsers.
         * returns a new object. this object also gets attached to the orig event. -> event.corrected
         *
         * @param event
         * @returns {{pointerId: number, timeStamp: number, button, buttons, pointerType: (string|string|any), movementY: number, movementX: number, pressure, coalescedArr: [], pageY, pageX, clientX, clientY, eventPreventDefault: func, eventStopPropagation: func}
         */ function correctPointerEvent(event) {
            if (event.corrected) return event.corrected;
            /*if (event.type === 'pointermove' && !window.hidePressureOut) {
                if (event.type === 'pointermove') {
                    BB.throwOut(event.pressure + ' ' + event.pointerType);
                }
            }*/ const correctedObj = {
                pointerId: event.pointerId,
                pointerType: event.pointerType,
                pageX: event.pageX,
                pageY: event.pageY,
                clientX: event.clientX,
                clientY: event.clientY,
                movementX: event.movementX,
                movementY: event.movementY,
                timeStamp: event.timeStamp + timeStampOffset,
                pressure: normalizePressure(event.pressure, event.type),
                buttons: event.buttons,
                button: event.button,
                coalescedArr: [],
                eventPreventDefault: function() {
                    event.preventDefault();
                },
                eventStopPropagation: function() {
                    event.stopPropagation();
                }
            };
            event.corrected = correctedObj;
            let customPressure = null;
            if ("pointerId" in event) {
                if ("pressure" in event && event.buttons !== 0 && ([
                    "mouse"
                ].includes(event.pointerType) || event.pointerType === "touch" && event.pressure === 0)) {
                    correctedObj.pressure = 1;
                    customPressure = 1;
                }
            } else {
                correctedObj.pointerId = 0;
                correctedObj.pointerType = "mouse";
                correctedObj.pressure = event.buttons !== 0 ? 1 : 0;
                customPressure = correctedObj.pressure;
            }
            if ((0, _browser.isFirefox) && event.pointerType != "mouse" && event.type === "pointermove" && event.buttons === 0) correctedObj.buttons = 1; //todo wrong if no buttons actually pressed
            let coalescedEventArr = [];
            if ("getCoalescedEvents" in event) coalescedEventArr = event.getCoalescedEvents();
            // chrome somehow movementX not same scale as pageX. todo: only chrome?
            // so make my own
            let pointerObj = getPointer(correctedObj);
            if (pointerObj === null) pointerObj = addPointer(correctedObj);
            const totalLastX = pointerObj.lastPageX;
            const totalLastY = pointerObj.lastPageY;
            for(let i = 0; i < coalescedEventArr.length; i++){
                const eventItem = coalescedEventArr[i];
                correctedObj.coalescedArr.push({
                    pageX: eventItem.pageX,
                    pageY: eventItem.pageY,
                    clientX: eventItem.clientX,
                    clientY: eventItem.clientY,
                    movementX: pointerObj.lastPageX === null ? 0 : eventItem.pageX - pointerObj.lastPageX,
                    movementY: pointerObj.lastPageY === null ? 0 : eventItem.pageY - pointerObj.lastPageY,
                    timeStamp: eventItem.timeStamp === 0 ? correctedObj.timeStamp : eventItem.timeStamp + timeStampOffset,
                    pressure: customPressure === null ? normalizePressure(eventItem.pressure) : customPressure
                });
                pointerObj.lastPageX = eventItem.pageX;
                pointerObj.lastPageY = eventItem.pageY;
            }
            pointerObj.lastPageX = correctedObj.pageX;
            pointerObj.lastPageY = correctedObj.pageY;
            correctedObj.movementX = totalLastX === null ? 0 : pointerObj.lastPageX - totalLastX;
            correctedObj.movementY = totalLastY === null ? 0 : pointerObj.lastPageY - totalLastY;
            return correctedObj;
        }
        /**
         * creates a value for onPointer, from a pointer event handler
         *
         * @param typeStr string - 'pointerdown'|'pointermove'|'pointerup'
         * @param correctedEvent - corrected pointer event from correctPointerEvent()
         * @param custom - object for setting custom attributes
         * @returns {{pointerId: number, pointerType: *, dX: (*), relY: number, dY: (*), relX: number, type: *, event: *, pageY: *, pageX: *}}
         */ function createPointerOutEvent(typeStr, correctedEvent, custom) {
            const bounds = targetElement.getBoundingClientRect();
            const result = {
                type: typeStr,
                pointerId: correctedEvent.pointerId,
                pointerType: correctedEvent.pointerType,
                pageX: correctedEvent.pageX,
                pageY: correctedEvent.pageY,
                clientX: correctedEvent.clientX,
                clientY: correctedEvent.clientY,
                relX: correctedEvent.clientX - bounds.left + targetElement.scrollLeft,
                relY: correctedEvent.clientY - bounds.top + targetElement.scrollTop,
                dX: correctedEvent.movementX,
                dY: correctedEvent.movementY,
                time: correctedEvent.timeStamp,
                eventPreventDefault: correctedEvent.eventPreventDefault,
                eventStopPropagation: correctedEvent.eventStopPropagation
            };
            if (typeStr === "pointermove") {
                result.coalescedArr = [];
                if (correctedEvent.coalescedArr.length > 1) {
                    let coalescedItem;
                    for(let i = 0; i < correctedEvent.coalescedArr.length; i++){
                        coalescedItem = correctedEvent.coalescedArr[i];
                        result.coalescedArr.push({
                            pageX: coalescedItem.pageX,
                            pageY: coalescedItem.pageY,
                            clientX: coalescedItem.clientX,
                            clientY: coalescedItem.clientY,
                            relX: coalescedItem.clientX - bounds.left + targetElement.scrollLeft,
                            relY: coalescedItem.clientY - bounds.top + targetElement.scrollTop,
                            dX: coalescedItem.movementX,
                            dY: coalescedItem.movementY,
                            time: coalescedItem.timeStamp
                        });
                    }
                }
            }
            if (custom) {
                const keyArr = Object.keys(custom);
                for(let i1 = 0; i1 < keyArr.length; i1++)result[keyArr[i1]] = custom[keyArr[i1]];
            }
            return result;
        }
        /**
         * creates a value for onPointer, from a fallback touch event handler
         *
         * @param typeStr string - 'pointerdown'|'pointermove'|'pointerup'
         * @param touchListItem - element from changed touch list
         * @param touchEvent - touch event
         * @param custom - object for setting custom attributes
         * @returns {{pointerId: number, pointerType: string, relY: number, relX: number, type: *, event: *, pageY: *, pageX: *}}
         */ function createTouchOutEvent(typeStr, touchListItem, touchEvent, custom) {
            const bounds = targetElement.getBoundingClientRect();
            const result = {
                type: typeStr,
                pointerId: touchListItem.identifier,
                pointerType: "touch",
                pageX: touchListItem.pageX,
                pageY: touchListItem.pageY,
                clientX: touchListItem.clientX,
                clientY: touchListItem.clientY,
                relX: touchListItem.pageX - bounds.left + targetElement.scrollLeft,
                relY: touchListItem.pageY - bounds.top + targetElement.scrollTop,
                time: touchEvent.timeStamp + timeStampOffset,
                eventPreventDefault: function() {
                    touchEvent.preventDefault();
                },
                eventStopPropagation: function() {
                    touchEvent.stopPropagation();
                }
            };
            if (typeStr === "pointermove") result.coalescedArr = [];
            const keyArr = Object.keys(custom);
            for(let i = 0; i < keyArr.length; i++)result[keyArr[i]] = custom[keyArr[i]];
            return result;
        }
        function setupDocumentListeners() {
            (0, _eventListener.addEventListener)(document, "pointermove", onGlobalPointerMove);
            (0, _eventListener.addEventListener)(document, "pointerup", onGlobalPointerUp);
            (0, _eventListener.addEventListener)(document, "pointerleave", onGlobalPointerLeave);
        }
        function destroyDocumentListeners() {
            (0, _eventListener.removeEventListener)(document, "pointermove", onGlobalPointerMove);
            (0, _eventListener.removeEventListener)(document, "pointerup", onGlobalPointerUp);
            (0, _eventListener.removeEventListener)(document, "pointerleave", onGlobalPointerLeave);
        }
        let isOverCounter = 0; // might be multiple pointers
        function onPointerEnter() {
            isOverCounter++;
            if (onEnterLeaveCallback) onEnterLeaveCallback(true);
        }
        function onPointerLeave() {
            isOverCounter--;
            if (onEnterLeaveCallback) onEnterLeaveCallback(false);
        }
        function onPointermove(event) {
            event = correctPointerEvent(event);
            const tempLastPointerType = lastPointerType;
            lastPointerType = event.pointerType;
            if (dragPointerIdArr.includes(event.pointerId) || dragPointerIdArr.length === maxPointers || event.pointerType === "touch") {
                didSkip = false;
                return;
            }
            // chrome input glitch workaround - throws in a random mouse event with the wrong position when using a stylus
            if (!didSkip && event.pointerType === "mouse" && tempLastPointerType === "pen") {
                didSkip = true;
                return;
            }
            didSkip = false;
            const outEvent = createPointerOutEvent("pointermove", event);
            onPointerCallback(outEvent);
        }
        function onPointerdown(event) {
            //BB.throwOut('pointerdown ' + event.pointerId + ' | ' + dragPointerIdArr.length);
            event = correctPointerEvent(event);
            ////console.log('debug: ' + event.pointerId + ' pointerdown');
            if (dragPointerIdArr.includes(event.pointerId) || dragPointerIdArr.length === maxPointers || ![
                1,
                2,
                4
            ].includes(event.buttons)) //BB.throwOut('pointerdown ignored');
            return;
            //set up global listeners
            if (dragObjArr.length === 0) setupDocumentListeners();
            const dragObj = {
                pointerId: event.pointerId,
                pointerType: event.pointerType,
                downPageX: event.pageX,
                downPageY: event.pageY,
                buttons: event.buttons,
                lastPageX: event.pageX,
                lastPageY: event.pageY,
                lastTimeStamp: event.timeStamp
            };
            dragObjArr.push(dragObj);
            setTouchTimeout(dragObj);
            dragPointerIdArr.push(event.pointerId);
            const outEvent = createPointerOutEvent("pointerdown", event, {
                downPageX: event.pageX,
                downPageY: event.pageY,
                button: buttonsToStr[event.buttons],
                pressure: event.pressure
            });
            onPointerCallback(outEvent);
        }
        function onGlobalPointerMove(event) {
            //BB.throwOut('pointermove ' + event.pointerId);
            event = correctPointerEvent(event);
            ////console.log('debug: ' + event.pointerId + ' GLOBALpointermove');
            if (!dragPointerIdArr.includes(event.pointerId)) return;
            const dragObj = getDragObj(event.pointerId);
            clearTouchTimeout(dragObj);
            //if pointer changes button its pressing -> turn into pointerup
            if (event.buttons !== dragObj.buttons) {
                //pointer up
                //remove listener
                if (dragObjArr.length === 1) destroyDocumentListeners();
                removeDragObj(event.pointerId);
                const outEvent = createPointerOutEvent("pointerup", event, {
                    downPageX: dragObj.downPageX,
                    downPageY: dragObj.downPageY
                });
                onPointerCallback(outEvent);
                return;
            }
            setTouchTimeout(dragObj);
            // ipad likes to do this
            if (event.pointerType === "pen" && event.pageX === dragObj.lastPageX && event.pageY === dragObj.lastPageY && event.timeStamp === dragObj.lastTimeStamp) //ignore
            return;
            const outEvent1 = createPointerOutEvent("pointermove", event, {
                downPageX: dragObj.downPageX,
                downPageY: dragObj.downPageY,
                button: buttonsToStr[event.buttons],
                pressure: event.pressure
            });
            dragObj.lastPageX = event.pageX;
            dragObj.lastPageY = event.pageY;
            dragObj.lastTimeStamp = event.timeStamp;
            onPointerCallback(outEvent1);
        }
        function onGlobalPointerUp(event) {
            //BB.throwOut('pointerup ' + event.pointerId);
            event = correctPointerEvent(event);
            ////console.log('debug: ' + event.pointerId + ' GLOBALpointerup');
            if (!dragPointerIdArr.includes(event.pointerId)) return;
            //remove listener
            if (dragObjArr.length === 1) destroyDocumentListeners();
            const dragObj = removeDragObj(event.pointerId);
            clearTouchTimeout(dragObj);
            const outEvent = createPointerOutEvent("pointerup", event, {
                downPageX: dragObj.downPageX,
                downPageY: dragObj.downPageY
            });
            onPointerCallback(outEvent);
        }
        function onGlobalPointerLeave(event) {
            //BB.throwOut('pointerleave ' + event.pointerId);
            event = correctPointerEvent(event);
            ////console.log('debug: ' + event.pointerId + ' onGlobalPointerLeave', event);
            if (!dragPointerIdArr.includes(event.pointerId)) return;
            //remove listener
            if (dragObjArr.length === 1) destroyDocumentListeners();
            const dragObj = removeDragObj(event.pointerId);
            clearTouchTimeout(dragObj);
            const outEvent = createPointerOutEvent("pointerup", event, {
                downPageX: dragObj.downPageX,
                downPageY: dragObj.downPageY
            });
            onPointerCallback(outEvent);
        }
        /*
        --- ipad pointer event glitch damage control ---

        ipad pointer events are glitchy. doesn't always fire pointerup.
        - when two fingers get really close to each other
        - when finger moves out and back in bottom

        This artificially fires a pointerup
        */ function onTouchTimeout(dragObj) {
            //create fake event
            const fakeEvent = {
                pointerId: dragObj.pointerId,
                pointerType: dragObj.pointerType,
                type: "pointerup",
                timeStamp: performance.now(),
                pageX: 0,
                pageY: 0,
                clientX: 0,
                clientY: 0,
                preventDefault: function() {},
                stopPropagation: function() {}
            };
            //call onGlobalPointerUp with it
            onGlobalPointerUp(fakeEvent);
        }
        function setTouchTimeout(dragObj) {
            if (dragObj.pointerType !== "touch") return;
            dragObj.touchTimeout = setTimeout(function() {
                onTouchTimeout(dragObj);
            }, 2500); // 2.5 seconds
        }
        function clearTouchTimeout(dragObj) {
            if (!dragObj.touchTimeout) return;
            clearTimeout(dragObj.touchTimeout);
            dragObj.touchTimeout = null;
        }
        if (onEnterLeaveCallback) {
            (0, _eventListener.addEventListener)(targetElement, "pointerenter", onPointerEnter);
            (0, _eventListener.addEventListener)(targetElement, "pointerleave", onPointerLeave);
        }
        if (onPointerCallback) {
            (0, _eventListener.addEventListener)(targetElement, "pointermove", onPointermove);
            (0, _eventListener.addEventListener)(targetElement, "pointerdown", onPointerdown);
        }
        if (onWheelCallback) (0, _eventListener.addEventListener)(targetElement, "wheel", wheelCleaner.process);
        let onTouchstart;
        let onTouchmove;
        let onTouchend;
        // --- touch fallback ---
        if (!(0, _browser.hasPointerEvents)) {
            onTouchstart = function(event) {
                ////console.log('onTouchstart', event, event.changedTouches.length);
                event.preventDefault(); // needs to stay, otherwise page scrolls on iOS12
                const touchArr = event.changedTouches;
                for(let i = 0; i < touchArr.length && dragObjArr.length < maxPointers; i++){
                    const touchObj = touchArr[i];
                    //set up global listeners
                    if (dragObjArr.length === 0) {
                        (0, _eventListener.addEventListener)(document, "touchmove", onTouchmove);
                        (0, _eventListener.addEventListener)(document, "touchend", onTouchend);
                        (0, _eventListener.addEventListener)(document, "touchcancel", onTouchend);
                    }
                    dragObjArr.push({
                        pointerId: touchObj.identifier,
                        downPageX: touchObj.pageX,
                        downPageY: touchObj.pageY,
                        buttons: 1,
                        lastPageX: touchObj.pageX,
                        lastPageY: touchObj.pageY
                    });
                    dragPointerIdArr.push(touchObj.identifier);
                    const outEvent = createTouchOutEvent("pointerdown", touchObj, event, {
                        dX: 0,
                        dY: 0,
                        downPageX: touchObj.downPageX,
                        downPageY: touchObj.downPageY,
                        button: "left",
                        pressure: 1
                    });
                    onPointerCallback(outEvent);
                }
            };
            onTouchmove = function(event) {
                event.preventDefault(); // needs to stay, otherwise page scrolls on iOS12
                const touchArr = event.changedTouches;
                for(let i = 0; i < touchArr.length; i++){
                    const touchObj = touchArr[i];
                    if (!dragPointerIdArr.includes(touchObj.identifier)) continue;
                    const dragObj = getDragObj(touchObj.identifier);
                    const outEvent = createTouchOutEvent("pointermove", touchObj, event, {
                        dX: touchObj.pageX - dragObj.lastPageX,
                        dY: touchObj.pageY - dragObj.lastPageY,
                        downPageX: dragObj.downPageX,
                        downPageY: dragObj.downPageY,
                        button: "left",
                        isCoalesced: false,
                        pressure: 1
                    });
                    dragObj.lastPageX = touchObj.pageX;
                    dragObj.lastPageY = touchObj.pageY;
                    onPointerCallback(outEvent);
                }
            };
            onTouchend = function(event) {
                if (event.type !== "touchcancel") event.preventDefault(); // needs to stay, otherwise page scrolls on iOS12
                const touchArr = event.changedTouches;
                for(let i = 0; i < touchArr.length; i++){
                    const touchObj = touchArr[i];
                    if (!dragPointerIdArr.includes(touchObj.identifier)) continue;
                    //remove listener
                    if (dragObjArr.length === 1) {
                        (0, _eventListener.removeEventListener)(document, "touchmove", onTouchmove);
                        (0, _eventListener.removeEventListener)(document, "touchend", onTouchend);
                        (0, _eventListener.removeEventListener)(document, "touchcancel", onTouchend);
                    }
                    const dragObj = removeDragObj(touchObj.identifier);
                    const outEvent = createTouchOutEvent("pointerup", touchObj, event, {
                        dX: touchObj.pageX - dragObj.lastPageX,
                        dY: touchObj.pageY - dragObj.lastPageY,
                        downPageX: dragObj.downPageX,
                        downPageY: dragObj.downPageY
                    });
                    onPointerCallback(outEvent);
                }
            };
            if (onPointerCallback) (0, _eventListener.addEventListener)(targetElement, "touchstart", onTouchstart);
        } else if (p.fixScribble) {
            //ipad scribble workaround https://developer.apple.com/forums/thread/662874
            onTouchmove = function(e) {
                e.preventDefault();
            };
            (0, _eventListener.addEventListener)(targetElement, "touchmove", onTouchmove);
        }
        // --- interface ---
        this.isOver = function() {
            return isOverCounter > 0;
        };
        this.destroy = function() {
            if (isDestroyed) return;
            isDestroyed = true;
            (0, _eventListener.removeEventListener)(targetElement, "pointerenter", onPointerEnter);
            (0, _eventListener.removeEventListener)(targetElement, "pointerleave", onPointerLeave);
            (0, _eventListener.removeEventListener)(targetElement, "pointermove", onPointermove);
            (0, _eventListener.removeEventListener)(targetElement, "pointerdown", onPointerdown);
            (0, _eventListener.removeEventListener)(targetElement, "wheel", wheelCleaner.process);
            if (dragObjArr.length > 0) destroyDocumentListeners();
            if (!(0, _browser.hasPointerEvents)) {
                (0, _eventListener.removeEventListener)(targetElement, "touchstart", onTouchstart);
                if (dragObjArr.length > 0) {
                    (0, _eventListener.removeEventListener)(document, "touchmove", onTouchmove);
                    (0, _eventListener.removeEventListener)(document, "touchend", onTouchend);
                    (0, _eventListener.removeEventListener)(document, "touchcancel", onTouchend);
                }
            } else (0, _eventListener.removeEventListener)(targetElement, "touchmove", onTouchmove);
        };
    };
}();

},{"./event-listener":"7bxtC","../base/browser":"jZRZU","../math/math":"7w6MZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7w6MZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mix", ()=>mix);
parcelHelpers.export(exports, "dist", ()=>dist);
parcelHelpers.export(exports, "distSquared", ()=>distSquared);
parcelHelpers.export(exports, "lenSquared", ()=>lenSquared);
parcelHelpers.export(exports, "pointsToAngleRad", ()=>pointsToAngleRad);
parcelHelpers.export(exports, "pointsToAngleDeg", ()=>pointsToAngleDeg);
parcelHelpers.export(exports, "isInsideRect", ()=>isInsideRect);
parcelHelpers.export(exports, "clamp", ()=>clamp);
parcelHelpers.export(exports, "rotate", ()=>rotate);
parcelHelpers.export(exports, "rotateAround", ()=>rotateAround);
parcelHelpers.export(exports, "intDxy", ()=>intDxy);
/**
 * return closest even number
 * @param f
 */ parcelHelpers.export(exports, "roundEven", ()=>roundEven);
/**
 * return closest uneven number
 * @param f
 */ parcelHelpers.export(exports, "roundUneven", ()=>roundUneven);
/**
 * round number to certain precision.
 * round(1.2345, 2) = 1.23
 * round(1.2345, 0) = 0
 * round(123, -1) = 120
 *
 * @param f
 * @param digits
 */ parcelHelpers.export(exports, "round", ()=>round);
/**
 * update target so it includes bounds
 * @param target
 * @param bounds
 */ parcelHelpers.export(exports, "updateBounds", ()=>updateBounds);
/**
 * determine overlap of bounds with width&height
 */ parcelHelpers.export(exports, "boundsInArea", ()=>boundsInArea);
function mix(a, b, f) {
    return a * (1 - f) + b * f;
}
function dist(ax, ay, bx, by) {
    return Math.sqrt(Math.pow(ax - bx, 2) + Math.pow(ay - by, 2));
}
function distSquared(ax, ay, bx, by) {
    // faster because no square-root
    return Math.pow(ax - bx, 2) + Math.pow(ay - by, 2);
}
function lenSquared(x, y) {
    // faster because no square-root
    return x * x + y * y;
}
function pointsToAngleRad(p1, p2) {
    return Math.atan2(p2.y - p1.y, p2.x - p1.x);
}
function pointsToAngleDeg(p1, p2) {
    return pointsToAngleRad(p1, p2) * 180 / Math.PI;
}
function isInsideRect(p, rect) {
    return rect.x <= p.x && p.x <= rect.x + rect.width && rect.y <= p.y && p.y <= rect.y + rect.height;
}
function clamp(num, min, max) {
    return num <= min ? min : num >= max ? max : num;
}
function rotate(x, y, deg) {
    const theta = deg * (Math.PI / 180);
    const cs = Math.cos(theta);
    const sn = Math.sin(theta);
    return {
        x: x * cs - y * sn,
        y: x * sn + y * cs
    };
}
function rotateAround(center, point, deg) {
    const rot = rotate(point.x - center.x, point.y - center.y, deg);
    rot.x += center.x;
    rot.y += center.y;
    return rot;
}
function intDxy(remainder, fDx, fDy) {
    remainder.x += fDx;
    remainder.y += fDy;
    const dX = Math.round(remainder.x);
    const dY = Math.round(remainder.y);
    remainder.x -= dX;
    remainder.y -= dY;
    return {
        dX,
        dY
    };
}
function roundEven(f) {
    if (f % 1 === 0) {
        if (f % 2 === 0) return f;
        return f + 1;
    }
    const above = Math.ceil(f);
    const below = Math.floor(f);
    if (above % 2 === 0) return above;
    else return below;
}
function roundUneven(f) {
    if (f % 1 === 0) {
        if (f % 2 === 0) return f + 1;
        return f;
    }
    const above = Math.ceil(f);
    const below = Math.floor(f);
    if (above % 2 === 1) return above;
    else return below;
}
function round(f, digits) {
    const digitMult = Math.pow(10, digits);
    return Math.round(f /* + Number.EPSILON*/  * digitMult) / digitMult;
}
function updateBounds(target, bounds) {
    if (!bounds) return target;
    if (!target) target = {
        x1: bounds.x1,
        y1: bounds.y1,
        x2: bounds.x2,
        y2: bounds.y2
    };
    else {
        target.x1 = Math.min(target.x1, bounds.x1);
        target.y1 = Math.min(target.y1, bounds.y1);
        target.x2 = Math.max(target.x2, bounds.x2);
        target.y2 = Math.max(target.y2, bounds.y2);
    }
    return target;
}
function boundsInArea(bounds, width, height) {
    let x1 = Math.max(0, bounds.x1);
    let y1 = Math.max(0, bounds.y1);
    let x2 = Math.min(width - 1, bounds.x2);
    let y2 = Math.min(height - 1, bounds.y2);
    if (x1 > x2 || y1 > y2) return null;
    return {
        x1,
        y1,
        x2,
        y2
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3yNW8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EventChain", ()=>EventChain);
parcelHelpers.export(exports, "DoubleTapper", ()=>DoubleTapper);
parcelHelpers.export(exports, "NFingerTapper", ()=>NFingerTapper);
parcelHelpers.export(exports, "PinchZoomer", ()=>PinchZoomer);
parcelHelpers.export(exports, "CoalescedExploder", ()=>CoalescedExploder);
parcelHelpers.export(exports, "OnePointerLimiter", ()=>OnePointerLimiter);
parcelHelpers.export(exports, "LinetoolProcessor", ()=>LinetoolProcessor);
parcelHelpers.export(exports, "LineSanitizer", ()=>LineSanitizer);
parcelHelpers.export(exports, "LineSmoothing", ()=>LineSmoothing);
var _math = require("../math/math");
const EventChain = function(p) {
    const chainArr = p.chainArr;
    let chainOut = ()=>undefined;
    function continueChain(i, event) {
        for(; i < chainArr.length; i++){
            event = chainArr[i].chainIn(event);
            if (event === null) return null;
        }
        chainOut(event);
        return null;
    }
    for(let i = 0; i < chainArr.length; i++)(function(i) {
        chainArr[i].setChainOut(function(event) {
            continueChain(i + 1, event);
        });
    })(i);
    // --- interface ---
    this.chainIn = function(event) {
        return continueChain(0, event);
    };
    this.setChainOut = function(func) {
        chainOut = func;
    };
};
const DoubleTapper = function(p) {
    let chainOut = function() {};
    const minSilenceBeforeDurationMs = 400;
    const maxPressedDurationMs = 300;
    const maxPressedDistancePx = 10;
    const maxInbetweenDistancePx = 19;
    const maxUpToUpDurationMs = 500;
    const maxUntilSecondDownDurationMs = 300;
    const minSilenceAfterMs = 250;
    let allowedPointerTypeArr = [
        "touch",
        "mouse",
        "pen"
    ];
    let allowedButtonArr = [
        "left"
    ];
    let sequenceArr = [];
    const pointersDownIdArr = [];
    let lastUpTime = 0;
    let nowTime = 0;
    let eventQueueArr = [];
    function fail() {
        if (sequenceArr.length === 0) return;
        clearTimeout(timeoutObj.fail);
        clearTimeout(timeoutObj.maxUntilSecondDown);
        clearTimeout(timeoutObj.success);
        timeoutObj.fail = null;
        timeoutObj.maxUntilSecondDown = null;
        timeoutObj.success = null;
        for(let i = 0; i < eventQueueArr.length; i++)chainOut(eventQueueArr[i]);
        eventQueueArr = [];
        sequenceArr = [];
    }
    // double tap achieved
    function success() {
        timeoutObj.fail = null;
        timeoutObj.success = null;
        eventQueueArr = []; // events get swallowed
        const lastSequenceItem = sequenceArr[sequenceArr.length - 1];
        sequenceArr = [];
        p.onDoubleTap({
            pageX: lastSequenceItem.pageX,
            pageY: lastSequenceItem.pageY,
            relX: lastSequenceItem.relX,
            relY: lastSequenceItem.relY
        });
    }
    const timeoutObj = {
        fail: null,
        maxUntilSecondDown: null,
        success: null
    };
    //returns false if time already up. otherwise sets up timeout
    function setupTimeout(timeoutStr, targetFunc, timeMS) {
        const diff = timeMS - nowTime;
        //console.log(fingers + ': ' + timeoutStr + ' diff', diff);
        if (diff <= 0) return false;
        timeoutObj[timeoutStr] = setTimeout(targetFunc, diff);
        return true;
    }
    /**
     * @param event object - a pointer event from BB.PointerListener
     */ function processEvent(event) {
        if (event.type === "pointerdown") pointersDownIdArr.push(event.pointerId);
        else if (event.type === "pointerup") {
            for(let i = 0; i < pointersDownIdArr.length; i++)if (pointersDownIdArr[i] === event.pointerId) {
                pointersDownIdArr.splice(i, 1);
                break;
            }
        }
        if (!allowedPointerTypeArr.includes(event.pointerType)) {
            //console.log('wrong input type -> fail');
            fail();
            return;
        }
        nowTime = performance.now();
        const lastSequenceItem = sequenceArr.length > 0 ? sequenceArr[sequenceArr.length - 1] : null;
        if (event.type === "pointerup") lastUpTime = event.time;
        if (event.type === "pointerdown") {
            if (pointersDownIdArr.length > 1) {
                //console.log('more than one pointer down -> fail');
                fail();
                return;
            }
            if (timeoutObj.success !== null) {
                //console.log('silence-after not achieved -> fail');
                fail();
                return;
            }
            if (sequenceArr.length === 0 && nowTime - lastUpTime < minSilenceBeforeDurationMs) {
                //console.log('silence before not achieved -> fail');
                fail();
                return;
            }
            if (!allowedButtonArr.includes(event.button)) {
                //console.log('wrong button -> fail', event.button, allowedButtonArr);
                fail();
                return;
            }
            if (lastSequenceItem && lastSequenceItem.isDown || sequenceArr.length > 2) {
                //console.log('jumbled -> fail');
                fail();
                return;
            }
            if (lastSequenceItem) {
                const distance = (0, _math.dist)(lastSequenceItem.position[0], lastSequenceItem.position[1], event.pageX, event.pageY);
                if (distance > maxInbetweenDistancePx) {
                    //console.log('maxInbetweenDistancePx -> reset');
                    fail();
                    if (nowTime - lastSequenceItem.time < minSilenceBeforeDurationMs) return;
                }
            }
            sequenceArr.push({
                isDown: true,
                time: nowTime,
                position: [
                    event.pageX,
                    event.pageY
                ],
                pointerId: event.pointerId
            });
            //maxUntilSecondDown
            if (sequenceArr.length > 1) clearTimeout(timeoutObj.maxUntilSecondDown);
            else if (!setupTimeout("maxUntilSecondDown", fail, event.time + maxUntilSecondDownDurationMs)) {
                //console.log('event.time + maxPressedDurationMs -> fail');
                fail();
                return;
            }
            clearTimeout(timeoutObj.fail);
            if (!setupTimeout("fail", fail, event.time + maxPressedDurationMs)) {
                //console.log('event.time + maxPressedDurationMs -> fail');
                fail();
                return;
            }
        }
        if (lastSequenceItem && event.type === "pointermove" && lastSequenceItem.pointerId === event.pointerId) {
            /*if (lastSequenceItem.pointerId !== event.pointerId) { //another pointer mixing in -> fail
                console.log('another pointer mixing in -> fail');
                fail();
                return;
            }*/ const distance1 = (0, _math.dist)(lastSequenceItem.position[0], lastSequenceItem.position[1], event.pageX, event.pageY);
            if (distance1 > maxPressedDistancePx) {
                //console.log('maxPressedDistancePx -> fail');
                fail();
                return;
            }
        }
        if (lastSequenceItem && event.type === "pointerup") {
            if (lastSequenceItem.pointerId !== event.pointerId) {
                fail();
                return;
            }
            if (nowTime >= lastSequenceItem.time + maxPressedDurationMs) {
                fail();
                return;
            }
            clearTimeout(timeoutObj.fail);
            if (sequenceArr.length < 3) {
                if (!setupTimeout("fail", fail, event.time + maxUpToUpDurationMs)) {
                    fail();
                    return;
                }
                sequenceArr = [
                    lastSequenceItem,
                    {
                        isUp: true,
                        time: nowTime,
                        position: [
                            event.pageX,
                            event.pageY
                        ]
                    }
                ];
                return;
            }
            if (nowTime < sequenceArr[1].time + maxUpToUpDurationMs) {
                // double tap almost success
                // only needs silence
                sequenceArr.push({
                    pageX: event.pageX,
                    pageY: event.pageY,
                    relX: event.relX,
                    relY: event.relY
                });
                if (!setupTimeout("success", success, event.time + minSilenceAfterMs)) fail();
            } else fail();
        }
    }
    // --- interface ---
    this.chainIn = function(event) {
        processEvent(event);
        if (sequenceArr.length === 0) {
            fail();
            return event;
        }
        // events might become a double tap -> queue
        eventQueueArr.push(event);
        return null;
    };
    this.setChainOut = function(func) {
        chainOut = func;
    };
    this.setAllowedPointerTypeArr = function(arr) {
        allowedPointerTypeArr = arr;
    };
    this.setAllowedButtonArr = function(arr) {
        allowedButtonArr = arr;
    };
};
const NFingerTapper = function(p) {
    const fingers = p.fingers;
    let chainOut = function() {};
    const minSilenceBeforeDurationMs = 50; //250;
    const maxTapMs = 500;
    const maxFirstLastFingerDownMs = 250;
    const maxPressedDistancePx = 12; //5 + fingers * 5;
    const silenceAfterDurationMs = 250;
    /*
        fingerObj = {
            pointerId: number,
            downTime: number,
            downPageX: number,
            downPageY: number,
            isUp: boolean
        }
     */ let fingerArr = [];
    let firstDownTime;
    let eventQueueArr = [];
    let lastEventTime = 0;
    const pointersDownIdArr = [];
    function fail() {
        if (eventQueueArr.length === 0) return;
        clearTimeout(timeoutObj.firstLastDownTimeout);
        clearTimeout(timeoutObj.tapTimeout);
        for(let i = 0; i < eventQueueArr.length; i++)chainOut(eventQueueArr[i]);
        eventQueueArr = [];
        fingerArr = [];
    }
    function success() {
        clearTimeout(timeoutObj.firstLastDownTimeout);
        clearTimeout(timeoutObj.tapTimeout);
        eventQueueArr = []; // events get swallowed
        fingerArr = [];
        p.onTap();
    }
    let nowTime;
    const timeoutObj = {
        firstLastDownTimeout: null,
        tapTimeout: null
    };
    function setupTimeout(timeoutStr, timeMS) {
        const diff = timeMS - nowTime;
        //console.log(fingers + ': ' + timeoutStr + ' diff', diff);
        if (diff <= 0) return false;
        timeoutObj[timeoutStr] = setTimeout(fail, diff);
        return true;
    }
    function processEvent(event) {
        const tempLastEventTime = lastEventTime;
        lastEventTime = event.time;
        if (event.type === "pointerdown") pointersDownIdArr.push(event.pointerId);
        else if (event.type === "pointerup") {
            for(let i = 0; i < pointersDownIdArr.length; i++)if (pointersDownIdArr[i] === event.pointerId) {
                pointersDownIdArr.splice(i, 1);
                break;
            }
        }
        if (event.pointerType !== "touch") {
            if (fingerArr.length > 0) fail();
            return;
        }
        nowTime = performance.now();
        if (event.type === "pointerdown") {
            //console.log('down');
            if (fingerArr.length + 1 !== pointersDownIdArr.length) {
                fail();
                return;
            }
            if (fingerArr.length === fingers) {
                //console.log(fingers + ': too many fingers down -> fail');
                fail();
                return;
            }
            if (fingerArr.length > 0 && event.time - maxFirstLastFingerDownMs > fingerArr[0].downTime) {
                //console.log(fingers + ': took too long to touch with all fingers -> fail');
                fail();
                return;
            }
            if (fingerArr.length === 0 && event.time - minSilenceBeforeDurationMs < tempLastEventTime) {
                //console.log(fingers + ': not enough silence before -> fail');
                fail();
                return;
            }
            if (fingerArr.length === 0) {
                firstDownTime = event.time;
                if (!setupTimeout("firstLastDownTimeout", event.time + maxFirstLastFingerDownMs) || !setupTimeout("tapTimeout", event.time + maxTapMs)) {
                    fail();
                    return;
                }
            }
            fingerArr.push({
                pointerId: event.pointerId,
                downTime: event.time,
                downPageX: event.pageX,
                downPageY: event.pageY
            });
            return;
        }
        if (event.type === "pointermove") {
            if (fingerArr.length === 0) //not in a gesture -> ignore
            return;
            let fingerObj = null;
            for(let i1 = 0; i1 < fingerArr.length; i1++)if (fingerArr[i1].pointerId === event.pointerId) {
                fingerObj = fingerArr[i1];
                break;
            }
            if (fingerObj === null) {
                fail();
                return;
            }
            if (event.time - maxTapMs > firstDownTime) {
                //console.log(fingers + ': tap took too long -> fail');
                fail();
                return;
            }
            const distance = (0, _math.dist)(event.pageX, event.pageY, fingerObj.downPageX, fingerObj.downPageY);
            if (distance > maxPressedDistancePx) {
                //console.log(fingers + ': a finger moved too much -> fail', distance);
                fail();
                return;
            }
        }
        if (event.type === "pointerup") {
            if (fingerArr.length === 0) //not in a gesture -> ignore
            return;
            //console.log('up', event.pageX, event.pageY);
            if (fingerArr.length !== fingers) {
                //console.log(fingers + ': not enough fingers -> fail');
                fail();
                return;
            }
            let fingerObj1 = null;
            let i2 = 0;
            for(; i2 < fingerArr.length; i2++)if (fingerArr[i2].pointerId === event.pointerId) {
                fingerObj1 = fingerArr[i2];
                break;
            }
            if (fingerObj1 === null) //do nothing
            return;
            if (event.time - maxTapMs > firstDownTime) {
                //console.log(fingers + ': tap took too long -> fail');
                fail();
                return;
            }
            const distance1 = (0, _math.dist)(event.pageX, event.pageY, fingerObj1.downPageX, fingerObj1.downPageY);
            if (distance1 > maxPressedDistancePx) {
                //console.log(fingers + ': b finger moved too much -> fail', distance, event.pageX, event.pageY);
                //console.log(fingerArr);
                fail();
                return;
            }
            fingerObj1.isUp = true;
            let allAreUp = true;
            for(let i3 = 0; i3 < fingerArr.length; i3++)if (!fingerArr[i3].isUp) {
                allAreUp = false;
                break;
            }
            //console.log('fingerArr', fingerArr);
            if (allAreUp) {
                success();
                return true;
            }
        }
    }
    // --- interface ---
    this.chainIn = function(event) {
        const result = processEvent(event);
        //console.log(fingerArr.length);
        if (result === true) //tap success -> event gets swallowed
        return null;
        if (fingerArr.length === 0) return event;
        else eventQueueArr.push(event);
        return null;
    };
    this.setChainOut = function(func) {
        chainOut = func;
    };
};
const PinchZoomer = function(p) {
    const firstFingerMaxDistancePx = 10;
    const untilSecondFingerDurationMs = 250;
    let chainOut = function() {};
    const pointersDownIdArr = [];
    /*
    gestureObj = {
        touchPointerArr: Array of {
            pointerId: number,
            relX: number,
            relY: number,
            downRelX: number, // only for first
            downRelY: number
        },
        otherPointerIdArr: number[],
        isInProgress: boolean
    }
    */ let gestureObj = null;
    let eventQueueArr = [];
    function end() {
        gestureObj = null;
        eventQueueArr = [];
    }
    function fail(doSwallow) {
        if (!gestureObj) return;
        clearTimeout(timeoutObj.secondFingerTimeout);
        if (!doSwallow) for(let i = 0; i < eventQueueArr.length; i++)chainOut(eventQueueArr[i]);
        end();
    }
    let nowTime;
    const timeoutObj = {
        secondFingerTimeout: null
    };
    function setupTimeout(timeoutStr, targetFunc, timeMS) {
        const diff = timeMS - nowTime;
        if (diff <= 0) return false;
        timeoutObj[timeoutStr] = setTimeout(targetFunc, diff);
        return true;
    }
    function processEvent(event) {
        if (event.type === "pointerdown") pointersDownIdArr.push(event.pointerId);
        else if (event.type === "pointerup") {
            for(let i = 0; i < pointersDownIdArr.length; i++)if (pointersDownIdArr[i] === event.pointerId) {
                pointersDownIdArr.splice(i, 1);
                break;
            }
        }
        //pass through scenarios
        if (!gestureObj && (event.pointerType !== "touch" || event.type === "pointermove" && pointersDownIdArr.length > 0 || pointersDownIdArr.length > 1 || event.type === "pointerup" // failed before
        )) return;
        nowTime = performance.now();
        //pointer down
        if (event.type === "pointerdown") {
            if (gestureObj) {
                if (event.pointerType === "touch") {
                    gestureObj.touchPointerArr.push({
                        pointerId: event.pointerId,
                        relX: event.relX,
                        relY: event.relY
                    });
                    if (gestureObj.isInProgress) continuePinch(gestureObj, {
                        type: "down",
                        index: gestureObj.touchPointerArr.length - 1
                    });
                    else {
                        clearTimeout(timeoutObj.secondFingerTimeout);
                        gestureObj.isInProgress = true;
                        beginPinch(gestureObj);
                    }
                    return;
                } else {
                    if (gestureObj.isInProgress) gestureObj.otherPointerIdArr.push(event.pointerId);
                    else fail();
                    return;
                }
            } else {
                // first finger down - can only be touch if no gestureObj
                gestureObj = {
                    touchPointerArr: [
                        {
                            pointerId: event.pointerId,
                            relX: event.relX,
                            relY: event.relY,
                            downRelX: event.relX,
                            downRelY: event.relY
                        }
                    ],
                    otherPointerIdArr: [],
                    isInProgress: false
                };
                if (!setupTimeout("secondFingerTimeout", function() {
                    fail();
                }, event.time + untilSecondFingerDurationMs)) {
                    fail();
                    return;
                }
                return;
            }
        }
        //pointer move
        if (event.type === "pointermove" && event.pointerType === "touch") {
            //gesture object should always exist here
            let touchPointerObj = null;
            let i1 = 0;
            for(; i1 < gestureObj.touchPointerArr.length; i1++)if (event.pointerId === gestureObj.touchPointerArr[i1].pointerId) {
                touchPointerObj = gestureObj.touchPointerArr[i1];
                break;
            }
            //null should not be possible
            touchPointerObj.relX = event.relX;
            touchPointerObj.relY = event.relY;
            if (!gestureObj.isInProgress) {
                const distance = (0, _math.dist)(touchPointerObj.downRelX, touchPointerObj.downRelY, touchPointerObj.relX, touchPointerObj.relY);
                if (distance > firstFingerMaxDistancePx) {
                    fail();
                    return;
                }
            } else if (i1 < 2) continuePinch(gestureObj, {
                type: "move",
                index: i1
            });
            return;
        }
        //pointer up
        if (event.type === "pointerup") {
            //gesture object should always exist here
            if (event.pointerType === "touch") {
                let i2 = 0;
                for(; i2 < gestureObj.touchPointerArr.length; i2++)if (gestureObj.touchPointerArr[i2].pointerId === event.pointerId) {
                    gestureObj.touchPointerArr.splice(i2, 1);
                    break;
                }
                if (gestureObj.touchPointerArr.length > 0) continuePinch(gestureObj, {
                    type: "up",
                    index: i2
                });
            } else {
                for(let i3 = 0; i3 < gestureObj.otherPointerIdArr.length; i3++)if (gestureObj.otherPointerIdArr[i3] === event.pointerId) {
                    gestureObj.otherPointerIdArr.splice(i3, 1);
                    break;
                }
            }
            //all fingers lifted?
            if (gestureObj.touchPointerArr.length === 0 && gestureObj.otherPointerIdArr.length === 0) {
                if (gestureObj.isInProgress) {
                    end();
                    endPinch();
                } else fail();
                return;
            }
        }
    }
    // --- actual pinch transform logic ---
    let pincherArr = [];
    function beginPinch(gestureObj) {
        for(let i = 0; i < gestureObj.touchPointerArr.length; i++){
            const pointerObj = gestureObj.touchPointerArr[i];
            pincherArr.push({
                pointerId: pointerObj.pointerId,
                relX: pointerObj.relX,
                relY: pointerObj.relY,
                downRelX: pointerObj.relX,
                downRelY: pointerObj.relY
            });
        }
        const event = {
            type: "move",
            angleRad: 0,
            scale: 1
        };
        if (pincherArr.length === 1) {
            event.relX = pincherArr[0].downRelX;
            event.relY = pincherArr[0].downRelY;
        } else {
            event.relX = 0.5 * (pincherArr[0].downRelX + pincherArr[1].downRelX);
            event.relY = 0.5 * (pincherArr[0].downRelY + pincherArr[1].downRelY);
        }
        event.downRelX = event.relX;
        event.downRelY = event.relY;
        p.onPinch(event);
    }
    //actionObj = {type: 'down'|'move'|'up', index: number}
    function continuePinch(gestureObj, actionObj) {
        if (actionObj.index > 1) return;
        if (actionObj.type === "move") {
            let event;
            pincherArr[actionObj.index].relX = gestureObj.touchPointerArr[actionObj.index].relX;
            pincherArr[actionObj.index].relY = gestureObj.touchPointerArr[actionObj.index].relY;
            if (pincherArr.length === 1) event = {
                type: "move",
                downRelX: pincherArr[0].downRelX,
                downRelY: pincherArr[0].downRelY,
                relX: pincherArr[0].relX,
                relY: pincherArr[0].relY,
                angleRad: 0,
                scale: 1
            };
            else {
                const startDist = (0, _math.dist)(pincherArr[0].downRelX, pincherArr[0].downRelY, pincherArr[1].downRelX, pincherArr[1].downRelY);
                const distance = (0, _math.dist)(pincherArr[0].relX, pincherArr[0].relY, pincherArr[1].relX, pincherArr[1].relY);
                const startAngle = (0, _math.pointsToAngleRad)({
                    x: pincherArr[0].downRelX,
                    y: pincherArr[0].downRelY
                }, {
                    x: pincherArr[1].downRelX,
                    y: pincherArr[1].downRelY
                });
                const angle = (0, _math.pointsToAngleRad)({
                    x: pincherArr[0].relX,
                    y: pincherArr[0].relY
                }, {
                    x: pincherArr[1].relX,
                    y: pincherArr[1].relY
                });
                event = {
                    type: "move",
                    downRelX: 0.5 * (pincherArr[0].downRelX + pincherArr[1].downRelX),
                    downRelY: 0.5 * (pincherArr[0].downRelY + pincherArr[1].downRelY),
                    relX: 0.5 * (pincherArr[0].relX + pincherArr[1].relX),
                    relY: 0.5 * (pincherArr[0].relY + pincherArr[1].relY),
                    angleRad: angle - startAngle,
                    scale: distance / startDist
                };
            }
            p.onPinch(event);
        } else if (actionObj.type === "down" || actionObj.type === "up") {
            endPinch();
            beginPinch(gestureObj);
        }
    }
    function endPinch() {
        pincherArr = [];
        p.onPinch({
            type: "end"
        });
    }
    // --- interface ---
    this.chainIn = function(event) {
        processEvent(event);
        if (gestureObj) {
            if (!gestureObj.isInProgress) eventQueueArr.push(event);
        } else return event;
        return null;
    };
    this.setChainOut = function(func) {
        chainOut = func;
    };
};
const CoalescedExploder = function() {
    let chainOut = function() {};
    // --- interface ---
    this.chainIn = function(event) {
        if (event.type === "pointermove") {
            if (event.coalescedArr.length > 0) {
                let eventCopy = JSON.parse(JSON.stringify(event));
                eventCopy.coalescedArr = [];
                let coalescedItem;
                for(let i = 0; i < event.coalescedArr.length; i++){
                    if (i > 0) eventCopy = JSON.parse(JSON.stringify(event));
                    coalescedItem = event.coalescedArr[i];
                    eventCopy.pageX = coalescedItem.pageX;
                    eventCopy.pageY = coalescedItem.pageY;
                    eventCopy.relX = coalescedItem.relX;
                    eventCopy.relY = coalescedItem.relY;
                    eventCopy.dX = coalescedItem.dX;
                    eventCopy.dY = coalescedItem.dY;
                    eventCopy.time = coalescedItem.time;
                    if (i < event.coalescedArr.length - 1) eventCopy.isCoalesced = true;
                    chainOut(eventCopy);
                }
            } else return event;
        } else return event;
        return null;
    };
    this.setChainOut = function(func) {
        chainOut = func;
    };
};
const OnePointerLimiter = function(pointers) {
    let chainOut = function() {};
    let downPointerId = null;
    const ignorePointerIdArr = [];
    // --- interface ---
    this.chainIn = function(event) {
        if (ignorePointerIdArr.includes(event.pointerId)) {
            if (event.type === "pointerup") {
                for(let i = 0; i < ignorePointerIdArr.length; i++)if (ignorePointerIdArr[i] === event.pointerId) {
                    ignorePointerIdArr.splice(i, 1);
                    break;
                }
            }
            return null;
        }
        if (downPointerId === null) {
            if (event.type === "pointerdown") downPointerId = event.pointerId;
            return event;
        } else {
            if (event.pointerId !== downPointerId) {
                if (event.type === "pointerdown") ignorePointerIdArr.push(event.pointerId);
                return null;
            }
            if (event.type === "pointerup") downPointerId = null;
            return event;
        }
        return null;
    };
    this.setChainOut = function(func) {
        chainOut = func;
    };
};
const LinetoolProcessor = function(p) {
    let downEvent = null;
    let eventQueue = [];
    let direction = null;
    const DIR_X = 0, DIR_Y = 1;
    this.process = function(event) {
        if (event.type === "down") {
            downEvent = event;
            direction = null;
            if (event.shiftIsPressed) {
                p.onDraw({
                    type: "line",
                    x0: null,
                    y0: null,
                    pressure0: null,
                    x1: event.x,
                    y1: event.y,
                    pressure1: event.pressure
                });
                eventQueue.push(event);
                return;
            }
        }
        if (event.type === "move") {
            if (event.shiftIsPressed) {
                if (direction === null) {
                    const dX = Math.abs(event.x - downEvent.x);
                    const dY = Math.abs(event.y - downEvent.y);
                    if (dX > 5 || dY > 5) {
                        direction = dX > dY ? DIR_X : DIR_Y;
                        for(let i = 0; i < eventQueue.length; i++){
                            const e = eventQueue[i];
                            if (direction === DIR_X) e.y = downEvent.y;
                            else e.x = downEvent.x;
                            p.onDraw(JSON.parse(JSON.stringify(e)));
                        }
                        eventQueue = [];
                    }
                }
                if (direction === null) {
                    eventQueue.push(event);
                    return;
                }
                if (direction === DIR_X) event.y = downEvent.y;
                else event.x = downEvent.x;
            } else if (eventQueue.length > 0) {
                for(let i1 = 0; i1 < eventQueue.length; i1++)p.onDraw(JSON.parse(JSON.stringify(eventQueue[i1])));
                eventQueue = [];
            }
        }
        if (event.type === "up") eventQueue = [];
        p.onDraw(JSON.parse(JSON.stringify(event)));
    };
};
const LineSanitizer = function() {
    let chainOut = function() {};
    let isDrawing = false;
    // --- interface ---
    this.chainIn = function(event) {
        if (event.type === "down") {
            if (isDrawing) //console.log('line sanitizer - down, but already drawing');
            chainOut({
                type: "up",
                scale: event.scale,
                shiftIsPressed: event.shiftIsPressed,
                isCoalesced: false
            });
            else isDrawing = true;
        }
        if (!isDrawing && (event.type === "move" || event.type === "up")) //console.log('line sanitizer - ' + event.type + ' but not drawing');
        return null;
        if (event.type === "up" && isDrawing) isDrawing = false;
        return event;
    };
    this.setChainOut = function(func) {
        chainOut = func;
    };
    this.getIsDrawing = function() {
        return isDrawing;
    };
};
const LineSmoothing = function(p) {
    let chainOut = function() {};
    let smoothing = (0, _math.clamp)(p.smoothing, 0, 1);
    let lastMixedInput;
    let interval;
    let timeout;
    // --- interface ---
    this.chainIn = function(event) {
        event = JSON.parse(JSON.stringify(event));
        clearTimeout(timeout);
        clearInterval(interval);
        if (event.type === "down") lastMixedInput = {
            x: event.x,
            y: event.y,
            pressure: event.pressure
        };
        if (event.type === "move") {
            const inputX = event.x;
            const inputY = event.y;
            const inputPressure = event.pressure;
            event.x = (0, _math.mix)(event.x, lastMixedInput.x, smoothing);
            event.y = (0, _math.mix)(event.y, lastMixedInput.y, smoothing);
            event.pressure = (0, _math.mix)(event.pressure, lastMixedInput.pressure, smoothing);
            lastMixedInput = {
                x: event.x,
                y: event.y,
                pressure: event.pressure
            };
            if (smoothing > 0) timeout = setTimeout(function() {
                interval = setInterval(function() {
                    event = JSON.parse(JSON.stringify(event));
                    event.x = (0, _math.mix)(inputX, lastMixedInput.x, smoothing);
                    event.y = (0, _math.mix)(inputY, lastMixedInput.y, smoothing);
                    event.pressure = (0, _math.mix)(inputPressure, lastMixedInput.pressure, smoothing);
                    lastMixedInput = {
                        x: event.x,
                        y: event.y,
                        pressure: event.pressure
                    };
                    chainOut(event);
                }, 35);
            }, 80);
        }
        return event;
    };
    this.setChainOut = function(func) {
        chainOut = func;
    };
    this.setSmoothing = function(s) {
        smoothing = (0, _math.clamp)(s, 0, 1);
    };
};

},{"../math/math":"7w6MZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d7Vt7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "copyCanvas", ()=>copyCanvas);
/**
 * Determine if should disable imageSmoothing for transformation.
 * ImageSmoothing can make images blurry even when they're in the original scale and aligned with the pixelgrid.
 */ parcelHelpers.export(exports, "testShouldPixelate", ()=>testShouldPixelate);
/**
 * @param destCtx - the canvas that will be drawn on
 * @param transformImage - image that will be drawn on canvas
 * @param transform - {x, y, width, height, angle} - x and y are center of transformImage
 * @param bounds object - optional {x, y, width, height} - crop of transformImage in transformImage image space
 * @param pixelated
 */ parcelHelpers.export(exports, "drawTransformedImageWithBounds", ()=>drawTransformedImageWithBounds);
/**
 * all transformations are optional
 * center is the point around which will be scaled and rotated
 *
 * @param baseCanvas canvas - the canvas that will be drawn on
 * @param transformImage image|canvas - image that will be drawn on canvas
 * @param transformObj {center: {x, y}, scale: {x, y}, translate: {x, y}, angleDegree}
 */ parcelHelpers.export(exports, "drawTransformedImageOnCanvas", ()=>drawTransformedImageOnCanvas);
parcelHelpers.export(exports, "createCheckerCanvas", ()=>createCheckerCanvas);
parcelHelpers.export(exports, "createCheckerDataUrl", ()=>createCheckerDataUrl);
/**
 * smooth resize image
 * @param canvas canvas - will be resized (modified)
 * @param w
 * @param h
 * @param tmp1 canvas - optional, provide to save resources
 * @param tmp2 canvas - optional, provide to save resources
 */ parcelHelpers.export(exports, "resizeCanvas", ()=>resizeCanvas);
/**
 * puts naive greyscale version of image into alpha channel.
 * only writes a, doesn't write rgb
 * @param canvas
 */ parcelHelpers.export(exports, "convertToAlphaChannelCanvas", ()=>convertToAlphaChannelCanvas);
/**
 * Sometimes garbage collection is too slow, and canvases use up too much memory,
 * or there is a hard to fix memory leak.
 * This function manually makes the canvas use as little memory as possible.
 */ parcelHelpers.export(exports, "freeCanvas", ()=>freeCanvas);
/**
 * Determine bounding box that describes all pixels which are not fully transparent.
 * Returns null if empty.
 *
 * @param context
 */ parcelHelpers.export(exports, "canvasBounds", ()=>canvasBounds);
var _createCanvas = require("./create-canvas");
function copyCanvas(canvas) {
    const resultCanvas = (0, _createCanvas.createCanvas)(canvas.width, canvas.height);
    const ctx = resultCanvas.getContext("2d");
    if (!ctx) throw new Error("2d context not supported or canvas already initialized");
    ctx.drawImage(canvas, 0, 0);
    return resultCanvas;
}
function testShouldPixelate(transform, scaleX, scaleY) {
    if (![
        1,
        -1
    ].includes(scaleX) || ![
        1,
        -1
    ].includes(scaleY) || transform.width % 1 !== 0 || transform.height % 1 !== 0 || Math.abs(transform.angleDeg) % 90 !== 0) return false;
    const whSwapped = Math.abs(transform.angleDeg - 90) % 180 === 0;
    const width = whSwapped ? transform.height : transform.width;
    const height = whSwapped ? transform.width : transform.height;
    return (Math.abs(width) % 2 === 0 && transform.x % 1 === 0 || Math.abs(width) % 2 === 1 && transform.x % 1 === 0.5) && (Math.abs(height) % 2 === 0 && transform.y % 1 === 0 || Math.abs(height) % 2 === 1 && transform.y % 1 === 0.5);
}
function drawTransformedImageWithBounds(destCtx, transformImage, transform, bounds, pixelated) {
    if (!bounds) bounds = {
        x: 0,
        y: 0,
        width: transformImage.width,
        height: transformImage.height
    };
    destCtx.save();
    if (pixelated) destCtx.imageSmoothingEnabled = false;
    else {
        destCtx.imageSmoothingEnabled = true;
        destCtx.imageSmoothingQuality = "high";
    }
    destCtx.translate(transform.x, transform.y);
    destCtx.rotate(transform.angleDeg / 180 * Math.PI);
    destCtx.scale(transform.width > 0 ? 1 : -1, transform.height > 0 ? 1 : -1);
    destCtx.drawImage(transformImage, bounds.x, bounds.y, bounds.width, bounds.height, -Math.abs(transform.width) / 2, -Math.abs(transform.height) / 2, Math.abs(transform.width), Math.abs(transform.height));
    destCtx.restore();
}
function drawTransformedImageOnCanvas(baseCanvas, transformImage, transformObj) {
    transformObj = JSON.parse(JSON.stringify(transformObj));
    if (!transformObj.center) transformObj.center = {
        x: transformImage.width / 2,
        y: transformImage.height / 2
    };
    if (!transformObj.scale) transformObj.scale = {
        x: 1,
        y: 1
    };
    if (!transformObj.angleDegree) transformObj.angleDegree = 0;
    if (!transformObj.translate) transformObj.translate = {
        x: 0,
        y: 0
    };
    const ctx = baseCanvas.getContext("2d");
    if (!ctx) throw new Error("2d context not supported or canvas already initialized");
    ctx.save();
    if (Math.abs(transformObj.scale.x - 1) > 0.000001 || Math.abs(transformObj.scale.y - 1) > 0.000001 || Math.abs(transformObj.angleDegree % 90) > 0.000001) {
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";
    } else ctx.imageSmoothingEnabled = false;
    ctx.translate(transformObj.translate.x, transformObj.translate.y);
    ctx.translate(transformObj.center.x, transformObj.center.y);
    ctx.rotate(transformObj.angleDegree / 180 * Math.PI);
    ctx.scale(transformObj.scale.x, transformObj.scale.y);
    ctx.translate(-transformObj.center.x, -transformObj.center.y);
    ctx.drawImage(transformImage, 0, 0, transformImage.width, transformImage.height);
    ctx.restore();
}
const createCheckerCanvas = function(size) {
    const canvas = (0, _createCanvas.createCanvas)();
    let ctx;
    if (size < 1) {
        canvas.width = 1;
        canvas.height = 1;
        ctx = canvas.getContext("2d");
        if (!ctx) throw new Error("2d context not supported or canvas already initialized");
        ctx.fillStyle = "rgb(128, 128, 128)";
        ctx.fillRect(0, 0, 1, 1);
    } else if (size > 200) {
        canvas.width = 401;
        canvas.height = 401;
    } else {
        canvas.width = size * 2;
        canvas.height = size * 2;
        ctx = canvas.getContext("2d");
        if (!ctx) throw new Error("2d context not supported or canvas already initialized");
        ctx.fillStyle = "rgb(255, 255, 255)";
        ctx.fillRect(0, 0, size * 2, size * 2);
        ctx.fillStyle = "rgb(200, 200, 200)";
        ctx.fillRect(0, 0, size, size);
        ctx.fillRect(size, size, size * 2, size * 2);
    }
    return canvas;
};
const createCheckerDataUrl = function() {
    const cache = {
        "8": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAMElEQVQ4T2M8ceLEfwY8wNzcHJ80A+OoAcMiDP7//483HZw8eRJ/Ohg1gIFx6IcBAIhJUqnarXQ1AAAAAElFTkSuQmCC",
        "4": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAJ0lEQVQoU2M8ceLEfwYkYG5ujsxlYKSDgv///6O44eTJk6huoL0CAGsOKVVu8UYvAAAAAElFTkSuQmCC"
    };
    return function(size, callback) {
        function create(size) {
            size = parseInt("" + size);
            if (cache["" + size]) return cache["" + size];
            const canvas = createCheckerCanvas(size);
            const result = canvas.toDataURL("image/png");
            cache["" + size] = result;
            return result;
        }
        if (callback) setTimeout(function() {
            callback(create(size));
        }, 1);
        else return create(size);
    };
}();
function resizeCanvas(canvas, w, h, tmp1, tmp2) {
    //determine base 2 exponents of old and new size
    function getBase2Obj(oldW, oldH, newW, newH) {
        const result = {
            oldWidthEx: Math.round(Math.log2(oldW)),
            oldHeightEx: Math.round(Math.log2(oldH)),
            newWidthEx: Math.ceil(Math.log2(newW)),
            newHeightEx: Math.ceil(Math.log2(newH))
        };
        result.oldWidthEx = Math.max(result.oldWidthEx, result.newWidthEx);
        result.oldHeightEx = Math.max(result.oldHeightEx, result.newHeightEx);
        return result;
    }
    if (!w || !h || w === canvas.width && h === canvas.height) return;
    w = Math.max(w, 1);
    h = Math.max(h, 1);
    if (w <= canvas.width && h <= canvas.height) {
        tmp1 = !tmp1 ? (0, _createCanvas.createCanvas)() : tmp1;
        tmp2 = !tmp2 ? (0, _createCanvas.createCanvas)() : tmp2;
        const base2 = getBase2Obj(canvas.width, canvas.height, w, h);
        //initially scale to a base of 2. unless new size is too close to old. e.g. sizing from 900 to 600
        tmp2.width = base2.oldWidthEx > base2.newWidthEx ? Math.pow(2, base2.oldWidthEx) : w;
        tmp2.height = base2.oldHeightEx > base2.newHeightEx ? Math.pow(2, base2.oldHeightEx) : h;
        tmp1.getContext("2d").save();
        tmp2.getContext("2d").save();
        let ew, eh;
        let buffer1 = tmp1, buffer2 = tmp2;
        ew = base2.oldWidthEx;
        eh = base2.oldHeightEx;
        let bufferCtx = buffer2.getContext("2d");
        bufferCtx.imageSmoothingEnabled = true;
        bufferCtx.imageSmoothingQuality = "high";
        bufferCtx.globalCompositeOperation = "copy";
        bufferCtx.drawImage(canvas, 0, 0, buffer2.width, buffer2.height);
        let currentWidth = buffer2.width;
        let currentHeight = buffer2.height;
        //stepwise half the size
        for(; ew > base2.newWidthEx || eh > base2.newHeightEx; ew--, eh--){
            bufferCtx = buffer1.getContext("2d");
            bufferCtx.imageSmoothingEnabled = true;
            bufferCtx.imageSmoothingQuality = "high";
            bufferCtx.globalCompositeOperation = "copy";
            const newWidth = ew > base2.newWidthEx ? currentWidth / 2 : currentWidth;
            const newHeight = eh > base2.newHeightEx ? currentHeight / 2 : currentHeight;
            //buffer also needs to be properly sized, unfortunately
            buffer1.width = newWidth;
            buffer1.height = newHeight;
            bufferCtx.drawImage(buffer2, 0, 0, currentWidth, currentHeight, 0, 0, newWidth, newHeight);
            currentWidth = newWidth;
            currentHeight = newHeight;
            //swap
            const tmp = buffer1;
            buffer1 = buffer2;
            buffer2 = tmp;
        }
        //when no longer can be halved, bring to target size
        canvas.width = w;
        canvas.height = h;
        const canvasCtx = canvas.getContext("2d");
        canvasCtx.save();
        canvasCtx.imageSmoothingEnabled = true;
        canvasCtx.imageSmoothingQuality = "high";
        canvasCtx.drawImage(buffer2, 0, 0, currentWidth, currentHeight, 0, 0, w, h);
        canvasCtx.restore();
        tmp1.getContext("2d").restore();
        tmp2.getContext("2d").restore();
    } else if (w >= canvas.width && h >= canvas.height) {
        tmp1 = !tmp1 ? (0, _createCanvas.createCanvas)() : tmp1;
        tmp1.width = w;
        tmp1.height = h;
        const tmp1Ctx = tmp1.getContext("2d");
        tmp1Ctx.save();
        tmp1Ctx.imageSmoothingEnabled = true;
        tmp1Ctx.imageSmoothingQuality = "high";
        tmp1Ctx.drawImage(canvas, 0, 0, w, h);
        tmp1Ctx.restore();
        canvas.width = w;
        canvas.height = h;
        canvas.getContext("2d").drawImage(tmp1, 0, 0);
    } else {
        resizeCanvas(canvas, w, canvas.height, tmp1, tmp2);
        resizeCanvas(canvas, w, h, tmp1, tmp2);
    }
}
function convertToAlphaChannelCanvas(canvas) {
    const imdat = canvas.getContext("2d").getImageData(0, 0, canvas.width, canvas.height);
    for(let i = 0; i < imdat.data.length; i += 4){
        if (imdat.data[i + 3] === 0) continue;
        imdat.data[i + 3] = (imdat.data[i] + imdat.data[i + 1] + imdat.data[i + 2]) / 3 * (imdat.data[i + 3] / 255);
    }
    canvas.getContext("2d").putImageData(imdat, 0, 0);
}
function freeCanvas(canvas) {
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext("2d");
    ctx && ctx.clearRect(0, 0, 1, 1);
}
function canvasBounds(context) {
    let boundsObj = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    };
    {
        let tempBounds = {
            x1: null,
            y1: null,
            x2: null,
            y2: null
        };
        let imdat = context.getImageData(0, 0, context.canvas.width, context.canvas.height);
        if (imdat.data[3] > 0 && imdat.data[imdat.data.length - 1] > 0) {
            tempBounds.x1 = 0;
            tempBounds.y1 = 0;
            tempBounds.x2 = context.canvas.width - 1;
            tempBounds.y2 = context.canvas.height - 1;
        } else {
            for(let i = 3; i < imdat.data.length; i += 4)if (imdat.data[i] > 0) {
                let x = (i - 3) / 4 % context.canvas.width;
                let y = Math.floor((i - 3) / 4 / context.canvas.width);
                if (tempBounds.x1 > x || tempBounds.x1 === null) tempBounds.x1 = x;
                if (tempBounds.y1 === null) tempBounds.y1 = y;
                if (tempBounds.x2 < x || tempBounds.x2 === null) tempBounds.x2 = x;
                if (tempBounds.y2 < y || tempBounds.y2 === null) tempBounds.y2 = y;
            }
        }
        if (tempBounds.x1 === null || tempBounds.y1 === null) return null;
        boundsObj.x = tempBounds.x1;
        boundsObj.y = tempBounds.y1;
        boundsObj.width = tempBounds.x2 - tempBounds.x1 + 1;
        boundsObj.height = tempBounds.y2 - tempBounds.y1 + 1;
    }
    return boundsObj;
}

},{"./create-canvas":"4BLUK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k5NsM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Matrix", ()=>Matrix);
const Matrix = function() {
    // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Matrix_math_for_the_web
    // yes not optimized - but it's not used for physics simulations.
    // const perfTotal = 0;
    // point ‚Ä¢ matrix
    function multiplyMatrixAndPoint(matrix, point) {
        const result = [
            point[0] * matrix[0] + point[1] * matrix[4] + point[2] * matrix[8] + point[3] * matrix[12],
            point[0] * matrix[1] + point[1] * matrix[5] + point[2] * matrix[9] + point[3] * matrix[13],
            point[0] * matrix[2] + point[1] * matrix[6] + point[2] * matrix[10] + point[3] * matrix[14],
            point[0] * matrix[3] + point[1] * matrix[7] + point[2] * matrix[11] + point[3] * matrix[15] // w
        ];
        return result;
    }
    //matrixB ‚Ä¢ matrixA
    function multiplyMatrices(matrixA, matrixB) {
        // Slice the second matrix up into rows
        const row0 = [
            matrixB[0],
            matrixB[1],
            matrixB[2],
            matrixB[3]
        ];
        const row1 = [
            matrixB[4],
            matrixB[5],
            matrixB[6],
            matrixB[7]
        ];
        const row2 = [
            matrixB[8],
            matrixB[9],
            matrixB[10],
            matrixB[11]
        ];
        const row3 = [
            matrixB[12],
            matrixB[13],
            matrixB[14],
            matrixB[15]
        ];
        // Multiply each row by matrixA
        const result0 = multiplyMatrixAndPoint(matrixA, row0);
        const result1 = multiplyMatrixAndPoint(matrixA, row1);
        const result2 = multiplyMatrixAndPoint(matrixA, row2);
        const result3 = multiplyMatrixAndPoint(matrixA, row3);
        // Turn the result rows back into a single matrix
        return [
            result0[0],
            result0[1],
            result0[2],
            result0[3],
            result1[0],
            result1[1],
            result1[2],
            result1[3],
            result2[0],
            result2[1],
            result2[2],
            result2[3],
            result3[0],
            result3[1],
            result3[2],
            result3[3]
        ];
    }
    function createTranslationMatrix(x, y) {
        return [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            x,
            y,
            0,
            1
        ];
    }
    function createRotationMatrix(angleRad) {
        //let angleRad = angleDeg / 360 * 2 * Math.PI;
        return [
            Math.cos(-angleRad),
            -Math.sin(-angleRad),
            0,
            0,
            Math.sin(-angleRad),
            Math.cos(-angleRad),
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ];
    }
    function createScaleMatrix(f) {
        return [
            f,
            0,
            0,
            0,
            0,
            f,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ];
    }
    return {
        getIdentity: function() {
            return [
                1,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                1
            ];
        },
        multiplyMatrixAndPoint: multiplyMatrixAndPoint,
        multiplyMatrices: multiplyMatrices,
        createTranslationMatrix: createTranslationMatrix,
        createRotationMatrix: createRotationMatrix,
        createScaleMatrix: createScaleMatrix
    };
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eFVNh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Vec2", ()=>Vec2);
const Vec2 = {
    add: function(p1, p2) {
        return {
            x: p1.x + p2.x,
            y: p1.y + p2.y
        };
    },
    sub: function(p1, p2) {
        return {
            x: p1.x - p2.x,
            y: p1.y - p2.y
        };
    },
    nor: function(p) {
        const len = Math.sqrt(Math.pow(p.x, 2) + Math.pow(p.y, 2));
        return {
            x: p.x / len,
            y: p.y / len
        };
    },
    len: function(p) {
        return Math.sqrt(Math.pow(p.x, 2) + Math.pow(p.y, 2));
    },
    dist: function(p1, p2) {
        return Vec2.len(Vec2.sub(p1, p2));
    },
    mul: function(p, s) {
        return {
            x: p.x * s,
            y: p.y * s
        };
    },
    angle: function(p1, p2) {
        return Math.atan2(p2.y - p1.y, p2.x - p1.x);
    },
    dot: function(a, b) {
        const aArr = [
            a.x,
            a.y
        ];
        const bArr = [
            b.x,
            b.y
        ];
        return aArr.map((x, i)=>aArr[i] * bArr[i]).reduce((m, n)=>m + n);
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ewgfM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "projectPointOnLine", ()=>projectPointOnLine);
parcelHelpers.export(exports, "PointLine", ()=>PointLine);
parcelHelpers.export(exports, "BezierLine", ()=>BezierLine);
parcelHelpers.export(exports, "SplineInterpolator", ()=>SplineInterpolator);
parcelHelpers.export(exports, "quadraticSplineInput", ()=>quadraticSplineInput);
var _vec2 = require("./vec2");
var _math = require("./math");
const projectPointOnLine = function(lineStart, lineEnd, p) {
    let x, y;
    if (lineStart.x === lineEnd.x) {
        x = lineStart.x;
        y = p.y;
        return {
            x: x,
            y: y
        };
    }
    const m = (lineEnd.y - lineStart.y) / (lineEnd.x - lineStart.x);
    const b = lineStart.y - m * lineStart.x;
    x = (m * p.y + p.x - m * b) / (m * m + 1);
    y = (m * m * p.y + m * p.x + b) / (m * m + 1);
    return {
        x: x,
        y: y
    };
};
const PointLine = function(params) {
    const segmentArr = [];
    const _this = this;
    for(let i = 0; i < params.points.length; i++)(function(i) {
        let length = undefined;
        if (i < params.points.length - 1) length = (0, _math.dist)(params.points[i].x, params.points[i].y, params.points[i + 1].x, params.points[i + 1].y);
        segmentArr[i] = {
            x: params.points[i].x,
            y: params.points[i].y,
            length: length
        };
    })(i);
    /**
     * @param dist number - distance in pixels, > 0
     * @returns {{x: number, y: number}}
     */ this.getAtDist = function(dist) {
        let remainder = Math.min(_this.getLength(), dist);
        let i = 0;
        for(; remainder > segmentArr[i].length && i < segmentArr.length - 2; i++)remainder -= segmentArr[i].length;
        const fac = Math.min(1, Math.max(0, remainder / segmentArr[i].length));
        return {
            x: segmentArr[i].x * (1 - fac) + segmentArr[i + 1].x * fac,
            y: segmentArr[i].y * (1 - fac) + segmentArr[i + 1].y * fac
        };
    };
    this.getLength = function() {
        let result = 0;
        for(let i = 0; i < segmentArr.length - 1; i++)result += segmentArr[i].length;
        return result;
    };
};
const BezierLine = function() {
    const _this = this;
    const pointArr = [];
    let lastDot = 0;
    let lastPoint;
    let lastCallbackPoint;
    let lastAngle;
    let lastSpacing = null;
    /**
     * creates bezier curve from control points
     *
     * @param p1 - control point 1 {x: float, y: float}
     * @param p2 - control point 2 {x: float, y: float}
     * @param p3 - control point 3 {x: float, y: float}
     * @param p4 - control point 4 {x: float, y: float}
     * @param resolution - int
     * @returns {Array} - bezier curve made up of points {x: float, y: float}
     */ function getBezierPoints(p1, p2, p3, p4, resolution) {
        const curvePoints = [];
        let t, result;
        for(let i = 0; i <= resolution; i++){
            t = i / resolution;
            result = {};
            result.x = Math.pow(1 - t, 3) * p1.x + 3 * Math.pow(1 - t, 2) * t * p2.x + 3 * (1 - t) * Math.pow(t, 2) * p3.x + Math.pow(t, 3) * p4.x;
            result.y = Math.pow(1 - t, 3) * p1.y + 3 * Math.pow(1 - t, 2) * t * p2.y + 3 * (1 - t) * Math.pow(t, 2) * p3.y + Math.pow(t, 3) * p4.y;
            curvePoints[curvePoints.length] = result;
        }
        return curvePoints;
    }
    /**
     *
     * add now point to line
     * line will go until the previous point
     *
     * @param x - coord of new point
     * @param y - coord of new point
     * @param spacing - space between each step
     * @param callback - calls for each step - x, y, t - t is 0-1 how far along
     * @param controlsCallback - calls that callback with the bezier control points p1, p2, p3, p4 - each {x: float, y: float}
     */ this.add = function(x, y, spacing, callback, controlsCallback) {
        if (lastPoint && x === lastPoint.x && y === lastPoint.y) return;
        lastPoint = {
            x: x,
            y: y
        };
        pointArr[pointArr.length] = {
            x: x,
            y: y,
            spacing: spacing
        };
        //calculate directions
        if (pointArr.length === 1) {
            lastSpacing = spacing;
            return;
        } else if (pointArr.length === 2) {
            pointArr[0].dir = (0, _vec2.Vec2).nor((0, _vec2.Vec2).sub(pointArr[1], pointArr[0]));
            lastDot = spacing;
            lastSpacing = spacing;
            return;
        } else {
            const pointM1 = pointArr[pointArr.length - 1];
            const pointM2 = pointArr[pointArr.length - 2];
            const pointM3 = pointArr[pointArr.length - 3];
            pointM2.dir = (0, _vec2.Vec2).nor((0, _vec2.Vec2).sub(pointM1, pointM3));
            if (isNaN(pointM2.dir.x) || isNaN(pointM2.dir.y)) //when xy -3 == -1
            pointM2.dir = JSON.parse(JSON.stringify(pointM3.dir));
        }
        //get bezier curve
        const a = pointArr[pointArr.length - 3];
        const b = pointArr[pointArr.length - 2];
        const p1 = a;
        const p2 = (0, _vec2.Vec2).add(a, (0, _vec2.Vec2).mul(a.dir, (0, _vec2.Vec2).dist(a, b) / 4));
        const p3 = (0, _vec2.Vec2).sub(b, (0, _vec2.Vec2).mul(b.dir, (0, _vec2.Vec2).dist(a, b) / 4));
        const p4 = b;
        let pointLine;
        if (callback) {
            let curvePoints;
            curvePoints = getBezierPoints(p1, p2, p3, p4, 20);
            pointLine = new PointLine({
                points: curvePoints
            });
        } else pointLine = new PointLine({
            points: [
                p1,
                p4
            ]
        });
        //interate over curve with spacing and callback
        const len = pointLine.getLength();
        let tempSpacing = (0, _math.mix)(lastSpacing, spacing, (0, _math.clamp)(lastDot / len, 0, 1));
        let d = lastDot;
        for(; d <= len; d += tempSpacing){
            tempSpacing = (0, _math.mix)(lastSpacing, spacing, (0, _math.clamp)(d / len, 0, 1));
            const point = pointLine.getAtDist(d);
            const angle = lastCallbackPoint ? (0, _math.pointsToAngleDeg)(lastCallbackPoint, point) : undefined;
            if (callback) callback({
                x: point.x,
                y: point.y,
                t: d / len,
                angle: angle,
                dAngle: lastCallbackPoint ? angle - lastAngle : 0
            });
            lastCallbackPoint = point;
            lastAngle = angle;
        }
        if (callback) lastDot = d - len;
        else {
            lastDot = 0;
            controlsCallback({
                p1: p1,
                p2: p2,
                p3: p3,
                p4: p4
            });
        }
        lastSpacing = spacing;
    };
    this.addFinal = function(spacing, callback, controlsCallback) {
        if (pointArr.length < 2) return;
        const p1 = pointArr[pointArr.length - 2];
        const p2 = pointArr[pointArr.length - 1];
        const newP = (0, _vec2.Vec2).add(p2, (0, _vec2.Vec2).sub(p2, p1));
        _this.add(newP.x, newP.y, spacing, callback, controlsCallback);
    };
};
const SplineInterpolator = function(points) {
    const n = points.length;
    this.xa = [];
    this.ya = [];
    this.u = [];
    this.y2 = [];
    let i;
    const first = points[0][0];
    const last = points[points.length - 1][0];
    points.sort(function(a, b) {
        return a[0] - b[0];
    });
    for(i = 0; i < n; i++){
        this.xa.push(points[i][0]);
        this.ya.push(points[i][1]);
    }
    this.u[0] = 0;
    this.y2[0] = 0;
    for(i = 1; i < n - 1; ++i){
        // This is the decomposition loop of the tridiagonal algorithm.
        // y2 and u are used for temporary storage of the decomposed factors.
        const wx = this.xa[i + 1] - this.xa[i - 1];
        const sig = (this.xa[i] - this.xa[i - 1]) / wx;
        const p = sig * this.y2[i - 1] + 2.0;
        this.y2[i] = (sig - 1.0) / p;
        const ddydx = (this.ya[i + 1] - this.ya[i]) / (this.xa[i + 1] - this.xa[i]) - (this.ya[i] - this.ya[i - 1]) / (this.xa[i] - this.xa[i - 1]);
        this.u[i] = (6.0 * ddydx / wx - sig * this.u[i - 1]) / p;
    }
    this.y2[n - 1] = 0;
    // This is the backsubstitution loop of the tridiagonal algorithm
    for(i = n - 2; i >= 0; --i)this.y2[i] = this.y2[i] * this.y2[i + 1] + this.u[i];
    this.getFirstX = function() {
        return first;
    };
    this.getLastX = function() {
        return last;
    };
};
SplineInterpolator.prototype.interpolate = function(x) {
    const n = this.ya.length;
    let klo = 0;
    let khi = n - 1;
    // We will find the right place in the table by means of
    // bisection. This is optimal if sequential calls to this
    // routine are at random values of x. If sequential calls
    // are in order, and closely spaced, one would do better
    // to store previous values of klo and khi.
    while(khi - klo > 1){
        const k = khi + klo >> 1;
        if (this.xa[k] > x) khi = k;
        else klo = k;
    }
    const h = this.xa[khi] - this.xa[klo];
    const a = (this.xa[khi] - x) / h;
    const b = (x - this.xa[klo]) / h;
    // Cubic spline polynomial is now evaluated.
    return a * this.ya[klo] + b * this.ya[khi] + ((a * a * a - a) * this.y2[klo] + (b * b * b - b) * this.y2[khi]) * (h * h) / 6.0;
};
/**
 * find x to y. simply by stepping through. suboptimal, so don't call often.
 * searches in x 0-1 range
 *
 * @param y
 * @param resolution
 */ SplineInterpolator.prototype.findX = function(y, resolution) {
    let x = null;
    let dist = null;
    for(let i = 0; i <= resolution; i++){
        const tempX = i / resolution;
        const tempY = this.interpolate(tempX);
        if (x === null) {
            x = tempX;
            dist = Math.abs(tempY - y);
            continue;
        }
        const tempDist = Math.abs(tempY - y);
        if (tempDist < dist) {
            x = tempX;
            dist = tempDist;
        } else break;
    }
    return x;
};
const quadraticSplineInput = function(startVal, endVal, stepSize) {
    function round(v, dec) {
        return Math.round(v * Math.pow(10, dec)) / Math.pow(10, dec);
    }
    const resultArr = [];
    for(let i = 0; i <= 1; i += stepSize)resultArr.push([
        round(i, 4),
        round(startVal + Math.pow(i, 2) * (endVal - startVal), 4)
    ]);
    return resultArr;
};

},{"./vec2":"eFVNh","./math":"7w6MZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iVNo9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// based on js color conversion http://www.webtoolkit.info/
parcelHelpers.export(exports, "HSV", ()=>HSV);
parcelHelpers.export(exports, "RGB", ()=>RGB);
parcelHelpers.export(exports, "CMYK", ()=>CMYK);
parcelHelpers.export(exports, "ColorConverter", ()=>ColorConverter);
parcelHelpers.export(exports, "testIsWhiteBestContrast", ()=>testIsWhiteBestContrast);
class HSV {
    constructor(h, s, v){
        this.h = Math.max(0, Math.min(360, h));
        this.s = Math.max(0.001, Math.min(100, s)); //bug when 0
        this.v = Math.max(0, Math.min(100, v));
    }
}
class RGB {
    constructor(r, g, b){
        this.r = Math.max(0, Math.min(255, r));
        this.g = Math.max(0, Math.min(255, g));
        this.b = Math.max(0, Math.min(255, b));
    }
}
class CMYK {
    constructor(c, m, y, k){
        this.c = Math.max(0, Math.min(100, c));
        this.m = Math.max(0, Math.min(100, m));
        this.y = Math.max(0, Math.min(100, y));
        this.k = Math.max(0, Math.min(100, k));
    }
}
const ColorConverter = {
    _RGBtoHSV: function(RGB) {
        const result = new HSV(0, 0, 0);
        const r = RGB.r / 255;
        const g = RGB.g / 255;
        const b = RGB.b / 255;
        const minVal = Math.min(r, g, b);
        const maxVal = Math.max(r, g, b);
        const delta = maxVal - minVal;
        result.v = maxVal;
        if (delta == 0) {
            result.h = 0;
            result.s = 0;
        } else {
            result.s = delta / maxVal;
            const del_R = ((maxVal - r) / 6 + delta / 2) / delta;
            const del_G = ((maxVal - g) / 6 + delta / 2) / delta;
            const del_B = ((maxVal - b) / 6 + delta / 2) / delta;
            if (r == maxVal) result.h = del_B - del_G;
            else if (g == maxVal) result.h = 1 / 3 + del_R - del_B;
            else if (b == maxVal) result.h = 2 / 3 + del_G - del_R;
            if (result.h < 0) result.h += 1;
            if (result.h > 1) result.h -= 1;
        }
        result.h = Math.round(result.h * 360);
        result.s = Math.round(result.s * 100);
        result.v = Math.round(result.v * 100);
        return result;
    },
    _HSVtoRGB: function(HSV) {
        const result = new RGB(0, 0, 0);
        let var_h, var_i, var_1, var_2, var_3, var_r, var_g, var_b;
        const h = HSV.h / 360 % 1;
        const s = HSV.s / 100;
        const v = HSV.v / 100;
        if (s == 0) {
            result.r = v * 255;
            result.g = v * 255;
            result.b = v * 255;
        } else {
            var_h = h * 6;
            var_i = Math.floor(var_h);
            var_1 = v * (1 - s);
            var_2 = v * (1 - s * (var_h - var_i));
            var_3 = v * (1 - s * (1 - (var_h - var_i)));
            if (var_i == 0) {
                var_r = v;
                var_g = var_3;
                var_b = var_1;
            } else if (var_i == 1) {
                var_r = var_2;
                var_g = v;
                var_b = var_1;
            } else if (var_i == 2) {
                var_r = var_1;
                var_g = v;
                var_b = var_3;
            } else if (var_i == 3) {
                var_r = var_1;
                var_g = var_2;
                var_b = v;
            } else if (var_i == 4) {
                var_r = var_3;
                var_g = var_1;
                var_b = v;
            } else {
                var_r = v;
                var_g = var_1;
                var_b = var_2;
            }
            result.r = var_r * 255;
            result.g = var_g * 255;
            result.b = var_b * 255;
            result.r = Math.round(result.r);
            result.g = Math.round(result.g);
            result.b = Math.round(result.b);
        }
        return result;
    },
    _CMYKtoRGB: function(CMYK) {
        const result = new RGB(0, 0, 0);
        const c = CMYK.c / 100;
        const m = CMYK.m / 100;
        const y = CMYK.y / 100;
        const k = CMYK.k / 100;
        result.r = 1 - Math.min(1, c * (1 - k) + k);
        result.g = 1 - Math.min(1, m * (1 - k) + k);
        result.b = 1 - Math.min(1, y * (1 - k) + k);
        result.r = Math.round(result.r * 255);
        result.g = Math.round(result.g * 255);
        result.b = Math.round(result.b * 255);
        return result;
    },
    _RGBtoCMYK: function(RGB) {
        const result = new CMYK(0, 0, 0, 0);
        const r = RGB.r / 255;
        const g = RGB.g / 255;
        const b = RGB.b / 255;
        result.k = Math.min(1 - r, 1 - g, 1 - b);
        result.c = (1 - r - result.k) / (1 - result.k);
        result.m = (1 - g - result.k) / (1 - result.k);
        result.y = (1 - b - result.k) / (1 - result.k);
        result.c = Math.round(result.c * 100);
        result.m = Math.round(result.m * 100);
        result.y = Math.round(result.y * 100);
        result.k = Math.round(result.k * 100);
        return result;
    },
    toRGB: function(o) {
        if (o instanceof RGB) return o;
        if (o instanceof HSV) return this._HSVtoRGB(o);
        if (o instanceof CMYK) return this._CMYKtoRGB(o);
    },
    toHSV: function(o) {
        if (o instanceof HSV) return o;
        if (o instanceof RGB) return this._RGBtoHSV(o);
        if (o instanceof CMYK) return this._RGBtoHSV(this._CMYKtoRGB(o));
    },
    toCMYK: function(o) {
        if (o instanceof CMYK) return o;
        if (o instanceof RGB) return this._RGBtoCMYK(o);
        if (o instanceof HSV) return this._RGBtoCMYK(this._HSVtoRGB(o));
    },
    toHexString: function(o) {
        if (o instanceof RGB || "r" in o && "g" in o && "b" in o) {
            let ha = parseInt("" + o.r).toString(16);
            let hb = parseInt("" + o.g).toString(16);
            let hc = parseInt("" + o.b).toString(16);
            if (ha.length == 1) ha = "0" + ha;
            if (hb.length == 1) hb = "0" + hb;
            if (hc.length == 1) hc = "0" + hc;
            return ha + hb + hc;
        }
    },
    toRgbStr: function(rgbObj) {
        return "rgb(" + Math.round(rgbObj.r) + ", " + Math.round(rgbObj.g) + ", " + Math.round(rgbObj.b) + ")";
    },
    toRgbaStr: function(rgbaObj) {
        return "rgba(" + Math.round(rgbaObj.r) + ", " + Math.round(rgbaObj.g) + ", " + Math.round(rgbaObj.b) + ", " + rgbaObj.a + ")";
    },
    hexToRGB: function(hexStr) {
        hexStr = hexStr.trim();
        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
        const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hexStr = hexStr.replace(shorthandRegex, function(m, r, g, b) {
            return r + r + g + g + b + b;
        });
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hexStr);
        return result ? new RGB(parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)) : null;
    }
};
function testIsWhiteBestContrast(rgbObj) {
    return rgbObj.r * 0.299 + rgbObj.g * 0.587 + rgbObj.b * 0.114 < 125;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2nyzl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "appendTextDiv", ()=>appendTextDiv);
/**
 * Is an input element focused.
 * Set attribute "data-ignore-focus" to "true" if its focus should be ignored.
 *
 * @param getAll - check all, even those with "data-ignore-focus" = "true"
 */ parcelHelpers.export(exports, "isInputFocused", ()=>isInputFocused);
parcelHelpers.export(exports, "unfocusAnyInput", ()=>unfocusAnyInput);
/**
 * clears text selection in window
 */ parcelHelpers.export(exports, "clearSelection", ()=>clearSelection);
parcelHelpers.export(exports, "makeUnfocusable", ()=>makeUnfocusable);
// window['els'] = els;
/**
 *
 * Create DOM element - div by default
 * params = {
 * 	    parent: someOtherDiv,
 * 	    css: {
 * 		    width: "500px",
 * 		    backgroundColor: "#fff"
 * 	    },
 * 	    content: "test", //or  content: [divA, divB, divC]   or content: someDiv
 * 	    className: "bla",
 *      id: "bla"
 * }
 *
 *  If onClick or onChange is used, then BB.destroyEl MUST be called
 *  to prevent a memory leak.
 *
 * @param params
 */ parcelHelpers.export(exports, "el", ()=>el);
/**
 * removes event listeners for Elements created via el()
 * @param el
 */ parcelHelpers.export(exports, "destroyEl", ()=>destroyEl);
var _eventListener = require("../input/event-listener");
var _base = require("./base");
var _bb = require("../bb");
function appendTextDiv(target, text) {
    const div = document.createElement("div");
    div.innerHTML = text;
    target.appendChild(div);
    return div;
}
function isInputFocused(getAll = false) {
    let result = document.activeElement && [
        "INPUT",
        "TEXTAREA"
    ].includes(document.activeElement.tagName);
    if (getAll) return result;
    else return result && !document.activeElement.getAttribute("data-ignore-focus");
}
function unfocusAnyInput() {
    if (isInputFocused(true)) {
        /*
            Unfocus anything that is focused.

            If an Input is focused in Firefox, and it gets detached from the DOM via a Node
            that isn't its direct parent, then Firefox will keep anything attached to this
            Input in memory. It will not be garbage collected until a new Input is focused.

            Workaround: Temporarily create an input, focus it, detach it.
             */ const focusEl = (0, _bb.BB).el({
            parent: document.body,
            tagName: "input",
            css: {
                opacity: "0",
                width: "0",
                height: "0"
            }
        });
        setTimeout(()=>{
            focusEl.select();
            focusEl.focus();
            focusEl.parentNode.removeChild(focusEl);
        }, 10);
    }
}
function clearSelection() {
    if (window.getSelection) {
        const sel = window.getSelection();
        if (sel) {
            if (sel.empty) sel.empty();
            else if (sel.removeAllRanges) sel.removeAllRanges();
        }
    } else if ("selection" in document) document.selection.empty();
}
const makeUnfocusable = function() {
    function preventFocus(event) {
        event.preventDefault();
        let didFocusRelated = false;
        if (event.relatedTarget) try {
            event.relatedTarget.focus();
            didFocusRelated = true;
        } catch (e) {
            console.error("failed to focus");
        }
        if (!didFocusRelated) event.currentTarget.blur();
    }
    return function(el) {
        el.setAttribute("tabindex", "-1");
        (0, _eventListener.addEventListener)(el, "focus", preventFocus);
    };
}();
const els = [];
function el(params) {
    const div = document.createElement(params.tagName ? params.tagName : "div");
    if (params.css) (0, _base.css)(div, params.css);
    if (params.content) {
        if (typeof params.content === "string") div.innerHTML = params.content;
        else if (Array.isArray(params.content)) (0, _bb.BB).append(div, params.content);
        else div.appendChild(params.content);
    }
    if (params.textContent) div.textContent = params.textContent;
    if (params.className) div.className = params.className;
    if (params.id) div.id = params.id;
    if (params.parent) params.parent.appendChild(div);
    if ("title" in params && params.title !== undefined) div.title = params.title;
    const listeners = [];
    if ("onClick" in params) {
        (0, _eventListener.addEventListener)(div, "click", params.onClick);
        listeners.push([
            "click",
            params.onClick
        ]);
    }
    if ("onChange" in params) {
        (0, _eventListener.addEventListener)(div, "change", params.onChange);
        listeners.push([
            "change",
            params.onChange
        ]);
    }
    if (listeners.length > 0) els.push({
        el: div,
        listeners: listeners
    });
    if ("custom" in params) {
        const customKeyArr = Object.keys(params.custom);
        for(let i = 0; i < customKeyArr.length; i++)div.setAttribute(customKeyArr[i], params.custom[customKeyArr[i]]);
    }
    return div;
}
function destroyEl(el) {
    for(let i = 0; i < els.length; i++){
        const item = els[i];
        if (item.el === el) {
            item.listeners.forEach((item)=>{
                el.removeEventListener(item[0], item[1]);
            });
            els.splice(i, 1);
            return;
        }
    }
    // not found
    return;
}

},{"../input/event-listener":"7bxtC","./base":"k6nNY","../bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lSCOF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BbLog", ()=>BbLog);
class BbLog {
    static listeners = [];
    constructor(){}
    static subscribe(listener) {
        if (BbLog.listeners.includes(listener)) return;
        BbLog.listeners.push(listener);
    }
    static unsubscribe(listener) {
        for(let i = 0; i < BbLog.listeners.length; i++)if (listener === BbLog.listeners[i]) {
            BbLog.listeners.splice(i, 1);
            return;
        }
    }
    static emit(msg) {
        BbLog.listeners.forEach((item)=>{
            item(msg);
        });
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"04p5O":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * LocalStorage wrapper that does not throw exceptions.
 * If cookies disabled in Safari localStorage interactions throw exception "insecure operation"
 */ parcelHelpers.export(exports, "LocalStorage", ()=>LocalStorage);
class LocalStorage {
    static getItem(key) {
        let result = null;
        try {
            result = localStorage.getItem(key);
        } catch (e) {
            this.error = e;
        }
        return result;
    }
    static setItem(key, value) {
        try {
            localStorage.setItem(key, value);
        } catch (e) {
            this.error = e;
        }
    }
    static removeItem(key) {
        try {
            localStorage.removeItem(key);
        } catch (e) {
            this.error = e;
        }
    }
    static getError() {
        return this.error;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8nmWp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "KL", ()=>KL);
var _klHistory = require("./history/kl-history");
var _popup = require("./ui/modals/popup");
var _modalCount = require("./ui/modals/modal-count");
var _checkbox = require("./ui/base-components/checkbox");
var _input = require("./ui/base-components/input");
var _select = require("./ui/base-components/select");
var _imageToggle = require("./ui/base-components/image-toggle");
var _imageRadioList = require("./ui/base-components/image-radio-list");
var _penPressureToggle = require("./ui/base-components/pen-pressure-toggle");
var _klSlider = require("./ui/base-components/kl-slider");
var _sliderFalloff = require("./ui/base-components/slider-falloff");
var _colorSliderHexDialog = require("./ui/modals/color-slider-hex-dialog");
var _klColorSlider = require("./ui/base-components/kl-color-slider");
var _klColorSliderSmall = require("./ui/base-components/kl-color-slider-small");
var _pointSlider = require("./ui/base-components/point-slider");
var _colorOptions = require("./ui/base-components/color-options");
var _options = require("./ui/base-components/options");
var _statusOverlay = require("./ui/components/status-overlay");
var _exportDialogDeprecated = require("./ui/modals/export-dialog-deprecated");
var _cropCopy = require("./ui/components/crop-copy");
var _clipboardDialog = require("./ui/modals/clipboard-dialog");
var _klLayerManager = require("./ui/tool-tabs/kl-layer-manager");
var _workspaceSvgOverlay = require("./canvas-ui/workspace-svg-overlay");
var _klCanvasWorkspace = require("./canvas-ui/kl-canvas-workspace");
var _canvasPreview = require("./canvas-ui/canvas-preview");
var _freeTransform = require("./ui/components/free-transform");
var _freeTransformCanvas = require("./ui/components/free-transform-canvas");
var _cropper = require("./ui/components/cropper");
var _layerPreview = require("./ui/components/layer-preview");
var _fittedImage = require("./ui/components/fitted-image");
var _showImportAsLayerDialog = require("./ui/modals/show-import-as-layer-dialog");
var _klImageDropper = require("./ui/components/kl-image-dropper");
var _overlayToolspace = require("./ui/components/overlay-toolspace");
var _toolspaceTopRow = require("./ui/components/toolspace-top-row");
var _toolDropdown = require("./ui/components/tool-dropdown");
var _toolspaceToolRow = require("./ui/components/toolspace-tool-row");
var _toolspaceStabilizerRow = require("./ui/components/toolspace-stabilizer-row");
var _tabRow = require("./ui/components/tab-row");
var _handUi = require("./ui/tool-tabs/hand-ui");
var _fillUi = require("./ui/tool-tabs/fill-ui");
var _textUi = require("./ui/tool-tabs/text-ui");
var _shapeUi = require("./ui/tool-tabs/shape-ui");
var _newImageDialog = require("./ui/modals/new-image-dialog");
var _toolspaceCollapser = require("./ui/components/toolspace-collapser");
var _renderText = require("./image-operations/render-text");
var _textToolDialog = require("./ui/modals/text-tool-dialog");
var _showImportImageDialog = require("./ui/modals/show-import-image-dialog");
var _floodFill = require("./image-operations/flood-fill");
var _psd = require("./storage/psd");
var _shapeTool = require("./image-operations/shape-tool");
var _klCanvas = require("./canvas/kl-canvas");
var _indexedDb = require("./storage/indexed-db");
var _filters = require("./filters/filters");
var _brushes = require("./brushes/brushes");
var _brushesUi = require("./brushes-ui/brushes-ui");
var _showIframePopup = require("./ui/modals/show-iframe-popup");
var _radioList = require("./ui/base-components/radio-list");
var _browserStorageUi = require("./ui/components/browser-storage-ui");
var _drawProject = require("./canvas/draw-project");
var _projectStore = require("./storage/project-store");
var _fileTab = require("./ui/tool-tabs/file-tab");
var _filterTab = require("./ui/tool-tabs/filter-tab");
var _imgurUpload = require("./ui/modals/imgur-upload");
var _agPsdWrapper = require("./storage/ag-psd-wrapper");
var _saveReminder = require("./ui/components/save-reminder");
var _saveToComputer = require("./storage/save-to-computer");
var _undoRedoCatchup = require("./history/undo-redo-catchup");
var _brushSettingService = require("./brushes-ui/brush-setting-service");
var _boxToggle = require("./ui/base-components/box-toggle");
var _settingsTab = require("./ui/tool-tabs/settings-tab");
var _toolspaceScroller = require("./ui/components/toolspace-scroller");
var _gradientUi = require("./ui/tool-tabs/gradient-ui");
var _gradientTool = require("./image-operations/gradient-tool");
const KL = {
    brushes: // --- brushes ---
    (0, _brushes.brushes),
    brushesUI: (0, _brushesUi.brushesUI),
    BrushSettingService: (0, _brushSettingService.BrushSettingService),
    KlCanvas: // --- canvas ---
    (0, _klCanvas.KlCanvas),
    drawProject: (0, _drawProject.drawProject),
    WorkspaceSvgOverlay: // --- canvas ui ---
    (0, _workspaceSvgOverlay.WorkspaceSvgOverlay),
    KlCanvasWorkspace: (0, _klCanvasWorkspace.KlCanvasWorkspace),
    KlCanvasPreview: (0, _canvasPreview.KlCanvasPreview),
    filterLibStatus: // --- filters ---
    (0, _filters.filterLibStatus),
    filterLib: (0, _filters.filterLib),
    UndoRedoCatchup: // --- history ---
    (0, _undoRedoCatchup.UndoRedoCatchup),
    renderText: // --- image operations ---
    (0, _renderText.renderText),
    floodFillBits: (0, _floodFill.floodFillBits),
    ShapeTool: (0, _shapeTool.ShapeTool),
    drawShape: (0, _shapeTool.drawShape),
    GradientTool: (0, _gradientTool.GradientTool),
    drawGradient: (0, _gradientTool.drawGradient),
    PSD: // --- storage ---
    _psd,
    setDbName: (0, _indexedDb.setDbName),
    indexedDb: _indexedDb,
    ProjectStore: (0, _projectStore.ProjectStore),
    loadAgPsd: (0, _agPsdWrapper.loadAgPsd),
    SaveToComputer: (0, _saveToComputer.SaveToComputer),
    calcSliderFalloffFactor: // --- ui - base components ---
    (0, _sliderFalloff.calcSliderFalloffFactor),
    Checkbox: (0, _checkbox.Checkbox),
    input: (0, _input.input),
    Select: (0, _select.Select),
    ImageToggle: (0, _imageToggle.ImageToggle),
    ImageRadioList: (0, _imageRadioList.ImageRadioList),
    RadioList: (0, _radioList.RadioList),
    penPressureToggle: (0, _penPressureToggle.penPressureToggle),
    KlSlider: (0, _klSlider.KlSlider),
    HexColorDialog: (0, _colorSliderHexDialog.HexColorDialog),
    KlColorSlider: (0, _klColorSlider.KlColorSlider),
    KlSmallColorSlider: (0, _klColorSliderSmall.KlSmallColorSlider),
    PointSlider: (0, _pointSlider.PointSlider),
    ColorOptions: (0, _colorOptions.ColorOptions),
    Options: (0, _options.Options),
    BoxToggle: (0, _boxToggle.BoxToggle),
    StatusOverlay: // --- ui - components ---
    (0, _statusOverlay.StatusOverlay),
    CropCopy: (0, _cropCopy.CropCopy),
    FreeTransform: (0, _freeTransform.FreeTransform),
    FreeTransformCanvas: (0, _freeTransformCanvas.FreeTransformCanvas),
    Cropper: (0, _cropper.Cropper),
    LayerPreview: (0, _layerPreview.LayerPreview),
    FittedImage: (0, _fittedImage.FittedImage),
    KlImageDropper: (0, _klImageDropper.KlImageDropper),
    OverlayToolspace: (0, _overlayToolspace.OverlayToolspace),
    ToolspaceTopRow: (0, _toolspaceTopRow.ToolspaceTopRow),
    ToolDropdown: (0, _toolDropdown.ToolDropdown),
    ToolspaceToolRow: (0, _toolspaceToolRow.ToolspaceToolRow),
    ToolspaceStabilizerRow: (0, _toolspaceStabilizerRow.ToolspaceStabilizerRow),
    TabRow: (0, _tabRow.TabRow),
    ToolspaceCollapser: (0, _toolspaceCollapser.ToolspaceCollapser),
    BrowserStorageUi: (0, _browserStorageUi.BrowserStorageUi),
    SaveReminder: (0, _saveReminder.SaveReminder),
    ToolspaceScroller: (0, _toolspaceScroller.ToolspaceScroller),
    dialogCounter: // --- ui - modals ---
    (0, _modalCount.dialogCounter),
    popup: (0, _popup.popup),
    Popup: (0, _popup.Popup),
    exportDialog: (0, _exportDialogDeprecated.exportDialog),
    clipboardDialog: (0, _clipboardDialog.clipboardDialog),
    showImportAsLayerDialog: (0, _showImportAsLayerDialog.showImportAsLayerDialog),
    newImageDialog: (0, _newImageDialog.newImageDialog),
    textToolDialog: (0, _textToolDialog.textToolDialog),
    showImportImageDialog: (0, _showImportImageDialog.showImportImageDialog),
    showIframePopup: (0, _showIframePopup.showIframePopup),
    imgurUpload: (0, _imgurUpload.imgurUpload),
    HandUi: // --- ui - tool tabs ---
    (0, _handUi.HandUi),
    FillUi: (0, _fillUi.FillUi),
    GradientUi: (0, _gradientUi.GradientUi),
    TextUi: (0, _textUi.TextUi),
    ShapeUi: (0, _shapeUi.ShapeUi),
    FileTab: (0, _fileTab.FileTab),
    FilterTab: (0, _filterTab.FilterTab),
    SettingsTab: (0, _settingsTab.SettingsTab),
    klLayerManager: (0, _klLayerManager.klLayerManager),
    klHistory: (0, _klHistory.klHistory),
    DecoyKlHistory: (0, _klHistory.DecoyKlHistory)
};

},{"./history/kl-history":"klzEn","./ui/modals/popup":"4Ltiz","./ui/modals/modal-count":"lsSVM","./ui/base-components/checkbox":"kPAwM","./ui/base-components/input":"bsfIT","./ui/base-components/select":"7mzRU","./ui/base-components/image-toggle":"5vi2a","./ui/base-components/image-radio-list":"enKw8","./ui/base-components/pen-pressure-toggle":"h5aJV","./ui/base-components/kl-slider":"6YGce","./ui/base-components/slider-falloff":"e9Q7X","./ui/modals/color-slider-hex-dialog":"es6uV","./ui/base-components/kl-color-slider":"c14dz","./ui/base-components/kl-color-slider-small":"gZ9fi","./ui/base-components/point-slider":"gzw3V","./ui/base-components/color-options":"e85vi","./ui/base-components/options":"huqRY","./ui/components/status-overlay":"ke842","./ui/modals/export-dialog-deprecated":"iNIjl","./ui/components/crop-copy":"aTBXS","./ui/modals/clipboard-dialog":"9W8Vp","./ui/tool-tabs/kl-layer-manager":"luXyU","./canvas-ui/workspace-svg-overlay":"kspFU","./canvas-ui/kl-canvas-workspace":"ep4xw","./canvas-ui/canvas-preview":"gRZnS","./ui/components/free-transform":"izcGJ","./ui/components/free-transform-canvas":"3quPq","./ui/components/cropper":"bajkn","./ui/components/layer-preview":"1YtXQ","./ui/components/fitted-image":"aDRkt","./ui/modals/show-import-as-layer-dialog":"aDt10","./ui/components/kl-image-dropper":"9RVJV","./ui/components/overlay-toolspace":"hWy6k","./ui/components/toolspace-top-row":"fltn0","./ui/components/tool-dropdown":"3fI3r","./ui/components/toolspace-tool-row":"eTege","./ui/components/toolspace-stabilizer-row":"84zrw","./ui/components/tab-row":"fLnal","./ui/tool-tabs/hand-ui":"brsBa","./ui/tool-tabs/fill-ui":"5n3hF","./ui/tool-tabs/text-ui":"jaulB","./ui/tool-tabs/shape-ui":"7GG7G","./ui/modals/new-image-dialog":"5IVi4","./ui/components/toolspace-collapser":"l6lvr","./image-operations/render-text":"fEvNY","./ui/modals/text-tool-dialog":"cGhag","./ui/modals/show-import-image-dialog":"8CgvP","./image-operations/flood-fill":"j0xrQ","./storage/psd":"Q3aBW","./image-operations/shape-tool":"90Wty","./canvas/kl-canvas":"l78MY","./storage/indexed-db":"eCGtt","./filters/filters":"lIjDv","./brushes/brushes":"8eOZC","./brushes-ui/brushes-ui":"io8zk","./ui/modals/show-iframe-popup":"gD1Cf","./ui/base-components/radio-list":"4jflC","./ui/components/browser-storage-ui":"9u5bD","./canvas/draw-project":"6Yf6D","./storage/project-store":"gZHsZ","./ui/tool-tabs/file-tab":"3rIr5","./ui/tool-tabs/filter-tab":"ftyCZ","./ui/modals/imgur-upload":"cZn9c","./storage/ag-psd-wrapper":"kPUiJ","./ui/components/save-reminder":"i5Pgf","./storage/save-to-computer":"axnPV","./history/undo-redo-catchup":"e5QXt","./brushes-ui/brush-setting-service":"dTdDM","./ui/base-components/box-toggle":"95ffn","./ui/tool-tabs/settings-tab":"4JW40","./ui/components/toolspace-scroller":"gytag","./ui/tool-tabs/gradient-ui":"boDxv","./image-operations/gradient-tool":"jhX3B","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"klzEn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DecoyKlHistory", ()=>DecoyKlHistory);
parcelHelpers.export(exports, "KlHistory", ()=>KlHistory);
parcelHelpers.export(exports, "klHistory", ()=>klHistory);
let historyInstance = false;
class DecoyKlHistory {
    pause(b) {}
    addListener(l) {}
    push(e) {}
    undo() {
        return [];
    }
    redo() {
        return [];
    }
    getAll() {
        return [];
    }
    canRedo() {
        return false;
    }
    canUndo() {
        return false;
    }
    getState() {
        return 0;
    }
    getActionNumber() {
        return 0;
    }
}
class KlHistory {
    max = 20;
    broadcast(p) {
        setTimeout(()=>{
            for(let i = 0; i < this.listeners.length; i++)this.listeners[i](p);
            this.state++;
        }, 1);
    }
    // ---- public ----
    constructor(){
        if (historyInstance) throw new Error("klHistory already instantiated");
        historyInstance = true;
        this.state = 0;
        this.dataArr = [];
        this.listeners = [];
        this.pauseStack = 0;
        this.maxState = -1;
        this.actionNumber = -1;
    }
    /**
     * you need pause because there are sometimes actions that would cause other
     * undo steps
     * for example a filter that does something crazy with two layers and then merges them
     * you want that to be one undo step, and prevent merging from causing its undo step.
     * so while that filter is doing its magic you should pause possible undo steps that
     * are caused by a part of its code(in this example: merging layers)
     *
     * @param b
     */ pause(b) {
        if (b === false) this.pauseStack = Math.max(0, this.pauseStack - 1);
        else this.pauseStack++;
    }
    addListener(l) {
        this.listeners.push(l);
    }
    push(e) {
        if (this.pauseStack > 0) return;
        while(this.actionNumber < this.dataArr.length - 1)this.dataArr.pop();
        //taking care of actions that shouldn't cause a new undo step
        const top = this.dataArr[this.dataArr.length - 1];
        if (e.action === "layerOpacity" && top && top.action === "layerOpacity" && top.params[0] === e.params[0]) {
            this.dataArr[this.dataArr.length - 1] = e;
            this.state++; //still needs to increment because something changed
            return;
        }
        if (e.action === "focusLayer" && top && top.action === "focusLayer") {
            this.dataArr[this.dataArr.length - 1] = e;
            this.state++;
            return;
        }
        this.dataArr[this.dataArr.length] = e;
        this.actionNumber = this.dataArr.length - 1;
        const maxBefore = this.maxState;
        this.maxState = Math.max(this.maxState, this.actionNumber - this.max);
        if (maxBefore < this.maxState) this.broadcast({
            bufferUpdate: this.dataArr[this.maxState]
        });
        else this.broadcast(null);
        if (this.maxState >= 0) this.dataArr[this.maxState] = null; //to free some memory...imported images take a lot of space
    }
    undo() {
        let result;
        if (this.canUndo()) {
            result = [];
            for(let i = this.maxState + 1; i < this.actionNumber; i++)result.push(this.dataArr[i]);
            this.actionNumber--;
            this.broadcast(null);
        }
        return result;
    }
    redo() {
        const result = [];
        if (this.canRedo()) {
            this.actionNumber++;
            result.push(this.dataArr[this.actionNumber]);
            this.broadcast(null);
        }
        return result;
    }
    getAll() {
        return [].concat(this.dataArr);
    }
    canRedo() {
        return this.actionNumber < this.dataArr.length - 1;
    }
    canUndo() {
        return this.actionNumber > this.maxState;
    }
    getState() {
        return this.state;
    }
    /**
     * actionNumber - number of undo-able actions a user has done (e.g. if drawn 5 lines total -> 5)
     */ getActionNumber() {
        return this.actionNumber + 1;
    }
}
const klHistory = new KlHistory();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4Ltiz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "popup", ()=>popup);
parcelHelpers.export(exports, "Popup", ()=>Popup);
var _modalCount = require("./modal-count");
var _bb = require("../../../bb/bb");
// @ts-ignore
var _checkSvg = require("url:~/src/app/img/ui/check.svg");
var _checkSvgDefault = parcelHelpers.interopDefault(_checkSvg);
// @ts-ignore
var _cancelSvg = require("url:~/src/app/img/ui/cancel.svg");
var _cancelSvgDefault = parcelHelpers.interopDefault(_cancelSvg);
var _language = require("../../../language/language");
window.onscroll = (e)=>{
    e.preventDefault();
};
function popup(p) {
    (0, _modalCount.dialogCounter).increase();
    let isClosed = false;
    // need this extra layer because chrome mobile otherwise scrolls the page and then glitches as the address bar goes away
    const rootRootEl = (0, _bb.BB).el({
        parent: document.body,
        css: {
            position: "absolute",
            left: "0",
            top: "0",
            right: "0",
            bottom: "0",
            overflow: "hidden"
        }
    });
    const rootEl = (0, _bb.BB).el({
        parent: rootRootEl,
        className: "kl-popup"
    });
    const scrollContent = (0, _bb.BB).el({
        parent: rootEl,
        css: {
            width: "100%",
            minHeight: "100%",
            // padding: '10px 0',
            position: "relative",
            display: "flex",
            flexDirection: "column",
            justifyContent: "center",
            alignItems: "center"
        }
    });
    const bgEl = (0, _bb.BB).el({
        parent: scrollContent,
        onClick: ()=>{
            if (p.ignoreBackground) return;
            close("Cancel");
        },
        css: {
            position: "absolute",
            left: "0",
            top: "0",
            zIndex: "0",
            width: "100%",
            height: "100%"
        }
    });
    const titleHeight = 40;
    const xButton = (0, _bb.BB).el({
        tagName: "button",
        className: "popup-x",
        content: `<img alt="${(0, _language.LANG)("modal-close")}" height="20" src="${(0, _cancelSvgDefault.default)}">`,
        title: (0, _language.LANG)("modal-close"),
        onClick: ()=>{
            close("Cancel");
        },
        css: {
            width: titleHeight + "px",
            height: titleHeight + "px",
            lineHeight: titleHeight + "px",
            position: "absolute",
            right: "0",
            top: "0",
            background: "none",
            boxShadow: "none"
        }
    });
    const boxClasses = [
        "kl-popup-box"
    ];
    boxClasses.push("kl-popup-box--sm");
    const boxEl = (0, _bb.BB).el({
        content: [
            xButton,
            (0, _bb.BB).el({
                content: p.message,
                css: {
                    marginBottom: p.div ? "10px" : null,
                    marginRight: "15px"
                }
            }),
            p.div, 
        ],
        className: boxClasses.join(" "),
        css: p.style ? p.style : null
    });
    scrollContent.append((0, _bb.BB).el({
        css: {
            flex: "0.5"
        }
    }), boxEl, (0, _bb.BB).el({
        css: {
            flex: "1"
        }
    }));
    if (p.type === "error") boxEl.classList.add("poperror");
    if (p.type === "ok") boxEl.classList.add("popok");
    if (p.type === "warning") boxEl.classList.add("popwarning");
    if (p.type === "upload") boxEl.classList.add("popupload");
    const keyListener = new (0, _bb.BB).KeyListener({
        onDown: function(keyStr, e, comboStr) {
            if (isClosed) return;
            if (clickOnEnterBtn && comboStr === "enter" && !(0, _bb.BB).isInputFocused()) {
                e.stopPropagation();
                setTimeout(function() {
                    clickOnEnterBtn.click();
                }, 10);
            }
            if (comboStr === "esc") {
                e.stopPropagation();
                close("Cancel");
            }
        }
    });
    // prevent ctrl scroll -> zooming page
    const wheelPrevent = (event)=>{
        if (keyListener.isPressed("ctrl")) event.preventDefault();
    };
    (0, _bb.BB).addEventListener(rootEl, "wheel", wheelPrevent);
    rootEl.onclick = (0, _bb.BB).handleClick;
    let autoFocus = null;
    if (p.autoFocus) autoFocus = p.autoFocus;
    else if (p.autoFocus === false) autoFocus = null;
    else autoFocus = "Ok";
    const buttonRowEl = p.buttons && p.buttons.length > 0 ? (0, _bb.BB).el({
        parent: boxEl,
        css: {
            display: "flex",
            flexWrap: "wrap",
            justifyContent: "flex-end",
            marginTop: "12px",
            marginLeft: "-8px"
        }
    }) : null;
    let clickOnEnterBtn;
    const btnElArr = [];
    if (p.buttons) p.buttons.forEach((buttonName)=>{
        const btnClasses = [
            "kl-popup__btn"
        ];
        if (buttonName === "Ok" || p.primaries && p.primaries.includes(buttonName)) btnClasses.push("kl-button-primary");
        let iconUrl;
        let label = buttonName;
        if (buttonName === "Ok") {
            label = (0, _language.LANG)("modal-ok");
            iconUrl = (0, _checkSvgDefault.default);
        }
        if (buttonName === "Cancel") {
            label = (0, _language.LANG)("modal-cancel");
            iconUrl = (0, _cancelSvgDefault.default);
        }
        let iconImg = null;
        if (iconUrl) iconImg = (0, _bb.BB).el({
            tagName: "img",
            custom: {
                src: iconUrl,
                height: "17"
            }
        });
        const btn = (0, _bb.BB).el({
            parent: buttonRowEl,
            tagName: "button",
            className: btnClasses.join(" "),
            content: [
                iconImg,
                label
            ],
            onClick: ()=>{
                close(buttonName);
            }
        });
        btnElArr.push(btn);
        if (autoFocus === buttonName) {
            setTimeout(()=>{
                btn.focus();
                rootEl.scrollTo(0, 0);
            }, 10);
            setTimeout(()=>{
                // safari needs a separate timeout
                rootEl.scrollTo(0, 0);
            }, 20);
        }
        if (buttonName === p.clickOnEnter) clickOnEnterBtn = btn;
    });
    function close(value) {
        if (isClosed) return;
        isClosed = true;
        (0, _bb.BB).clearSelection();
        (0, _bb.BB).unfocusAnyInput();
        document.body.removeChild(rootRootEl);
        (0, _modalCount.dialogCounter).decrease();
        (0, _bb.BB).destroyEl(xButton);
        (0, _bb.BB).destroyEl(bgEl);
        keyListener.destroy();
        (0, _bb.BB).removeEventListener(rootEl, "wheel", wheelPrevent);
        rootEl.onclick = null;
        btnElArr.forEach((item)=>{
            (0, _bb.BB).destroyEl(item);
        });
        btnElArr.splice(0, btnElArr.length);
        if (p.callback) p.callback(value);
    }
    if (p.closefunc) p.closefunc(function() {
        close("Cancel");
    });
}
const Popup = function(p) {
    (0, _modalCount.dialogCounter).increase();
    const parent = document.body;
    const div = (0, _bb.BB).el({
        parent: parent,
        className: "g-root",
        css: {
            position: "fixed",
            left: "0",
            top: "0",
            bottom: "0",
            right: "0",
            background: "rgba(0, 0, 0, 0.45)",
            overflow: "auto",
            animationName: "consoleIn",
            animationDuration: "0.3s",
            animationTimingFunction: "ease-out"
        }
    });
    div.onclick = (0, _bb.BB).handleClick;
    let updateInterval;
    function close() {
        (0, _modalCount.dialogCounter).decrease();
        div.onclick = null;
        parent.removeChild(div);
        clearInterval(updateInterval);
        window.removeEventListener("resize", updatePos);
        keyListener.destroy();
        (0, _bb.BB).destroyEl(xButton);
        (0, _bb.BB).destroyEl(bgEl);
        if (p.onClose) p.onClose();
    }
    //background element registering clicks
    const bgEl = (0, _bb.BB).el({
        parent: div,
        css: {
            position: "absolute",
            left: "0",
            top: "0",
            bottom: "0",
            right: "0"
        },
        onClick: close
    });
    //the actual popup box
    const popupEl = (0, _bb.BB).el({
        parent: div,
        css: {
            position: "absolute",
            width: (0, _bb.BB).isCssMinMaxSupported() ? "min(calc(100% - 40px), " + (p.width ? p.width : 400) + "px)" : (p.width ? p.width : 400) + "px",
            height: "calc(100% - 40px)",
            background: "#eee",
            borderRadius: "10px",
            overflow: "hidden",
            boxShadow: "rgba(0, 0, 0, 0.25) 0px 5px 60px"
        }
    });
    //x and y position via script. flex not powerful enough imo
    function updatePos() {
        const elW = popupEl.offsetWidth;
        const elH = popupEl.offsetHeight;
        (0, _bb.BB).css(popupEl, {
            left: Math.max(0, (window.innerWidth - elW) / 2) + "px",
            top: Math.max(20, (window.innerHeight - elH) / 2 - elH * 0.20) + "px"
        });
    }
    //todo also update when popup changes size - resizeobserver and fallback
    //updateInterval = setInterval(updatePos, 100);
    updatePos();
    window.addEventListener("resize", updatePos);
    //title row in popup
    const titleHeight = 40;
    const titleEl = (0, _bb.BB).el({
        parent: popupEl,
        css: {
            height: titleHeight + "px",
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            paddingLeft: titleHeight / 2 + "px"
        }
    });
    if (p.title) titleEl.appendChild(p.title);
    const xButton = (0, _bb.BB).el({
        parent: titleEl,
        tagName: "button",
        className: "popup-x",
        content: `<img alt="${(0, _language.LANG)("modal-close")}" height="20" src="${(0, _cancelSvgDefault.default)}">`,
        title: (0, _language.LANG)("modal-close"),
        onClick: close,
        css: {
            width: titleHeight + "px",
            height: titleHeight + "px",
            lineHeight: titleHeight + "px",
            background: "none",
            boxShadow: "none"
        },
        custom: {
            tabindex: "0"
        }
    });
    const contentEl = (0, _bb.BB).el({
        parent: popupEl,
        css: {
            height: "calc(100% - " + titleHeight + "px)"
        }
    });
    if (p.content) contentEl.appendChild(p.content);
    const keyListener = new (0, _bb.BB).KeyListener({
        onDown: function(keyStr, e) {
            if (keyStr === "esc") {
                e.stopPropagation();
                close();
            }
        }
    });
    // --- interface ---
    this.close = function() {
        close();
    };
};

},{"./modal-count":"lsSVM","../../../bb/bb":"dcQKo","url:~/src/app/img/ui/check.svg":"4Wx6X","url:~/src/app/img/ui/cancel.svg":"3xU6m","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lsSVM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// not the best
/**
 * how many modals are open
 */ parcelHelpers.export(exports, "DialogCounter", ()=>DialogCounter);
parcelHelpers.export(exports, "dialogCounter", ()=>dialogCounter);
class DialogCounter {
    listeners = [];
    count = 0;
    emit() {
        this.listeners.forEach((item)=>{
            item(this.count);
        });
    }
    increase(v) {
        if (v !== undefined) this.count += v;
        else this.count++;
        this.emit();
    }
    decrease(v) {
        if (v !== undefined) this.count -= v;
        else this.count--;
        this.emit();
    }
    get() {
        return this.count;
    }
    subscribe(listener) {
        this.listeners.push(listener);
    }
}
const dialogCounter = new DialogCounter();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4Wx6X":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "check.04f6f8b0.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"lgJ39":[function(require,module,exports) {
"use strict";
var bundleURL = {};
function getBundleURLCached(id) {
    var value = bundleURL[id];
    if (!value) {
        value = getBundleURL();
        bundleURL[id] = value;
    }
    return value;
}
function getBundleURL() {
    try {
        throw new Error();
    } catch (err) {
        var matches = ("" + err.stack).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/[^)\n]+/g);
        if (matches) // The first two stack frames will be this function and getBundleURLCached.
        // Use the 3rd one, which will be a runtime in the original bundle.
        return getBaseURL(matches[2]);
    }
    return "/";
}
function getBaseURL(url) {
    return ("" + url).replace(/^((?:https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/.+)\/[^/]+$/, "$1") + "/";
} // TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.
function getOrigin(url) {
    var matches = ("" + url).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/[^/]+/);
    if (!matches) throw new Error("Origin not found");
    return matches[0];
}
exports.getBundleURL = getBundleURLCached;
exports.getBaseURL = getBaseURL;
exports.getOrigin = getOrigin;

},{}],"3xU6m":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "cancel.8f01fb7c.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"iiYGN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LS_LANGUAGE_KEY", ()=>LS_LANGUAGE_KEY);
parcelHelpers.export(exports, "LanguageStrings", ()=>LanguageStrings);
parcelHelpers.export(exports, "languageStrings", ()=>languageStrings);
parcelHelpers.export(exports, "LANG", ()=>LANG);
parcelHelpers.export(exports, "initLANG", ()=>initLANG);
// @ts-ignore
var _languages = require("../../languages/languages");
const LS_LANGUAGE_KEY = "klecks-language";
class LanguageStrings {
    listeners = [];
    // --- public ----
    constructor(){
        // need to use setLanguage for a different language
        this.data = {
            ...(0, _languages.english)
        };
        this.code = "en";
    }
    async setLanguage(langCode) {
        if (langCode === "en") this.data = {
            ...(0, _languages.english)
        };
        else this.data = {
            ...(0, _languages.english),
            ...await (0, _languages.loadLanguage)(langCode)
        };
        this.code = langCode;
        document.documentElement.setAttribute("lang", langCode);
        this.listeners.forEach((item)=>{
            item();
        });
    }
    get(code) {
        if (!(code in this.data)) throw new Error("translation code doesn't exist: " + code);
        return this.data[code];
    }
    getLanguage() {
        return (0, _languages.languages).find((item)=>{
            return item.code === this.code;
        });
    }
    getCode() {
        return this.code;
    }
    // get notified on language change
    subscribe(subscriber) {
        if (this.listeners.includes(subscriber)) return;
        this.listeners.push(subscriber);
    }
    unsubscribe(subscriber) {
        for(let i = 0; i < this.listeners.length; i++)if (subscriber === this.listeners[i]) {
            this.listeners.splice(i, 1);
            return;
        }
    }
}
let activeLanguageCode = "en"; // active language code
{
    const langs = []; // from highest to lowest priority
    const navLangs = navigator.languages ? navigator.languages : [
        navigator.language
    ];
    navLangs.forEach((item)=>{
        const split = item.split("-");
        langs.push(item);
        if (split.length === 2) langs.push(split[0]);
    });
    try {
        if (localStorage.getItem(LS_LANGUAGE_KEY)) langs.unshift(localStorage.getItem(LS_LANGUAGE_KEY));
    } catch (e) {
    // likely cookies disabled in Safari
    }
    for(let i = 0; i < langs.length; i++){
        const lang = langs[i];
        const found = (0, _languages.languages).find((item)=>{
            return item.code.toLowerCase() === lang.toLowerCase();
        });
        if (found) {
            activeLanguageCode = found.code;
            break;
        }
    }
}const languageStrings = new LanguageStrings();
const LANG = (code, replace)=>{
    if (replace) {
        let result = languageStrings.get(code);
        const keyArr = Object.keys(replace);
        keyArr.forEach((key)=>{
            result = result.replace(`{${key}}`, replace[key]);
        });
        return result;
    } else return languageStrings.get(code);
};
const initLANG = ()=>languageStrings.setLanguage(activeLanguageCode);

},{"../../languages/languages":"5K1G7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5K1G7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "english", ()=>english);
parcelHelpers.export(exports, "languages", ()=>languages);
parcelHelpers.export(exports, "loadLanguage", ()=>loadLanguage);
// generated from src/languages. "npm run lang:build" to update
// @ts-ignore
var _enJson = require("./en.json");
var _enJsonDefault = parcelHelpers.interopDefault(_enJson);
const english = (0, _enJsonDefault.default);
const languages = [
    {
        code: "en",
        name: "English"
    },
    {
        code: "de",
        name: "Deutsch"
    },
    {
        code: "ja",
        name: "Êó•Êú¨Ë™û"
    },
    {
        code: "zh-CN",
        name: "ÁÆÄ‰Ωì‰∏≠Êñá"
    },
    {
        code: "zh-TW",
        name: "ÁπÅÈ´î‰∏≠Êñá"
    }
];
const loadLanguage = async (code)=>{
    if (code === "en") return english;
    else if (code === "de") // @ts-ignore
    return await require("4d605ca5252fba22");
    else if (code === "ja") // @ts-ignore
    return await require("880fa9eff302714e");
    else if (code === "zh-CN") // @ts-ignore
    return await require("58e96364f4c28f06");
    else if (code === "zh-TW") // @ts-ignore
    return await require("ef3a3701243ff03a");
    throw new Error("unknown language code");
};

},{"./en.json":"81RpX","4d605ca5252fba22":"7xY9y","880fa9eff302714e":"jY7Yl","58e96364f4c28f06":"kkQnx","ef3a3701243ff03a":"gJTRh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"81RpX":[function(require,module,exports) {
module.exports = JSON.parse('{"switch-ui-left-right":"Switch left/right UI","toggle-show-tools":"Show/Hide Tools","scroll":"Scroll","donate":"Donate","home":"Home","modal-new-tab":"Open in new tab","tab-layers":"Layers","tab-edit":"Edit","tab-file":"File","tool-brush":"Brush","tool-paint-bucket":"Paint Bucket","tool-gradient":"Gradient","tool-shape":"Shape","tool-text":"Text","tool-hand":"Hand Tool","tool-zoom":"Zoom","tool-undo-redo":"Undo / Redo","undo":"Undo","redo":"Redo","brush-pen":"Pen","brush-blend":"Blend","brush-sketchy":"Sketchy","brush-pixel":"Pixel","brush-chemy":"Chemy","brush-smudge":"Smudge","brush-size":"Size","brush-blending":"Blending","brush-toggle-pressure":"Toggle Pressure Sensitivity","brush-pen-circle":"Circle","brush-pen-chalk":"Chalk","brush-pen-calligraphy":"Calligraphy","brush-pen-square":"Square","brush-sketchy-scale":"Scale","brush-pixel-dither":"Dither","brush-chemy-fill":"Fill","brush-chemy-stroke":"Stroke","brush-chemy-mirror-x":"Horizontal Symmetry","brush-chemy-mirror-y":"Vertical Symmetry","brush-chemy-gradient":"Gradient","brush-eraser-transparent-bg":"Transparent Background","stabilizer":"Stabilizer","stabilizer-title":"Stroke Stabilizer","eyedropper":"Eyedropper","secondary-color":"Secondary Color","manual-color-input":"Manual Color Input","mci-hex":"Hex","mci-copy":"Copy","modal-ok":"Ok","modal-cancel":"Cancel","modal-close":"Close","layers-active-layer":"Active Layer","layers-layer":"Layer","layers-copy":"copy","layers-blending":"Blending","layers-new":"New Layer","layers-remove":"Remove Layer","layers-duplicate":"Duplicate Layer","layers-merge":"Merge with layer below","layers-rename":"Rename","layers-blend-normal":"normal","layers-blend-darken":"darken","layers-blend-multiply":"multiply","layers-blend-color-burn":"color burn","layers-blend-lighten":"lighten","layers-blend-screen":"screen","layers-blend-color-dodge":"color dodge","layers-blend-overlay":"overlay","layers-blend-soft-light":"soft light","layers-blend-hard-light":"hard light","layers-blend-difference":"difference","layers-blend-exclusion":"exclusion","layers-blend-hue":"hue","layers-blend-saturation":"saturation","layers-blend-color":"color","layers-blend-luminosity":"luminosity","layers-rename-title":"Rename Layer","layers-rename-name":"Name","layers-rename-clear":"Clear Name","layers-rename-sketch":"Sketch","layers-rename-colors":"Colors","layers-rename-shading":"Shading","layers-rename-lines":"Lines","layers-rename-effects":"Effects","layers-rename-foreground":"Foreground","layers-merge-modal-title":"Merge/Mix Layers","layers-merge-description":"Merges the selected layer with the one underneath. Select the mix mode:","file-no-autosave":"No autosave, no cloud storage","file-new":"New","file-import":"Import","file-save":"Save","file-save-png":"Save PNG","file-save-psd":"Save PSD","file-save-layers":"Save Layers","file-copy":"Copy","file-copy-title":"Copy To Clipboard","file-share":"Share","file-storage":"Browser Storage","file-storage-thumb-title":"Restores when reopening page","file-storage-about":"About Browser Storage","file-storage-cant-access":"Can\'t access","file-storage-empty":"Empty","file-storage-store":"Store","file-storage-clear":"Clear","file-storage-storing":"Storing","file-storage-overwrite":"Overwrite","file-storage-min-ago":"{x}min ago","file-storage-hours-ago":"{x}h ago","file-storage-days-ago":"{x}d ago","file-storage-month-ago":"> 1month ago","file-storage-restored":"Restored from Browser Storage","file-storage-stored":"Stored to Browser Storage","file-storage-failed":"Failed to store to Browser Storage","file-storage-failed-1":"Failed to store. Possible causes:","file-storage-failed-2":"Out of disk space","file-storage-failed-3":"Storage disabled in incognito tab","file-storage-failed-4":"Browser doesn\'t support storage","file-storage-failed-clear":"Failed to clear.","file-upload":"Upload","cleared-layer":"Cleared layer","filled":"Filled","new-title":"New Image","new-current":"Current","new-fit":"Fit","new-oversize":"Oversize","new-square":"Square","new-landscape":"Landscape","new-portrait":"Portrait","new-screen":"Screen","new-video":"Video","new-din-paper":"DIN Paper","new-px":"px","new-ratio":"Ratio","upload-title":"Upload to Imgur","upload-link-notice":"Anyone with the link to your uploaded image will be able to view it.","upload-name":"Title","upload-title-untitled":"Untitled","upload-caption":"Caption","upload-tos":"Terms of Service","upload-tos-2":"for imgur.com","upload-submit":"Upload","upload-uploading":"Uploading...","upload-success":"Upload Successful","upload-failed":"Upload failed.","upload-delete":"To delete your image from Imgur visit:","cropcopy-title-copy":"Copy To Clipboard","cropcopy-title-crop":"Crop","cropcopy-click-hold":"Right-click or press hold to copy.","cropcopy-btn-copy":"To Clipboard","cropcopy-copied":"Copied.","cropcopy-btn-crop":"Apply Crop","crop-drag-to-crop":"Drag to crop","filter-crop-extend":"Crop/Extend","filter-flip":"Flip","filter-perspective":"Perspective","filter-resize":"Resize","filter-rotate":"Rotate","filter-transform":"Transform","filter-bright-contrast":"Bright/Contrast","filter-curves":"Curves","filter-hue-sat":"Hue/Saturation","filter-invert":"Invert","filter-tilt-shift":"Tilt Shift","filter-to-alpha":"To Alpha","filter-triangle-blur":"Triangle Blur","filter-unsharp-mask":"Unsharp Mask","filter-crop-title":"Crop / Extend","filter-crop-description":"Crop or extend the image.","filter-crop-left":"Left","filter-crop-right":"Right","filter-crop-top":"Top","filter-crop-bottom":"Bottom","filter-crop-rule-thirds":"Rule of Thirds","filter-crop-fill":"Fill","filter-flip-title":"Flip","filter-flip-description":"Flips layer or whole image.","filter-flip-horizontal":"Horizontal","filter-flip-vertical":"Vertical","filter-flip-image":"Flip Image","filter-flip-layer":"Flip Layer","filter-perspective-title":"Perspective","filter-perspective-description":"Transforms the selected layer.","filter-resize-title":"Resize","filter-resize-description":"Resizes the image.","filter-rotate-title":"Rotate","filter-rotate-description":"Rotates the image.","filter-transform-empty":"Layer is empty.","filter-transform-title":"Transform","filter-transform-description":"Transforms selected layer. Hold Shift for additional behavior.","filter-transform-rotation":"Rotation","filter-transform-flip":"Flip","filter-transform-center":"Center","filter-transform-constrain":"Constrain","filter-transform-snap":"Snap","filter-transform-snap-title":"Snap Rotation And Position","filter-bright-contrast-title":"Brightness / Contrast","filter-bright-contrast-description":"Change brightness and contrast for the selected layer.","filter-bright-contrast-brightness":"Brightness","filter-bright-contrast-contrast":"Contrast","filter-curves-title":"Curves","filter-curves-description":"Apply curves on the selected layer.","filter-curves-all":"All","filter-hue-sat-title":"Hue / Saturation","filter-hue-sat-description":"Change hue and saturation for the selected layer.","filter-hue-sat-hue":"Hue","filter-hue-sat-saturation":"Saturation","filter-applied":"applied","filter-tilt-shift-title":"Tilt Shift","filter-tilt-shift-description":"Applies tilt shift on the selected layer.","filter-tilt-shift-blur":"Blur Radius","filter-tilt-shift-gradient":"Gradient Radius","filter-to-alpha-title":"To Alpha","filter-to-alpha-description":"Generates alpha channel for selected layer from:","filter-to-alpha-inverted-lum":"Inverted Luminance","filter-to-alpha-lum":"Luminance","filter-to-alpha-replace":"Replace RGB","filter-triangle-blur-title":"Triangle Blur","filter-triangle-blur-description":"Applies triangle blur on the selected layer.","filter-unsharp-mask-title":"Unsharp Mask","filter-unsharp-mask-description":"Sharpens the selected layer by scaling pixels away from the average of their neighbors.","filter-unsharp-mask-strength":"Strength","filter-grid":"Grid","filter-grid-description":"Draws grid on selected layer.","filter-noise":"Noise","filter-noise-description":"Adds noise to selected layer.","filter-noise-scale":"Scale","filter-noise-alpha":"Alpha","filter-pattern":"Pattern","filter-pattern-description":"Generates pattern on selected layer. Drag the preview for further controls.","filter-distort":"Distort","filter-distort-description":"Distorts the selected layer.","filter-distort-phase":"Phase","filter-distort-stepsize":"Step Size","filter-distort-sync-xy":"Sync XY","filter-vanish-point":"Vanish Point","filter-vanish-point-title":"Vanishing Point","filter-vanish-point-description":"Adds vanishing point to selected layer. Drag preview to move.","filter-vanish-point-lines":"Lines","import-opening":"Opening file...","import-title":"Import Image","import-too-large":"Image too large, will be downscaled.","import-btn-as-layer":"As Layer","import-btn-as-image":"As Image","import-as-layer-title":"Import Image as New Layer","import-as-layer-description":"Adjust the position of the imported image.","import-as-layer-limit-reached":"Layer limit reached. Image will be placed on existing layer.","import-as-layer-fit":"Fit","import-flatten":"Flatten image","import-unsupported-file":"Unsupported file type. See Help for supported types.","import-broken-file":"Couldn\'t load image. File might be corrupted.","import-psd-unsupported":"Unsupported features. PSD had to be flattened.","import-psd-limited-support":"PSD support is limited. Flattened will more likely look correct.","import-psd-too-large":"Image exceeds maximum dimensions of {x} x {x} pixels. Unable to import.","import-psd-size":"Image size","hand-reset":"Reset","hand-fit":"Fit","bucket-tolerance":"Tolerance","bucket-sample":"Sample","bucket-sample-title":"Which layers to sample color from","bucket-sample-all":"All","bucket-sample-active":"Active","bucket-sample-above":"Above","bucket-grow":"Grow","bucket-grow-title":"Grow filled area (in pixels)","bucket-contiguous":"Contiguous","bucket-contiguous-title":"Only fill connected areas","gradient-linear":"Linear","gradient-linear-mirror":"Linear-Mirror","gradient-radial":"Radial","shape-stroke":"Stroke","shape-fill":"Fill","shape-rect":"Rectangle","shape-ellipse":"Ellipse","shape-line":"Line","shape-line-width":"Line Width","shape-outwards":"Outwards","shape-fixed":"Fixed 1:1","text-instruction":"Click canvas to place text","text-title":"Add Text","text-placeholder":"Your text (multiline Shift+Enter)","text-color":"Color","text-size":"Size","text-left":"Left","text-center":"Center","text-right":"Right","text-italic":"Italic","text-bold":"Bold","save-reminder-title":"Unsaved Work","save-reminder-text":"Image was not saved in {a} minutes{b}. Save now to prevent eventual loss.","save-reminder-save-psd":"Save As PSD","save-reminder-psd-layers":"PSD will remember all layers.","submit":"Submit","submit-title":"Submit Drawing","submit-prompt":"Submit drawing?","submit-submitting":"Submitting","embed-init-loading":"Loading app","embed-init-waiting":"Waiting for image","unsaved":"Unsaved","help":"Help","tab-settings":"Settings","settings-language":"Language","settings-preferred-language":"Preferred Language","settings-language-reload":"Will update after reloading.","licenses":"Licenses","source-code":"Source Code","auto":"auto","zoom-in":"Zoom In","zoom-out":"Zoom Out","radius":"Radius","constrain-proportions":"Constrain Proportions","width":"Width","height":"Height","opacity":"Opacity","red":"Red","green":"Green","blue":"Blue","eraser":"Eraser","center":"Center","background":"Background","scaling-algorithm":"Scaling Algorithm","algorithm-smooth":"Smooth","algorithm-pixelated":"Pixelated","preview":"Preview","angle-snap":"Snap","angle-snap-title":"45\xb0 Angle Snapping","lock-alpha":"Lock Alpha","lock-alpha-title":"Locks layer\'s alpha channel","reverse":"Reverse","compare-before":"Before","compare-after":"After"}');

},{}],"7xY9y":[function(require,module,exports) {
module.exports = require("./helpers/browser/js-loader")(require("./helpers/bundle-url").getBundleURL("d3gnI") + "de.bc2c59f6.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root("gPCVN"));

},{"./helpers/browser/js-loader":"61B45","./helpers/bundle-url":"lgJ39"}],"61B45":[function(require,module,exports) {
"use strict";
var cacheLoader = require("../cacheLoader");
module.exports = cacheLoader(function(bundle) {
    return new Promise(function(resolve, reject) {
        // Don't insert the same script twice (e.g. if it was already in the HTML)
        var existingScripts = document.getElementsByTagName("script");
        if ([].concat(existingScripts).some(function isCurrentBundle(script) {
            return script.src === bundle;
        })) {
            resolve();
            return;
        }
        var preloadLink = document.createElement("link");
        preloadLink.href = bundle;
        preloadLink.rel = "preload";
        preloadLink.as = "script";
        document.head.appendChild(preloadLink);
        var script = document.createElement("script");
        script.async = true;
        script.type = "text/javascript";
        script.src = bundle;
        script.onerror = function(e) {
            var error = new TypeError("Failed to fetch dynamically imported module: ".concat(bundle, ". Error: ").concat(e.message));
            script.onerror = script.onload = null;
            script.remove();
            reject(error);
        };
        script.onload = function() {
            script.onerror = script.onload = null;
            resolve();
        };
        document.getElementsByTagName("head")[0].appendChild(script);
    });
});

},{"../cacheLoader":"j49pS"}],"j49pS":[function(require,module,exports) {
"use strict";
var cachedBundles = {};
var cachedPreloads = {};
var cachedPrefetches = {};
function getCache(type) {
    switch(type){
        case "preload":
            return cachedPreloads;
        case "prefetch":
            return cachedPrefetches;
        default:
            return cachedBundles;
    }
}
module.exports = function(loader, type) {
    return function(bundle) {
        var cache = getCache(type);
        if (cache[bundle]) return cache[bundle];
        return cache[bundle] = loader.apply(null, arguments).catch(function(e) {
            delete cache[bundle];
            throw e;
        });
    };
};

},{}],"jY7Yl":[function(require,module,exports) {
module.exports = require("./helpers/browser/js-loader")(require("./helpers/bundle-url").getBundleURL("d3gnI") + "ja.e641fff7.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root("hU4y7"));

},{"./helpers/browser/js-loader":"61B45","./helpers/bundle-url":"lgJ39"}],"kkQnx":[function(require,module,exports) {
module.exports = require("./helpers/browser/js-loader")(require("./helpers/bundle-url").getBundleURL("d3gnI") + "zh-CN.21b77a10.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root("iRXNP"));

},{"./helpers/browser/js-loader":"61B45","./helpers/bundle-url":"lgJ39"}],"gJTRh":[function(require,module,exports) {
module.exports = require("./helpers/browser/js-loader")(require("./helpers/bundle-url").getBundleURL("d3gnI") + "zh-TW.dfa4013e.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root("1YTLX"));

},{"./helpers/browser/js-loader":"61B45","./helpers/bundle-url":"lgJ39"}],"kPAwM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Checkbox - with label
 */ parcelHelpers.export(exports, "Checkbox", ()=>Checkbox);
var _bb = require("../../../bb/bb");
class Checkbox {
    // --- public ---
    constructor(params){
        this.doHighlight = params.doHighlight;
        this.element = (0, _bb.BB).el({
            className: "kl-checkbox"
        });
        const innerEl = (0, _bb.BB).el({
            parent: this.element,
            tagName: "label",
            className: "kl-checkbox__inner"
        });
        this.check = (0, _bb.BB).el({
            parent: innerEl,
            tagName: "input",
            css: {
                marginLeft: "0",
                display: "inline-block"
            },
            custom: {
                type: "checkbox"
            }
        });
        this.check.checked = params.init;
        if (this.doHighlight && this.check.checked) this.element.classList.add("kl-checkbox--highlight");
        if (!params.allowTab) this.check.tabIndex = -1;
        if (params.title) innerEl.title = params.title;
        const label = document.createElement("div");
        label.style.display = "inline-block";
        label.innerHTML = params.label;
        label.allowClick = true;
        innerEl.appendChild(label);
        this.check.onchange = ()=>{
            if (this.doHighlight) this.element.classList.toggle("kl-checkbox--highlight", this.check.checked);
            params.callback(this.check.checked);
            setTimeout(()=>{
                this.check.blur();
            }, 0);
        };
        if (params.css) (0, _bb.BB).css(this.element, params.css);
    }
    getValue() {
        return this.check.checked;
    }
    setValue(b) {
        this.check.checked = !!b;
        if (this.doHighlight) this.element.classList.toggle("kl-checkbox--highlight", this.check.checked);
    }
    getElement() {
        return this.element;
    }
    destroy() {
        this.check.onchange = null;
    }
}

},{"../../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bsfIT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "input", ()=>input);
var _bb = require("../../../bb/bb");
const input = function(params) {
    const result = document.createElement("input");
    if (params.type) try {
        result.type = params.type;
    } catch (e) {} // ie can't deal with number
    else result.type = "text";
    if (params.min !== undefined) result.min = "" + params.min;
    if (params.max !== undefined) result.max = "" + params.max;
    result.value = "" + params.init;
    if (params.callback) result.onchange = function() {
        params.callback(result.value);
    };
    if (params.css) (0, _bb.BB).css(result, params.css);
    return result;
};

},{"../../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7mzRU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A select dropdown
 */ parcelHelpers.export(exports, "Select", ()=>Select);
var _bb = require("../../../bb/bb");
class Select {
    // --- public ---
    constructor(p){
        this.selectEl = (0, _bb.BB).el({
            tagName: "select",
            title: p.title,
            css: {
                cursor: "pointer",
                fontSize: "15px",
                padding: "3px",
                background: "#fff",
                //webkitAppearance: 'none'
                colorScheme: "only light"
            }
        });
        if (p.css) (0, _bb.BB).css(this.selectEl, p.css);
        const isFocusable = p.isFocusable;
        if (!isFocusable) this.selectEl.tabIndex = -1;
        this.optionArr = p.optionArr;
        for(let i = 0; i < this.optionArr.length; i++){
            if (this.optionArr[i] === null) continue;
            const option = document.createElement("option");
            option.value = this.optionArr[i][0];
            option.textContent = this.optionArr[i][1];
            this.selectEl.append(option);
        }
        this.onChange = p.onChange;
        this.changeListener = (e)=>{
            if (!isFocusable) this.selectEl.blur();
            this.onChange(this.selectEl.value);
        };
        this.selectEl.addEventListener("change", this.changeListener);
        this.selectEl.value = "initValue" in p ? p.initValue : null;
    }
    setValue(val) {
        this.selectEl.value = val;
    }
    getValue() {
        return this.selectEl.value;
    }
    setDeltaValue(delta) {
        let index = 0;
        for(let i = 0; i < this.optionArr.length; i++)if ("" + this.optionArr[i][0] === this.selectEl.value) {
            index = i;
            break;
        }
        index = Math.max(0, Math.min(this.optionArr.length - 1, index + delta));
        this.selectEl.value = this.optionArr[index][0];
        this.onChange(this.selectEl.value);
    }
    getElement() {
        return this.selectEl;
    }
    destroy = ()=>{
        this.selectEl.removeEventListener("change", this.changeListener);
    };
}

},{"../../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5vi2a":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ImageToggle", ()=>ImageToggle);
var _bb = require("../../../bb/bb");
const ImageToggle = function(p) {
    let isActive = !!p.initValue;
    const div = (0, _bb.BB).el({
        className: "image-toggle",
        title: p.title,
        css: {
            backgroundImage: "url('" + p.image + "')"
        },
        onClick: function(e) {
            e.preventDefault();
            if (p.isRadio && isActive) return;
            isActive = !isActive;
            update();
            p.onChange(isActive);
        }
    });
    function update() {
        div.classList.toggle("image-toggle-active", isActive);
    }
    update();
    // --- interface ---
    this.setValue = function(b) {
        isActive = !!b;
        update();
    };
    this.getElement = function() {
        return div;
    };
    this.getValue = function() {
        return isActive;
    };
    this.destroy = ()=>{
        (0, _bb.BB).destroyEl(div);
    };
};

},{"../../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"enKw8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ImageRadioList", ()=>ImageRadioList);
var _bb = require("../../../bb/bb");
var _imageToggle = require("./image-toggle");
const ImageRadioList = function(p) {
    const div = (0, _bb.BB).el({
        className: "image-radio-wrapper",
        css: {
            display: "flex"
        }
    });
    let activeIndex;
    const optionArr = [];
    function select(index, id) {
        activeIndex = index;
        for(let i = 0; i < optionArr.length; i++)optionArr[i].setValue(i === activeIndex);
        p.onChange(id);
    }
    function createOption(index, o) {
        if (o.id === p.initId) activeIndex = index;
        const radioEl = new (0, _imageToggle.ImageToggle)({
            image: o.image,
            title: o.title,
            initValue: o.id === p.initId,
            isRadio: true,
            onChange: function() {
                select(index, o.id);
            }
        });
        div.appendChild(radioEl.getElement());
        return radioEl;
    }
    for(let i = 0; i < p.optionArr.length; i++)optionArr.push(createOption(i, p.optionArr[i]));
    // --- interface ---
    this.getElement = function() {
        return div;
    };
    this.getValue = function() {
        return p.optionArr[activeIndex].id;
    };
    this.destroy = ()=>{
        optionArr.forEach((item)=>{
            item.destroy();
        });
    };
};

},{"../../../bb/bb":"dcQKo","./image-toggle":"5vi2a","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h5aJV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "penPressureToggle", ()=>penPressureToggle);
var _bb = require("../../../bb/bb");
// @ts-ignore
var _brushPressureSvg = require("url:~/src/app/img/ui/brush-pressure.svg");
var _brushPressureSvgDefault = parcelHelpers.interopDefault(_brushPressureSvg);
var _language = require("../../../language/language");
const penPressureToggle = function(isChecked, changeCallback) {
    const toggleDiv = (0, _bb.BB).el({
        css: {
            cssFloat: "right",
            borderRadius: "3px",
            width: "18px",
            height: "18px",
            backgroundImage: 'url("' + (0, _brushPressureSvgDefault.default) + '")',
            backgroundSize: "contain",
            backgroundRepeat: "no-repeat",
            cursor: "pointer",
            boxSizing: "border-box",
            colorScheme: "only light"
        }
    });
    if (!(0, _bb.BB).hasPointerEvents) toggleDiv.style.display = "none";
    function redraw() {
        if (isChecked) (0, _bb.BB).css(toggleDiv, {
            backgroundColor: "#fff",
            opacity: "0.9",
            border: "1px solid var(--active-highlight-color)"
        });
        else (0, _bb.BB).css(toggleDiv, {
            backgroundColor: "transparent",
            opacity: "0.5",
            border: "1px solid #666"
        });
    }
    toggleDiv.title = (0, _language.LANG)("brush-toggle-pressure");
    toggleDiv.onclick = function() {
        isChecked = !isChecked;
        redraw();
        changeCallback(isChecked);
    };
    redraw();
    changeCallback(isChecked);
    return toggleDiv;
};

},{"../../../bb/bb":"dcQKo","url:~/src/app/img/ui/brush-pressure.svg":"d2oJm","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d2oJm":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "brush-pressure.bbb8031a.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"6YGce":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Horizontal slider, can be changed by dragging anywhere on it. Has a label & value.
 * e.g. used for brush size
 *
 * left mouse button - set absolute value
 * right mouse button - change relative value
 * drag mouse vertically away - high precision mode
 * double-click/tap slider -> manual input mode
 *
 * Values can be spline interpolated
 * On change callback can be debounced
 *
 */ parcelHelpers.export(exports, "KlSlider", ()=>KlSlider);
var _bb = require("../../../bb/bb");
var _sliderFalloff = require("./slider-falloff");
var _language = require("../../../language/language");
var _eventChain = require("../../../bb/input/event-chain");
var _klSliderManualInput = require("./kl-slider-manual-input");
class KlSlider {
    emitValue = null;
    valueToSliderValue(value) {
        if (this.useSpline) return this.splineInterpolator.findX(value, Math.floor(this.resolution));
        return (value - this.min) / (this.max - this.min);
    }
    sliderValuetoValue(sliderValue) {
        let result = this.min + sliderValue * (this.max - this.min);
        if (this.useSpline) result = this.splineInterpolator.interpolate(sliderValue);
        return result;
    }
    updateLabel() {
        let displayValue = this.valueToDisplayValue(this.value);
        displayValue = this.formatFunc ? this.formatFunc(displayValue) : Math.round(displayValue);
        displayValue = displayValue.toLocaleString((0, _language.languageStrings).getCode());
        this.textEl.innerHTML = this.label + '&nbsp;&nbsp;<span style="font-weight:bold">' + displayValue + "</span>";
        const sliderValue = this.valueToSliderValue(this.value);
        this.control.style.width = sliderValue * this.elementWidth + "px";
    }
    emit(isFinal) {
        if (!isFinal && this.isChangeOnFinal) return;
        if (isFinal || !this.eventResMs) {
            this.onChange(this.value);
            if (this.emitInterval) {
                clearInterval(this.emitInterval);
                this.emitInterval = null;
            }
            return;
        }
        if (this.emitInterval) this.emitValue = this.value;
        else {
            this.onChange(this.value);
            this.emitInterval = setInterval(()=>{
                if (this.emitValue === null) {
                    clearInterval(this.emitInterval);
                    this.emitInterval = null;
                } else {
                    this.onChange(this.emitValue);
                    this.emitValue = null;
                }
            }, this.eventResMs);
        }
    }
    updateEnable() {
        (0, _bb.BB).css(this.sliderWrapperEl, {
            opacity: this.isEnabled ? null : "0.5",
            pointerEvents: this.isEnabled ? null : "none"
        });
        if (this.manualInput) this.manualInput.setIsEnabled(this.isEnabled);
    }
    showManualInput() {
        this.manualInput = new (0, _klSliderManualInput.KlSliderManualInput)(this.valueToDisplayValue(this.value), this.valueToDisplayValue(this.min), this.valueToDisplayValue(this.max), this.sliderWrapperEl.getBoundingClientRect(), (val)=>{
            val = this.displayValueToValue(val);
            this.setValue((0, _bb.BB).clamp(val, this.min, this.max));
            this.onChange(this.value);
        }, ()=>{
            (0, _bb.BB).css(this.sliderWrapperEl, {
                display: null
            });
            this.roolEl.removeChild(this.manualInput.getElement());
            this.manualInput.destroy();
            this.manualInput = null;
        }, this.manualInputRoundDigits && this.manualInputRoundDigits > 0 ? this.manualInputRoundDigits : 0);
        this.roolEl.append(this.manualInput.getElement());
        setTimeout(()=>{
            this.manualInput.focus();
        });
        (0, _bb.BB).css(this.sliderWrapperEl, {
            display: "none"
        });
    }
    // --- public ---
    constructor(p){
        const _this = this;
        this.isEnabled = p.isEnabled !== false;
        this.manualInputRoundDigits = p.manualInputRoundDigits;
        this.useSpline = !!p.curve;
        if (!p.label) throw new Error("KlSlider missing params");
        if (p.min != 0 && p.max != 0 && p.value != 0) {
            if (!p.min || !p.max || !p.value) throw new Error("KlSlider broken params");
        }
        if (p.min >= p.max) throw new Error("KlSlider broken params");
        this.min = p.min;
        this.max = p.max;
        this.value = (0, _bb.BB).clamp(p.value, this.min, this.max);
        this.elementWidth = p.width;
        this.elementHeight = p.height;
        this.resolution = p.resolution ? p.resolution : this.elementWidth * 2;
        this.onChange = p.onChange ? p.onChange : ()=>{};
        if (!this.displayValueToValue !== !this.valueToDisplayValue) throw new Error("both or neither have to be set, toValue and toDisplayValue");
        this.displayValueToValue = p.toValue ? p.toValue : (displayValue)=>displayValue;
        this.valueToDisplayValue = p.toDisplayValue ? p.toDisplayValue : (value)=>value;
        this.isChangeOnFinal = !!p.isChangeOnFinal;
        this.formatFunc = p.formatFunc;
        this.eventResMs = p.eventResMs;
        if (this.useSpline) {
            const curveArr = p.curve === "quadratic" ? (0, _bb.BB).quadraticSplineInput(this.min, this.max, 0.1) : p.curve;
            this.splineInterpolator = new (0, _bb.BB).SplineInterpolator(curveArr);
        }
        this.roolEl = (0, _bb.BB).el({
            css: {
                display: "flex"
            }
        });
        this.sliderWrapperEl = (0, _bb.BB).el({
            parent: this.roolEl,
            className: "sliderWrapper",
            css: {
                overflow: "hidden",
                position: "relative",
                width: this.elementWidth + "px",
                height: this.elementHeight + "px",
                userSelect: "none"
            }
        });
        this.roolEl.oncontextmenu = function() {
            return false;
        };
        this.label = p.label;
        const labelFontSize = this.elementHeight - 14;
        this.textEl = (0, _bb.BB).el({
            content: this.label,
            css: {
                position: "absolute",
                left: "7px",
                top: this.elementHeight / 2 - labelFontSize / 2 + 1 + "px",
                lineHeight: labelFontSize + "px",
                fontSize: labelFontSize + "px",
                pointerEvents: "none"
            }
        });
        this.control = (0, _bb.BB).el({
            className: "sliderInner",
            css: {
                position: "absolute",
                left: "0",
                top: "0",
                width: this.valueToSliderValue(this.value) * this.elementWidth + "px",
                height: this.elementHeight + "px"
            }
        });
        const controlInner = document.createElement("div");
        this.sliderWrapperEl.append(this.control, this.textEl);
        this.control.append(controlInner);
        this.updateEnable();
        const doubleTapper = new (0, _eventChain.DoubleTapper)({
            onDoubleTap: ()=>{
                this.showManualInput();
            }
        });
        doubleTapper.setAllowedButtonArr([
            "left",
            "right"
        ]);
        const eventChain = new (0, _eventChain.EventChain)({
            chainArr: [
                doubleTapper
            ]
        });
        let virtualVal;
        const onPointer = (event)=>{
            event.eventPreventDefault();
            if (!this.isEnabled) return;
            if (event.type === "pointerdown") {
                // unfocus manual slider input
                (0, _bb.BB).unfocusAnyInput();
                this.sliderWrapperEl.className = "sliderWrapper sliderWrapperActive";
                if (event.button === "left") {
                    let sliderValue = event.relX / this.elementWidth;
                    sliderValue = Math.max(0, Math.min(1, sliderValue));
                    this.value = this.sliderValuetoValue(sliderValue);
                    this.updateLabel();
                    this.emit(false);
                }
                virtualVal = this.valueToSliderValue(this.value);
            }
            if (event.type === "pointermove" && [
                "left",
                "right"
            ].includes(event.button)) {
                let deltaX = event.dX;
                const deltaY = Math.abs(event.pageY - event.downPageY);
                const factor = (0, _sliderFalloff.calcSliderFalloffFactor)(deltaY, event.button === "right");
                deltaX *= factor;
                deltaX /= this.elementWidth;
                virtualVal += deltaX;
                let sliderValue1 = Math.max(0, Math.min(1, virtualVal));
                this.value = this.sliderValuetoValue(sliderValue1);
                this.updateLabel();
                this.emit(false);
            }
            if (event.type === "pointerup") {
                this.sliderWrapperEl.className = "sliderWrapper";
                this.emit(true);
            }
        };
        this.pointerListenerTimeout = setTimeout(()=>{
            this.pointerListener = new (0, _bb.BB).PointerListener({
                target: this.sliderWrapperEl,
                maxPointers: 1,
                fixScribble: true,
                onPointer: (e)=>{
                    onPointer(e);
                    eventChain.chainIn(e);
                },
                onWheel: (event)=>{
                    let sliderValue = this.valueToSliderValue(this.value);
                    sliderValue = (0, _bb.BB).clamp(sliderValue - event.deltaY / 40, 0, 1);
                    this.value = this.sliderValuetoValue(sliderValue);
                    this.updateLabel();
                    this.onChange(this.value);
                }
            });
            this.updateLabel();
        }, 1);
    }
    changeSliderValue(f) {
        if (!this.isEnabled) return;
        let sliderValue = this.valueToSliderValue(this.value);
        sliderValue = (0, _bb.BB).clamp(sliderValue + f, 0, 1);
        this.value = this.sliderValuetoValue(sliderValue);
        this.updateLabel();
        this.onChange(this.value);
    }
    setValue(v) {
        this.value = (0, _bb.BB).clamp(v, this.min, this.max);
        this.updateLabel();
    }
    getValue() {
        return this.value;
    }
    update(config) {
        this.min = config.min;
        this.max = config.max;
        this.useSpline = !!config.curve;
        if (this.useSpline) {
            const curveArr = config.curve === "quadratic" ? (0, _bb.BB).quadraticSplineInput(this.min, this.max, 0.1) : config.curve;
            this.splineInterpolator = new (0, _bb.BB).SplineInterpolator(curveArr);
        } else this.splineInterpolator = null;
        this.setIsEnabled(!config.isDisabled);
    }
    setIsEnabled(e) {
        this.isEnabled = !!e;
        this.updateEnable();
    }
    destroy() {
        clearTimeout(this.pointerListenerTimeout);
        if (this.pointerListener) this.pointerListener.destroy();
        if (this.manualInput) this.manualInput.destroy();
        if (this.emitInterval) clearInterval(this.emitInterval);
    }
    getElement() {
        return this.roolEl;
    }
}

},{"../../../bb/bb":"dcQKo","./slider-falloff":"e9Q7X","../../../language/language":"iiYGN","../../../bb/input/event-chain":"3yNW8","./kl-slider-manual-input":"lmQtM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e9Q7X":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "calcSliderFalloffFactor", ()=>calcSliderFalloffFactor);
const calcSliderFalloffFactor = function(deltaY, isRightButton) {
    let result = Math.min(10, 1 + Math.pow(Math.floor(deltaY / 50), 2));
    if (isRightButton) result *= 2;
    return 1 / result;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lmQtM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Used by KlSlider. Allows user to type in value in input (type=number) field, instead of dragging with mouse.
 * Input goes away when losing focus, or when pressing Enter/Escape.
 */ parcelHelpers.export(exports, "KlSliderManualInput", ()=>KlSliderManualInput);
var _bb = require("../../../bb/bb");
var _input = require("./input");
class KlSliderManualInput {
    emit() {
        if (this.lastValue !== Number(this.input.value)) {
            this.onChange(Number(this.input.value));
            this.lastValue = Number(this.input.value);
        }
    }
    privateOnClose() {
        if (this.isClosed) return;
        this.isClosed = true;
        this.emit();
        this.onClose();
        setTimeout(()=>{
            // because iPad keyboard changes the scroll position
            window.scrollTo(this.scrollBefore.x, this.scrollBefore.y);
            this.scrollBefore = null;
        });
    }
    // --- public ---
    constructor(value, min, max, rect, onChange, onClose, roundDigits){
        this.onChange = onChange;
        this.onClose = onClose;
        this.isClosed = false;
        this.input = (0, _input.input)({
            type: "number",
            init: value,
            min,
            max,
            callback: (val)=>{
                this.emit();
            }
        });
        if (roundDigits !== 0) this.input.setAttribute("step", "any");
        this.input.onblur = ()=>{
            this.privateOnClose();
        };
        this.input.addEventListener("keyup", (e)=>{
            if ([
                "Enter",
                "Escape"
            ].includes(e.key)) this.privateOnClose();
            else this.emit();
        });
        this.input.addEventListener("wheel", ()=>this.emit());
        this.scrollBefore = {
            x: window.scrollX,
            y: window.scrollY
        };
        let currentValue;
        if (roundDigits || roundDigits === 0) currentValue = (0, _bb.BB).round(value, roundDigits);
        else currentValue = value;
        this.lastValue = currentValue;
        this.input.value = "" + currentValue;
        (0, _bb.BB).css(this.input, {
            width: rect.width + "px",
            height: rect.height + "px"
        });
    }
    getElement() {
        return this.input;
    }
    setIsEnabled(b) {
        this.isEnabled = !!b;
    }
    focus() {
        this.input.focus();
        this.input.select();
    }
    destroy() {
        (0, _bb.BB).destroyEl(this.input);
    }
}

},{"../../../bb/bb":"dcQKo","./input":"bsfIT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"es6uV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HexColorDialog", ()=>HexColorDialog);
var _bb = require("../../../bb/bb");
var _input = require("../base-components/input");
var _popup = require("./popup");
var _language = require("../../../language/language");
// @ts-ignore
var _copySvg = require("url:~/src/app/img/ui/copy.svg");
var _copySvgDefault = parcelHelpers.interopDefault(_copySvg);
const HexColorDialog = function(p) {
    let lastValidRgb = new (0, _bb.BB).RGB(p.color.r, p.color.g, p.color.b);
    const div = (0, _bb.BB).el({});
    const previewEl = (0, _bb.BB).el({
        css: {
            width: "20px",
            height: "20px",
            marginBottom: "10px",
            boxShadow: "inset 0 0 0 1px #fff, 0 0 0 1px #000",
            background: "#" + (0, _bb.BB).ColorConverter.toHexString(lastValidRgb),
            colorScheme: "only light"
        }
    });
    div.appendChild(previewEl);
    // --- Hex ---
    const hexRowEl = (0, _bb.BB).el({
        css: {
            display: "flex",
            alignItems: "center",
            marginBottom: "15px"
        }
    });
    const hexLabel = (0, _bb.BB).el({
        content: (0, _language.LANG)("mci-hex"),
        css: {
            width: "60px"
        }
    });
    const hexInput = (0, _input.input)({
        init: "#" + (0, _bb.BB).ColorConverter.toHexString(lastValidRgb),
        css: {
            width: "80px"
        },
        callback: function() {
            let rgbObj = (0, _bb.BB).ColorConverter.hexToRGB(hexInput.value);
            if (rgbObj === null) {
                rgbObj = lastValidRgb;
                hexInput.value = "#" + (0, _bb.BB).ColorConverter.toHexString(lastValidRgb);
            } else lastValidRgb = rgbObj;
            previewEl.style.background = "#" + (0, _bb.BB).ColorConverter.toHexString(rgbObj);
            for(let i = 0; i < rgbArr.length; i++)rgbArr[i].update();
        }
    });
    const copyButton = (0, _bb.BB).el({
        tagName: "button",
        content: '<img src="' + (0, _copySvgDefault.default) + '" height="20"/>',
        title: (0, _language.LANG)("mci-copy"),
        css: {
            marginLeft: "10px"
        },
        onClick: function() {
            hexInput.select();
            document.execCommand("copy");
        }
    });
    hexRowEl.appendChild(hexLabel);
    hexRowEl.appendChild(hexInput);
    hexRowEl.appendChild(copyButton);
    div.appendChild(hexRowEl);
    setTimeout(function() {
        hexInput.focus();
        hexInput.select();
    }, 0);
    // --- R G B ---
    function createRgbInputRow(labelStr, attributeStr) {
        const result = {};
        const rowEl = (0, _bb.BB).el({
            css: {
                display: "flex",
                alignItems: "center",
                marginTop: "5px"
            }
        });
        const labelEl = (0, _bb.BB).el({
            content: labelStr,
            css: {
                width: "60px"
            }
        });
        const inputEl = (0, _input.input)({
            init: lastValidRgb[attributeStr],
            min: 0,
            max: 255,
            type: "number",
            css: {
                width: "80px"
            },
            callback: function() {
                if (inputEl.value === "" || parseFloat(inputEl.value) < 0 || parseFloat(inputEl.value) > 255) {
                    result.update();
                    return;
                }
                inputEl.value = "" + Math.round(parseFloat(inputEl.value));
                lastValidRgb[attributeStr] = inputEl.value;
                previewEl.style.background = "#" + (0, _bb.BB).ColorConverter.toHexString(lastValidRgb);
                hexInput.value = "#" + (0, _bb.BB).ColorConverter.toHexString(lastValidRgb);
            }
        });
        rowEl.appendChild(labelEl);
        rowEl.appendChild(inputEl);
        div.appendChild(rowEl);
        result.update = function() {
            inputEl.value = lastValidRgb[attributeStr];
        };
        result.destroy = ()=>{
            inputEl.onchange = null;
        };
        return result;
    }
    const rgbArr = [];
    rgbArr.push(createRgbInputRow((0, _language.LANG)("red"), "r"));
    rgbArr.push(createRgbInputRow((0, _language.LANG)("green"), "g"));
    rgbArr.push(createRgbInputRow((0, _language.LANG)("blue"), "b"));
    (0, _popup.popup)({
        target: document.body,
        message: `<b>${(0, _language.LANG)("manual-color-input")}</b>`,
        div: div,
        autoFocus: false,
        clickOnEnter: "Ok",
        buttons: [
            "Ok",
            "Cancel"
        ],
        callback: function(resultStr) {
            (0, _bb.BB).destroyEl(copyButton);
            rgbArr.forEach((item)=>item.destroy());
            rgbArr.splice(0, rgbArr.length);
            p.onClose(resultStr === "Ok" ? (0, _bb.BB).ColorConverter.hexToRGB(hexInput.value) : null);
        }
    });
};

},{"../../../bb/bb":"dcQKo","../base-components/input":"bsfIT","./popup":"4Ltiz","../../../language/language":"iiYGN","url:~/src/app/img/ui/copy.svg":"fWmY4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fWmY4":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "copy.b1df5ac8.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"c14dz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "KlColorSlider", ()=>KlColorSlider);
var _bb = require("../../../bb/bb");
var _colorSliderHexDialog = require("../modals/color-slider-hex-dialog");
var _sliderFalloff = require("./slider-falloff");
// @ts-ignore
var _toolPickerSvg = require("url:~/src/app/img/ui/tool-picker.svg");
var _toolPickerSvgDefault = parcelHelpers.interopDefault(_toolPickerSvg);
var _language = require("../../../language/language");
const KlColorSlider = function(p) {
    const _this = this;
    let pickCallback = function(result) {};
    const div = document.createElement("div");
    div.style.position = "relative";
    div.className = "colorSlider";
    const outputDiv = (0, _bb.BB).el({
        css: {
            display: "flex",
            alignItems: "center"
        }
    });
    const width = p.width;
    let svHeight = p.svHeight;
    const height = p.height;
    const emitColor = p.onPick;
    let primaryColorRGB = {
        r: parseInt(p.startValue.r, 10),
        g: parseInt(p.startValue.g, 10),
        b: parseInt(p.startValue.b, 10)
    };
    let primaryColorHSV = (0, _bb.BB).ColorConverter.toHSV(p.startValue); // BB.HSV
    let secondaryColorRGB = {
        r: 255,
        g: 255,
        b: 255
    };
    let secondaryColorHSV = (0, _bb.BB).ColorConverter._RGBtoHSV(secondaryColorRGB); // BB.HSV
    const svWrapper = (0, _bb.BB).el({});
    const svSvg = new DOMParser().parseFromString('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" preserveAspectRatio="none"> <defs> <linearGradient id="value" gradientTransform="rotate(90)"> <stop offset="0" stop-color="rgba(0,0,0,0)"/> <stop offset="100%" stop-color="rgba(0,0,0,1)"/> </linearGradient> <linearGradient id="hue" gradientTransform="rotate(0)"> <stop offset="0" stop-color="#fff"/> <stop id="hue-stop" offset="100%" stop-color="#f00"/> </linearGradient> </defs> <rect x="0" y="0" width="100" height="100" fill="url(\'#hue\')"/> <rect x="0" y="0" width="100" height="100" fill="url(\'#value\')"/></svg>', "image/svg+xml").documentElement;
    const hueStop = svSvg.getElementById("hue-stop");
    (0, _bb.BB).setAttributes(hueStop, {
        "stop-color": "#f0f"
    });
    (0, _bb.BB).css(svSvg, {
        width: width + "px",
        height: svHeight + "px"
    });
    svWrapper.appendChild(svSvg);
    const divH = document.createElement("div");
    (0, _bb.BB).css(divH, {
        position: "relative",
        height: height + "px"
    });
    const divPreview = document.createElement("div");
    const controlH = document.createElement("div");
    const enabled = true;
    function updatePrimaryHSV(hsv) {
        if (hsv.s === 0) primaryColorHSV = new (0, _bb.BB).HSV(primaryColorHSV.h, hsv.s, hsv.v);
        else primaryColorHSV = new (0, _bb.BB).HSV(hsv.h, hsv.s, hsv.v);
    }
    function createHueBg(targetEl) {
        const im = new Image();
        (0, _bb.BB).css(im, {
            position: "absolute",
            left: "0",
            top: "0",
            display: "none",
            pointerEvents: "none"
        });
        const cv = (0, _bb.BB).canvas(width, height);
        const ctx = cv.getContext("2d");
        const gradH = ctx.createLinearGradient(0, 0, width, 0);
        for(let i = 0; i < 1; i += 0.01){
            const col = (0, _bb.BB).ColorConverter.toRGB(new (0, _bb.BB).HSV(i * 360, 100, 100));
            let ha = parseInt("" + col.r).toString(16);
            let hb = parseInt("" + col.g).toString(16);
            let hc = parseInt("" + col.b).toString(16);
            if (ha.length === 1) ha = "0" + ha;
            if (hb.length === 1) hb = "0" + hb;
            if (hc.length === 1) hc = "0" + hc;
            gradH.addColorStop(i, "#" + ha + hb + hc);
        }
        ctx.fillStyle = gradH;
        ctx.fillRect(0, 0, width, height);
        targetEl.appendChild(im);
        im.alt = "hue";
        im.src = cv.toDataURL("image/png");
        im.style.display = "block";
    }
    function updateSVCanvas() {
        const rgb = (0, _bb.BB).ColorConverter.toRGB(new (0, _bb.BB).HSV(primaryColorHSV.h, 100, 100));
        (0, _bb.BB).setAttributes(hueStop, {
            "stop-color": "#" + (0, _bb.BB).ColorConverter.toHexString(rgb)
        });
    }
    function updateSVPointer() {
        const left = primaryColorHSV.s / 100 * width - 7;
        const top = (1 - primaryColorHSV.v / 100) * svHeight - 6;
        (0, _bb.BB).css(pointerSV, {
            left: left + "px",
            top: top + "px"
        });
    }
    function setColPreview() {
        divPreview.style.backgroundColor = "rgb(" + primaryColorRGB.r + "," + primaryColorRGB.g + "," + primaryColorRGB.b + ")";
        if ((0, _bb.BB).testIsWhiteBestContrast(primaryColorRGB)) {
            (0, _bb.BB).css(pickerButton, {
                filter: "invert(1)"
            });
            (0, _bb.BB).css(hexButton, {
                filter: "invert(1)"
            });
        } else {
            (0, _bb.BB).css(pickerButton, {
                filter: ""
            });
            (0, _bb.BB).css(hexButton, {
                filter: ""
            });
        }
    }
    updateSVCanvas();
    div.style.width = width + "px";
    div.oncontextmenu = function() {
        return false;
    };
    const SVContainer = document.createElement("div");
    (0, _bb.BB).css(SVContainer, {
        width: width + "px",
        height: svHeight + "px",
        overflow: "hidden",
        display: "block",
        position: "relative",
        cursor: "crosshair",
        boxShadow: "rgb(188, 188, 188) 0 0 0 1px"
    });
    const pointerSV = document.createElement("div");
    (0, _bb.BB).css(pointerSV, {
        width: "12px",
        height: "12px",
        borderRadius: "6px",
        position: "absolute",
        pointerEvents: "none",
        boxShadow: "0px 0px 0 1px #000, inset 0px 0px 0 1px #fff"
    });
    SVContainer.appendChild(svWrapper);
    SVContainer.appendChild(pointerSV);
    updateSVPointer();
    div.appendChild(SVContainer);
    div.appendChild(divH);
    outputDiv.appendChild(divPreview);
    (0, _bb.BB).css(divPreview, {
        display: "flex",
        justifyContent: "space-between",
        width: height * 2.5 + "px",
        height: height + "px",
        //position: "relative",
        boxShadow: "rgb(188, 188, 188) 0 0 0 1px",
        colorScheme: "only light"
    });
    (0, _bb.BB).css(divH, {
        overflow: "hidden",
        position: "relative",
        width: width + "px",
        height: height + "px",
        cursor: "ew-resize",
        boxShadow: "rgb(188, 188, 188) 0 0 0 1px",
        marginTop: "1px",
        marginBottom: "1px"
    });
    //divH.className = "svSlider";
    (0, _bb.BB).css(controlH, {
        width: "1px",
        height: height + "px",
        background: "#000",
        borderLeft: "1px solid #fff",
        position: "absolute",
        top: "0",
        left: parseInt("" + (primaryColorHSV.h / 360 * width - 1)) + "px"
    });
    const virtualHSV = {
        h: 0,
        s: 0,
        v: 0
    };
    let svPointerListener;
    let hPointerListener;
    const pickerButton = (0, _bb.BB).el({
        title: (0, _language.LANG)("eyedropper") + " [Alt]",
        className: "color-picker-preview-button",
        css: {
            width: "30px",
            height: "30px",
            backgroundImage: "url(" + (0, _toolPickerSvgDefault.default) + ")",
            backgroundRepeat: "no-repeat",
            backgroundSize: "70%",
            backgroundPosition: "center"
        }
    });
    let isPicking = false;
    pickerButton.onclick = function() {
        if (isPicking === false) {
            pickerButton.classList.remove("color-picker-preview-button-hover");
            pickerButton.classList.add("color-picker-preview-button-active");
            isPicking = true;
            pickCallback(true);
        } else {
            pickCallback(false);
            _this.pickingDone();
        }
    };
    const pickerButtonPointerListener = new (0, _bb.BB).PointerListener({
        target: pickerButton,
        onEnterLeave: function(isOver) {
            if (isPicking) return;
            pickerButton.classList.toggle("color-picker-preview-button-hover", isOver);
        }
    });
    divPreview.appendChild(pickerButton);
    const hexButton = (0, _bb.BB).el({
        content: "#",
        className: "color-picker-preview-button",
        title: (0, _language.LANG)("manual-color-input"),
        css: {
            height: "100%",
            width: height + "px",
            lineHeight: height + "px",
            fontSize: height * 0.65 + "px"
        },
        onClick: function() {
            (0, _colorSliderHexDialog.HexColorDialog)({
                color: new (0, _bb.BB).RGB(primaryColorRGB.r, primaryColorRGB.g, primaryColorRGB.b),
                onClose: function(rgbObj) {
                    if (!rgbObj) return;
                    _this.setColor(rgbObj);
                    emitColor(new (0, _bb.BB).RGB(primaryColorRGB.r, primaryColorRGB.g, primaryColorRGB.b));
                }
            });
        }
    });
    const hexButtonPointerListener = new (0, _bb.BB).PointerListener({
        target: hexButton,
        onEnterLeave: function(isOver) {
            hexButton.classList.toggle("color-picker-preview-button-hover", isOver);
        }
    });
    divPreview.appendChild(hexButton);
    setColPreview();
    setTimeout(function() {
        createHueBg(divH);
        divH.appendChild(controlH);
        svPointerListener = new (0, _bb.BB).PointerListener({
            target: svWrapper,
            maxPointers: 1,
            fixScribble: true,
            onPointer: function(event) {
                if (event.type === "pointerdown") {
                    // prevent manual slider input keeping focus on iPad
                    (0, _bb.BB).unfocusAnyInput();
                    (0, _bb.BB).css(SVContainer, {
                        boxShadow: "0px 0px 0px 1px rgb(255,255,255)",
                        zIndex: "1"
                    });
                    if (event.button === "left") {
                        virtualHSV.s = event.relX / width * 100;
                        virtualHSV.v = 100 - event.relY / svHeight * 100;
                        primaryColorHSV = new (0, _bb.BB).HSV(primaryColorHSV.h, virtualHSV.s, virtualHSV.v);
                        primaryColorRGB = (0, _bb.BB).ColorConverter.toRGB(primaryColorHSV);
                        updateSVPointer();
                        setColPreview();
                        emitColor((0, _bb.BB).ColorConverter.toRGB(primaryColorHSV));
                    } else {
                        virtualHSV.s = primaryColorHSV.s;
                        virtualHSV.v = primaryColorHSV.v;
                    }
                }
                if (event.type === "pointermove" && [
                    "left",
                    "right"
                ].includes(event.button)) {
                    let factor = 1;
                    if (event.button === "right") factor = 0.5;
                    virtualHSV.s += event.dX / width * 100 * factor;
                    virtualHSV.v -= event.dY / svHeight * 100 * factor;
                    primaryColorHSV = new (0, _bb.BB).HSV(primaryColorHSV.h, virtualHSV.s, virtualHSV.v);
                    primaryColorRGB = (0, _bb.BB).ColorConverter.toRGB(primaryColorHSV);
                    updateSVPointer();
                    setColPreview();
                    emitColor((0, _bb.BB).ColorConverter.toRGB(primaryColorHSV));
                }
                if (event.type === "pointerup") (0, _bb.BB).css(SVContainer, {
                    boxShadow: "0 0 0 1px rgb(188, 188, 188)",
                    zIndex: "0"
                });
            }
        });
        hPointerListener = new (0, _bb.BB).PointerListener({
            target: divH,
            maxPointers: 1,
            fixScribble: true,
            onPointer: function(event) {
                if (event.type === "pointerdown") {
                    // prevent manual slider input keeping focus on iPad
                    (0, _bb.BB).unfocusAnyInput();
                    (0, _bb.BB).css(divH, {
                        boxShadow: "0px 0px 0px 1px rgba(255,255,255,1)"
                    });
                    if (event.button === "left") {
                        virtualHSV.h = event.relX / width * 359.99;
                        primaryColorHSV = new (0, _bb.BB).HSV(virtualHSV.h, primaryColorHSV.s, primaryColorHSV.v);
                        primaryColorRGB = (0, _bb.BB).ColorConverter.toRGB(primaryColorHSV);
                        controlH.style.left = Math.round(primaryColorHSV.h / 359.99 * width) - 1 + "px";
                        updateSVCanvas();
                        setColPreview();
                        emitColor((0, _bb.BB).ColorConverter.toRGB(primaryColorHSV));
                    } else virtualHSV.h = primaryColorHSV.h;
                }
                if (event.type === "pointermove" && [
                    "left",
                    "right"
                ].includes(event.button)) {
                    const deltaY = Math.abs(event.pageY - event.downPageY);
                    const factor = (0, _sliderFalloff.calcSliderFalloffFactor)(deltaY, event.button === "right");
                    virtualHSV.h += event.dX / width * 359.99 * factor;
                    if (event.button === "right") {
                        virtualHSV.h = virtualHSV.h % 359.99;
                        if (virtualHSV.h < 0) virtualHSV.h += 359.99;
                    }
                    virtualHSV.h = Math.min(359.99, virtualHSV.h);
                    primaryColorHSV = new (0, _bb.BB).HSV(virtualHSV.h, primaryColorHSV.s, primaryColorHSV.v);
                    primaryColorRGB = (0, _bb.BB).ColorConverter.toRGB(primaryColorHSV);
                    controlH.style.left = Math.round(primaryColorHSV.h / 359.99 * width) - 1 + "px";
                    updateSVCanvas();
                    setColPreview();
                    emitColor((0, _bb.BB).ColorConverter.toRGB(primaryColorHSV));
                }
                if (event.type === "pointerup") (0, _bb.BB).css(divH, {
                    boxShadow: "rgb(188, 188, 188) 0 0 0 1px"
                });
            }
        });
    }, 1);
    // --- second color ---
    const secondaryColorBtn = (0, _bb.BB).el({
        parent: outputDiv,
        title: (0, _language.LANG)("secondary-color") + " [X]",
        css: {
            cursor: "pointer",
            marginLeft: "5px",
            width: "22px",
            height: "22px",
            boxShadow: "rgb(188, 188, 188) 0px 0px 0px 1px",
            colorScheme: "only light"
        },
        onClick: function(e) {
            e.preventDefault();
            swapColors();
        }
    });
    function updateSecondaryColor() {
        secondaryColorBtn.style.backgroundColor = (0, _bb.BB).ColorConverter.toRgbStr(secondaryColorRGB);
    }
    function swapColors() {
        // swap hsv
        let tmp = secondaryColorHSV;
        secondaryColorHSV = primaryColorHSV;
        updatePrimaryHSV(tmp);
        // swap rgb
        tmp = secondaryColorRGB;
        secondaryColorRGB = primaryColorRGB;
        primaryColorRGB = tmp;
        controlH.style.left = parseInt("" + (primaryColorHSV.h / 359 * width - 1)) + "px";
        updateSVCanvas();
        updateSVPointer();
        setColPreview();
        updateSecondaryColor();
        emitColor(new (0, _bb.BB).RGB(primaryColorRGB.r, primaryColorRGB.g, primaryColorRGB.b));
    }
    updateSecondaryColor();
    // --- interface ---
    this.setColor = function(c) {
        primaryColorRGB = {
            r: parseInt(c.r, 10),
            g: parseInt(c.g, 10),
            b: parseInt(c.b, 10)
        };
        updatePrimaryHSV((0, _bb.BB).ColorConverter.toHSV(c));
        controlH.style.left = parseInt("" + (primaryColorHSV.h / 359 * width - 1)) + "px";
        updateSVCanvas();
        updateSVPointer();
        setColPreview();
    };
    this.getColor = function() {
        return new (0, _bb.BB).RGB(primaryColorRGB.r, primaryColorRGB.g, primaryColorRGB.b);
    };
    this.getSecondaryRGB = function() {
        return new (0, _bb.BB).RGB(secondaryColorRGB.r, secondaryColorRGB.g, secondaryColorRGB.b);
    };
    this.setPickCallback = function(func) {
        pickCallback = func;
    };
    this.pickingDone = function() {
        if (!isPicking) return;
        isPicking = false;
        pickerButton.classList.remove("color-picker-preview-button-active");
    };
    this.enable = function(e) {
        if (e) {
            div.style.pointerEvents = "";
            div.style.opacity = "1";
            outputDiv.style.pointerEvents = "";
            outputDiv.style.opacity = "1";
        } else {
            div.style.pointerEvents = "none";
            div.style.opacity = "0.5";
            outputDiv.style.pointerEvents = "none";
            outputDiv.style.opacity = "0.5";
        }
    };
    this.setHeight = function(h) {
        h = parseInt("" + (h - height * 2 - 3), 10);
        if (h === svHeight) return;
        svHeight = h;
        (0, _bb.BB).css(svSvg, {
            width: width + "px",
            height: svHeight + "px"
        });
        SVContainer.style.height = svHeight + "px";
        updateSVPointer();
    };
    this.swapColors = function() {
        swapColors();
    };
    this.getElement = function() {
        return div;
    };
    this.getOutputElement = function() {
        return outputDiv;
    };
};

},{"../../../bb/bb":"dcQKo","../modals/color-slider-hex-dialog":"es6uV","./slider-falloff":"e9Q7X","url:~/src/app/img/ui/tool-picker.svg":"jo1fC","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jo1fC":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "tool-picker.54196984.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"gZ9fi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "KlSmallColorSlider", ()=>KlSmallColorSlider);
var _bb = require("../../../bb/bb");
var _sliderFalloff = require("./slider-falloff");
const KlSmallColorSlider = function(params) {
    const div = document.createElement("div");
    div.oncontextmenu = function(e) {
        e.preventDefault();
    };
    let color = (0, _bb.BB).ColorConverter.toHSV(new (0, _bb.BB).RGB(params.color.r, params.color.g, params.color.b));
    (0, _bb.BB).css(div, {
        width: params.width + "px",
        position: "relative",
        overflow: "hidden",
        userSelect: "none"
    });
    const canvasSV = (0, _bb.BB).canvas(10, 10);
    canvasSV.style.width = params.width + "px";
    canvasSV.style.height = params.heightSV + "px";
    canvasSV.style.cursor = "crosshair";
    function updateSV() {
        const ctx = canvasSV.getContext("2d");
        for(let i = 0; i < canvasSV.height; i += 1){
            const gradient1 = ctx.createLinearGradient(0, 0, canvasSV.width, 0);
            const colleft = (0, _bb.BB).ColorConverter.toRGB(new (0, _bb.BB).HSV(color.h, 1, 100 - i / canvasSV.height * 100.0));
            const colright = (0, _bb.BB).ColorConverter.toRGB(new (0, _bb.BB).HSV(color.h, 100, 100 - i / canvasSV.height * 100.0));
            gradient1.addColorStop(0, "#" + (0, _bb.BB).ColorConverter.toHexString(colleft));
            gradient1.addColorStop(1, "#" + (0, _bb.BB).ColorConverter.toHexString(colright));
            ctx.fillStyle = "#ff0000"; //needed for chrome...otherwise alpha problem
            ctx.fillStyle = gradient1;
            ctx.fillRect(0, i, canvasSV.width, 1);
        }
    }
    updateSV();
    const canvasH = (0, _bb.BB).canvas(params.width, params.heightH);
    canvasH.style.cursor = "ew-resize";
    (function() {
        const ctx = canvasH.getContext("2d");
        const gradH = ctx.createLinearGradient(0, 0, params.width, 0);
        for(let i = 0; i < 1; i += 0.01){
            const col = (0, _bb.BB).ColorConverter.toRGB(new (0, _bb.BB).HSV(i * 360, 100, 100));
            gradH.addColorStop(i, "rgba(" + parseInt("" + col.r) + ", " + parseInt("" + col.g) + ", " + parseInt("" + col.b) + ", 1)");
        }
        ctx.fillStyle = gradH;
        ctx.fillRect(0, 0, params.width, params.heightH);
    })();
    (0, _bb.BB).css(canvasSV, {
        width: params.width + "px",
        height: params.heightSV + "px",
        overflow: "hidden",
        position: "relative"
    });
    canvasSV.style.cssFloat = "left";
    canvasH.style.cssFloat = "left";
    div.appendChild(canvasSV);
    div.appendChild(canvasH);
    const pointerSV = document.createElement("div");
    (0, _bb.BB).css(pointerSV, {
        width: "8px",
        height: "8px",
        borderRadius: "8px",
        position: "absolute",
        pointerEvents: "none",
        boxShadow: "0 0 0 1px #000, inset 0 0 0 1px #fff"
    });
    div.appendChild(pointerSV);
    const pointerH = document.createElement("div");
    (0, _bb.BB).css(pointerH, {
        width: "0",
        height: params.heightH + "px",
        borderLeft: "1px solid #fff",
        borderRight: "1px solid #000",
        position: "absolute",
        top: params.heightSV + "px",
        pointerEvents: "none"
    });
    div.appendChild(pointerH);
    function updateSVPointer() {
        const left = color.s / 100 * params.width - 4;
        const top = (1 - color.v / 100) * params.heightSV - 4;
        (0, _bb.BB).css(pointerSV, {
            left: left + "px",
            top: top + "px"
        });
    /*if (top < params.heightSV/3) {
        pointerSV.style.border = "1px solid rgba(0,0,0,1)";
    } else {
        pointerSV.style.border = "1px solid rgba(255,255,255,1)";
    }*/ }
    function updateHPointer() {
        pointerH.style.left = color.h / 359.999 * params.width - 1 + "px";
    }
    updateSVPointer();
    updateHPointer();
    const virtualHSV = {
        h: 0,
        s: 0,
        v: 0
    };
    let svPointerId = null;
    const svPointerListener = new (0, _bb.BB).PointerListener({
        target: canvasSV,
        maxPointers: 1,
        fixScribble: true,
        onPointer: function(event) {
            if (event.type === "pointerdown") {
                // prevent manual slider input keeping focus on iPad
                (0, _bb.BB).unfocusAnyInput();
                svPointerId = event.pointerId;
                if (event.button === "left") {
                    virtualHSV.s = event.relX / params.width * 100;
                    virtualHSV.v = 100 - event.relY / params.heightSV * 100;
                    color = new (0, _bb.BB).HSV(color.h, virtualHSV.s, virtualHSV.v);
                    updateSVPointer();
                    params.callback((0, _bb.BB).ColorConverter.toRGB(color));
                } else {
                    virtualHSV.s = color.s;
                    virtualHSV.v = color.v;
                }
            }
            if (event.type === "pointermove" && [
                "left",
                "right"
            ].includes(event.button) && svPointerId === event.pointerId) {
                let factor = 1;
                if (event.button === "right") factor = 0.5;
                virtualHSV.s += event.dX / params.width * 100 * factor;
                virtualHSV.v -= event.dY / params.heightSV * 100 * factor;
                color = new (0, _bb.BB).HSV(color.h, virtualHSV.s, virtualHSV.v);
                updateSVPointer();
                params.callback((0, _bb.BB).ColorConverter.toRGB(color));
            }
            if (event.type === "pointerup") svPointerId = null;
        }
    });
    let hPointerId = null;
    const hPointerListener = new (0, _bb.BB).PointerListener({
        target: canvasH,
        maxPointers: 1,
        fixScribble: true,
        onPointer: function(event) {
            if (event.type === "pointerdown") {
                hPointerId = event.pointerId;
                if (event.button === "left") {
                    virtualHSV.h = event.relX / params.width * 359.99;
                    color = new (0, _bb.BB).HSV(virtualHSV.h, color.s, color.v);
                    updateSV();
                    updateHPointer();
                    params.callback((0, _bb.BB).ColorConverter.toRGB(color));
                } else virtualHSV.h = color.h;
            }
            if (event.type === "pointermove" && [
                "left",
                "right"
            ].includes(event.button) && hPointerId === event.pointerId) {
                const deltaY = Math.abs(event.pageY - event.downPageY);
                const factor = (0, _sliderFalloff.calcSliderFalloffFactor)(deltaY, event.button === "right");
                virtualHSV.h += event.dX / params.width * 359.99 * factor;
                if (event.button === "right") {
                    virtualHSV.h = virtualHSV.h % 359.99;
                    if (virtualHSV.h < 0) virtualHSV.h += 359.99;
                }
                virtualHSV.h = Math.min(359.99, virtualHSV.h);
                color = new (0, _bb.BB).HSV(virtualHSV.h, color.s, color.v);
                updateSV();
                updateHPointer();
                params.callback((0, _bb.BB).ColorConverter.toRGB(color));
            }
            if (event.type === "pointerup") hPointerId = null;
        }
    });
    const cleardiv = document.createElement("div");
    cleardiv.style.clear = "both";
    div.appendChild(cleardiv);
    // --- interface ---
    this.setColor = function(c) {
        color = (0, _bb.BB).ColorConverter.toHSV(new (0, _bb.BB).RGB(c.r, c.g, c.b));
        updateSV();
        updateSVPointer();
        updateHPointer();
    };
    this.getColor = function() {
        return (0, _bb.BB).ColorConverter.toRGB(color);
    };
    this.getElement = function() {
        return div;
    };
    this.destroy = function() {
        svPointerListener.destroy();
        hPointerListener.destroy();
    };
    this.end = function() {
        svPointerId = null;
        hPointerId = null;
    };
};

},{"../../../bb/bb":"dcQKo","./slider-falloff":"e9Q7X","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gzw3V":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PointSlider", ()=>PointSlider);
var _bb = require("../../../bb/bb");
const PointSlider = function(param) {
    const div = document.createElement("div");
    div.style.position = "relative";
    const sliderLine = (0, _bb.BB).el({});
    const sliderPoint = (0, _bb.BB).el({
        css: {
            colorScheme: "only light"
        }
    });
    div.appendChild(sliderLine);
    div.appendChild(sliderPoint);
    let sliderPos;
    let isDragging = false;
    (0, _bb.BB).css(sliderLine, {
        marginTop: parseInt("" + (param.pointSize / 2 - 1)) + "px",
        height: "2px",
        background: "#aaa",
        width: param.width + "px"
    });
    //sliderPoint
    const touchAreaEl = (0, _bb.BB).el({
        parent: sliderPoint,
        css: {
            // background: 'rgba(255,0,0,0.4)',
            margin: "-7px 0 0 -7px",
            width: "calc(100% + 14px)",
            height: "calc(100% + 7px)"
        }
    });
    function redrawPoint() {
        sliderPoint.style.left = sliderPos + "px";
        if (isDragging) sliderPoint.style.boxShadow = "0 0 6px rgba(0,0,0,1)";
        else sliderPoint.style.boxShadow = "0 0 3px rgba(0,0,0,0.8)";
    }
    function getValue() {
        return sliderPos / (param.width - param.pointSize);
    }
    let pointerListener;
    {
        let isFirst;
        sliderPos = (0, _bb.BB).clamp(param.init * (param.width - param.pointSize), 0, param.width - param.pointSize);
        (0, _bb.BB).css(sliderPoint, {
            position: "absolute",
            top: "0px",
            backgroundColor: "#eaeaea",
            boxShadow: "0 0 3px rgba(0,0,0,0.8)",
            width: param.pointSize + "px",
            height: param.pointSize + "px",
            borderRadius: param.pointSize + "px",
            cursor: "ew-resize",
            transition: "box-shadow 0.2s ease-in-out"
        });
        redrawPoint();
        let imaginaryPos;
        pointerListener = new (0, _bb.BB).PointerListener({
            target: sliderPoint,
            fixScribble: true,
            onPointer: function(event) {
                if (event.type === "pointerdown" && event.button === "left") {
                    isFirst = true;
                    isDragging = true;
                    imaginaryPos = sliderPos;
                    redrawPoint();
                    event.eventStopPropagation();
                } else if (event.type === "pointermove" && event.button === "left") {
                    event.eventStopPropagation();
                    imaginaryPos = imaginaryPos + event.dX;
                    sliderPos = parseInt("" + (0, _bb.BB).clamp(imaginaryPos, 0, param.width - param.pointSize));
                    redrawPoint();
                    param.callback(getValue(), isFirst, false);
                    isFirst = false;
                }
                if (event.type === "pointerup") {
                    event.eventStopPropagation();
                    isDragging = false;
                    redrawPoint();
                    param.callback(getValue(), false, true);
                }
            }
        });
    }
    // --- interface ---
    this.getEl = function() {
        return div;
    };
    this.setActive = function(isActive) {
        if (isActive) sliderPoint.style.backgroundColor = "#fff";
        else sliderPoint.style.backgroundColor = "#eaeaea";
    };
    this.destroy = function() {
        pointerListener.destroy();
    };
};

},{"../../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e85vi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ColorOptions", ()=>ColorOptions);
var _bb = require("../../../bb/bb");
const ColorOptions = function(p) {
    const div = (0, _bb.BB).el({
        content: p.label ? p.label : "",
        css: {
            display: "flex",
            alignItems: "center",
            colorScheme: "only light"
        }
    });
    let selectedIndex = 0;
    const colorArr = [];
    const buttonArr = [];
    const buttonSize = 22;
    const checkerUrl = (0, _bb.BB).createCheckerDataUrl(5);
    // build colorArr while removing duplicates
    for(let i = 0; i < p.colorArr.length; i++){
        const item = p.colorArr[i];
        let found = false;
        for(let e = 0; e < colorArr.length; e++){
            const sItem = colorArr[e];
            if (sItem === null || item === null) continue;
            if (sItem.r === item.r && sItem.g === item.g && sItem.b === item.b && sItem.a === item.a) {
                found = true;
                break;
            }
        }
        if (found) continue;
        colorArr.push(item);
        if ("initialIndex" in p && p.initialIndex === i) selectedIndex = colorArr.length - 1;
    }
    for(let i1 = 0; i1 < colorArr.length; i1++)(function(i) {
        const colorButton = (0, _bb.BB).el({
            content: colorArr[i] ? "" : "X",
            css: {
                width: buttonSize + "px",
                height: buttonSize + "px",
                backgroundColor: colorArr[i] ? (0, _bb.BB).ColorConverter.toRgbaStr(colorArr[i]) : "transparent",
                marginLeft: "7px",
                boxShadow: "0 0 0 1px #aaa",
                cursor: "pointer",
                userSelect: "none",
                textAlign: "center",
                lineHeight: buttonSize + 1 + "px",
                color: "#aaa"
            }
        });
        if (colorArr[i] && colorArr[i].a === 0) colorButton.style.backgroundImage = "url(" + checkerUrl + ")";
        colorButton.onclick = function(e) {
            e.preventDefault();
            selectedIndex = i;
            update();
            p.onChange(colorArr[i]);
        };
        colorButton.setIsSelected = function(b) {
            if (b) (0, _bb.BB).css(colorButton, {
                boxShadow: "0 0 0 2px var(--active-highlight-color), 0 0 5px 0 var(--active-highlight-color)",
                pointerEvents: "none"
            });
            else (0, _bb.BB).css(colorButton, {
                boxShadow: "0 0 0 1px #aaa",
                pointerEvents: ""
            });
        };
        div.appendChild(colorButton);
        buttonArr.push(colorButton);
    })(i1);
    function update() {
        for(let i = 0; i < buttonArr.length; i++)buttonArr[i].setIsSelected(i === selectedIndex);
    }
    update();
    // --- interface ---
    this.getElement = function() {
        return div;
    };
    this.destroy = ()=>{
        buttonArr.forEach((item)=>{
            item.onclick = null;
        });
        buttonArr.splice(0, buttonArr.length);
    };
};

},{"../../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"huqRY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Options", ()=>Options);
var _bb = require("../../../bb/bb");
const Options = function(p) {
    const div = (0, _bb.BB).el({});
    const wrapperEl = (0, _bb.BB).el({
        parent: div,
        className: "kl-option-wrapper",
        css: {
            display: "flex"
        }
    });
    const optionArr = [];
    let selectedId = "initialId" in p ? p.initialId : p.optionArr[0].id;
    function createOption(o) {
        const optionObj = {
            id: o.id,
            el: null
        };
        const classArr = [
            "kl-option"
        ];
        if (p.isSmall) classArr.push("kl-option--small");
        if (typeof o.label !== "string") {
            classArr.push("kl-option--custom-el");
            (0, _bb.BB).css(o.label, {
                display: "block",
                pointerEvents: "none"
            });
        }
        optionObj.el = (0, _bb.BB).el({
            parent: wrapperEl,
            content: o.label,
            className: classArr.join(" "),
            onClick: function() {
                if (selectedId !== optionObj.id) {
                    selectedId = optionObj.id;
                    update();
                    p.onChange(selectedId);
                }
            }
        });
        if (o.title) optionObj.el.title = o.title;
        optionArr.push(optionObj);
    }
    function update() {
        for(let i = 0; i < optionArr.length; i++)optionArr[i].el.classList.toggle("kl-option-selected", optionArr[i].id === selectedId);
    }
    for(let i = 0; i < p.optionArr.length; i++)createOption(p.optionArr[i]);
    update();
    if (p.changeOnInit) setTimeout(function() {
        p.onChange(selectedId);
    }, 0);
    function getIndex() {
        for(let i = 0; i < optionArr.length; i++){
            if (optionArr[i].id === selectedId) return i;
        }
    }
    // --- interface ---
    this.getElement = function() {
        return div;
    };
    this.getValue = function() {
        return selectedId;
    };
    this.next = function() {
        selectedId = optionArr[(getIndex() + 1) % optionArr.length].id;
        update();
        p.onChange(selectedId);
    };
    this.previous = function() {
        selectedId = optionArr[(optionArr.length + getIndex() - 1) % optionArr.length].id;
        update();
        p.onChange(selectedId);
    };
    this.destroy = ()=>{
        optionArr.forEach((item)=>{
            (0, _bb.BB).destroyEl(item.el);
        });
        optionArr.splice(0, optionArr.length);
    };
};

},{"../../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ke842":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * display little messages at the top of KlWorkspace
 */ parcelHelpers.export(exports, "StatusOverlay", ()=>StatusOverlay);
var _bb = require("../../../bb/bb");
// @ts-ignore
var _angleSvg = require("url:~/src/app/img/ui/angle.svg");
var _angleSvgDefault = parcelHelpers.interopDefault(_angleSvg);
class StatusOverlay {
    updateUiState() {
        if (!this.el) return;
        setTimeout(()=>{}, 100);
        if (this.uiState === "left") this.el.style.left = "271px";
        else this.el.style.removeProperty("left");
    }
    init() {
        this.el = (0, _bb.BB).el({
            className: "top-overlay g-root",
            onClick: (0, _bb.BB).handleClick
        });
        if (this.isWide) this.el.style.width = "100%";
        this.updateUiState();
        this.innerEl = (0, _bb.BB).el({
            className: "top-overlay-inner"
        });
        this.angleIm = new Image();
        this.angleIm.src = (0, _angleSvgDefault.default);
        (0, _bb.BB).css(this.angleIm, {
            verticalAlign: "bottom",
            width: "20px",
            height: "20px",
            marginLeft: "5px",
            borderRadius: "10px"
        });
        this.innerInnerEl = document.createElement("div");
        this.innerInnerEl.style.display = "inline-block";
        this.innerEl.appendChild(this.innerInnerEl);
        this.innerEl.appendChild(this.angleIm);
        this.el.appendChild(this.innerEl);
        document.body.appendChild(this.el);
        this.el.style.display = "none";
    }
    // --- public ---
    constructor(){
        this.init();
    }
    setWide(b) {
        this.isWide = !!b;
        if (!this.el) return;
        if (this.isWide) {
            this.el.style.width = "100%";
            this.el.style.left = "";
        } else {
            this.el.style.removeProperty("width");
            this.el.style.left = this.uiState === "left" ? "271px" : "";
        }
    }
    setUiState(state) {
        this.uiState = state;
        this.updateUiState();
    }
    out(msg, doPulse) {
        if (msg && typeof msg === "object") {
            if (msg.type === "transform") {
                this.angleIm.style.display = "inline-block";
                this.angleIm.style.transform = "rotate(" + msg.angleDeg + "deg)";
                if (msg.angleDeg % 90 === 0) this.angleIm.style.boxShadow = "inset 0 0 0 1px rgba(255, 255, 255, 0.7)";
                else this.angleIm.style.boxShadow = "";
                this.innerInnerEl.innerHTML = Math.round(msg.scale * 100) + "%";
            } else this.angleIm.style.display = "none";
        } else if (typeof msg === "string") {
            this.angleIm.style.display = "none";
            this.innerInnerEl.innerHTML = msg;
        }
        if (doPulse) {
            this.innerEl.style.animation = "";
            setTimeout(()=>this.innerEl.style.animation = "top-overlay-pulse 0.5s ease-out", 20);
            if (this.timeout3) clearTimeout(this.timeout3);
            this.timeout3 = window.setTimeout(()=>this.innerEl.style.animation = "", 520);
        }
        if (this.timeout) clearTimeout(this.timeout);
        if (this.timeout2) clearTimeout(this.timeout2);
        this.el.style.animationName = doPulse ? "consoleInFast" : "consoleIn";
        this.el.style.opacity = "1";
        this.timeout = window.setTimeout(()=>{
            this.el.style.opacity = "0";
            this.el.style.animationName = "consoleOut";
            this.timeout2 = window.setTimeout(()=>{
                this.el.style.display = "none";
                this.timeout2 = 0;
            }, 450);
            this.timeout = 0;
        }, 1200);
        this.el.style.display = "flex";
    }
}

},{"../../../bb/bb":"dcQKo","url:~/src/app/img/ui/angle.svg":"hgcfy","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hgcfy":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "angle.aba27c2c.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"iNIjl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "exportDialog", ()=>exportDialog);
var _bb = require("../../../bb/bb");
var _popup = require("./popup");
function exportDialog(parent, image) {
    let boxSize, aboutCloseFunc, aboutDiv, closed, aniToggle, imageContainer, coverImage, coverSize, text, holding, aniTimeout, halfBoxSize;
    boxSize = 44;
    halfBoxSize = 22;
    aboutCloseFunc = function() {};
    closed = false;
    aniToggle = false;
    aboutDiv = document.createElement("div");
    (0, _bb.BB).css(aboutDiv, {
        width: 7 * boxSize + "px"
    });
    imageContainer = document.createElement("div");
    coverImage = new Image();
    coverImage.src = image.src;
    imageContainer.appendChild(coverImage);
    imageContainer.appendChild(image);
    (0, _bb.BB).css(imageContainer, {
        width: 6 * boxSize + "px",
        height: 4 * boxSize + "px",
        marginTop: boxSize / 2 - 1 + "px",
        marginLeft: boxSize / 2 - 1 + "px",
        position: "relative",
        overflow: "hidden",
        boxShadow: "0 0 10px 4px rgba(255,255,255, 0)",
        border: "1px solid rgba(255, 255, 255, 1)",
        transition: "box-shadow 0.7s linear"
    });
    (0, _bb.BB).css(image, {
        position: "absolute",
        left: "0",
        top: "0",
        width: 6 * boxSize + "px",
        height: 4 * boxSize + "px",
        opacity: "0"
    });
    coverSize = {
        width: 6 * boxSize,
        height: 6 * boxSize / image.width * image.height
    };
    if (coverSize.height < 4 * boxSize) {
        coverSize.height = 4 * boxSize;
        coverSize.width = coverSize.height / image.height * image.width;
    }
    (0, _bb.BB).css(coverImage, {
        position: "absolute",
        top: 2 * boxSize + "px",
        left: 3 * boxSize + "px",
        width: coverSize.width + "px",
        height: coverSize.height + "px",
        marginLeft: -coverSize.width / 2 + "px",
        marginTop: -coverSize.height / 2 + "px"
    });
    function animation() {
        if (closed) return;
        aniToggle = !aniToggle;
        if (aniToggle) (0, _bb.BB).css(imageContainer, {
            border: "1px solid rgba(0, 0, 0, 1)"
        });
        else (0, _bb.BB).css(imageContainer, {
            border: "1px solid rgba(200, 200, 200, 1)"
        });
        setTimeout(animation, 510);
    }
    animation();
    text = document.createElement("div");
    text.innerHTML = "Right-Click or Press-Hold on the image, then save.";
    text.ontouchstart = function() {
        return false;
    };
    (0, _bb.BB).css(text, {
        fontSize: boxSize / 2.5 + "px",
        color: "#666",
        padding: "10px",
        textAlign: "center"
    });
    aboutDiv.appendChild(imageContainer);
    aboutDiv.appendChild(text);
    holding = false;
    image.ontouchstart = function() {
        (0, _bb.BB).css(imageContainer, {
            boxShadow: "0 0 10px 8px rgba(0,255,255, 1)"
        });
        holding = true;
        aniTimeout = setTimeout(function() {
            holding = false;
            (0, _bb.BB).css(imageContainer, {
                boxShadow: "0 0 10px 4px rgba(0,255,255, 0)"
            });
        }, 1500);
    };
    image.ontouchmove = function() {
        (0, _bb.BB).css(imageContainer, {
            boxShadow: "0 0 10px 4px rgba(0,255,255, 0)"
        });
        holding = false;
        clearTimeout(aniTimeout);
    };
    image.ontouchend = function() {
        (0, _bb.BB).css(imageContainer, {
            boxShadow: "0 0 10px 4px rgba(0,255,255, 0)"
        });
        holding = false;
        clearTimeout(aniTimeout);
    };
    (0, _popup.popup)({
        target: parent,
        message: "<b>Save Image</b>",
        div: aboutDiv,
        buttons: [
            "Close"
        ],
        callback: function(result) {
            closed = true;
        }
    });
}

},{"../../../bb/bb":"dcQKo","./popup":"4Ltiz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aTBXS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * element that lets you crop an image and copy it via right click
 *
 * param = {
 *     width: number,
 *     height: number,
 *     canvas: image | canvas,
 *     isNotCopy: boolean,
 *     onChange: function(width, height)
 * }
 *
 * @param param object
 * @constructor
 */ parcelHelpers.export(exports, "CropCopy", ()=>CropCopy);
var _bb = require("../../../bb/bb");
function CropCopy(param) {
    const div = document.createElement("div");
    (0, _bb.BB).css(div, {
        position: "relative",
        height: param.height + "px",
        width: param.width + "px",
        overflow: "hidden",
        colorScheme: "only light"
    });
    div.style.position = "relative";
    let crop;
    function resetCrop() {
        crop = {
            x: 0,
            y: 0,
            width: param.canvas.width,
            height: param.canvas.height
        };
    }
    resetCrop();
    function updateCroppedCanvas() {
        croppedCanvas.width = Math.round(crop.width);
        croppedCanvas.height = Math.round(crop.height);
        let ctx = croppedCanvas.getContext("2d");
        ctx.drawImage(param.canvas, Math.round(-crop.x), Math.round(-crop.y));
        if (croppedImage) croppedImage.src = croppedCanvas.toDataURL("image/png");
        if (param.onChange) param.onChange(croppedCanvas.width, croppedCanvas.height);
    }
    function updateSelectionRect() {
        (0, _bb.BB).css(selectionRect, {
            left: thumbX + crop.x * scaleW + "px",
            top: thumbY + crop.y * scaleH + "px",
            width: crop.width * scaleW + "px",
            height: crop.height * scaleH + "px"
        });
        if (param.onChange) param.onChange(Math.round(crop.width), Math.round(crop.height));
    }
    function isInsideSelectionRect(p) {
        let rect = {
            x: Math.round(thumbX + crop.x * scaleW),
            y: Math.round(thumbY + crop.y * scaleH),
            width: Math.round(crop.width * scaleW),
            height: Math.round(crop.height * scaleH)
        };
        return (0, _bb.BB).isInsideRect(p, rect);
    }
    const croppedCanvas = (0, _bb.BB).canvas();
    let eventTarget = croppedCanvas;
    let croppedImage = null;
    if (!param.isNotCopy) {
        croppedImage = new Image();
        eventTarget = croppedImage;
    }
    (0, _bb.BB).css(eventTarget, {
        height: param.height + "px",
        width: param.width + "px"
    });
    div.appendChild(eventTarget);
    updateCroppedCanvas();
    const padding = 20;
    const previewWrapper = (0, _bb.BB).el({
        css: {
            width: param.width + "px",
            height: param.height + "px",
            position: "absolute",
            left: "0",
            top: "0",
            pointerEvents: "none"
        }
    });
    div.appendChild(previewWrapper);
    (0, _bb.BB).createCheckerDataUrl(4, function(v) {
        previewWrapper.style.backgroundImage = "url(" + v + ")";
    });
    const thumbSize = (0, _bb.BB).fitInto(param.canvas.width, param.canvas.height, param.width - padding * 2, param.height - padding * 2, 1);
    const thumbCanvas = (0, _bb.BB).canvas(Math.round(thumbSize.width), Math.round(thumbSize.height));
    thumbCanvas.style.imageRendering = "pixelated";
    const scaleW = thumbCanvas.width / param.canvas.width;
    const scaleH = thumbCanvas.height / param.canvas.height;
    const thumbCtx = thumbCanvas.getContext("2d");
    thumbCtx.imageSmoothingEnabled = false;
    thumbCtx.drawImage(param.canvas, 0, 0, thumbCanvas.width, thumbCanvas.height);
    previewWrapper.appendChild(thumbCanvas);
    const thumbX = parseInt("" + (param.width - thumbCanvas.width) / 2);
    const thumbY = parseInt("" + (param.height - thumbCanvas.height) / 2);
    (0, _bb.BB).css(thumbCanvas, {
        position: "absolute",
        left: thumbX + "px",
        top: thumbY + "px"
    });
    const selectionRect = (0, _bb.BB).el({
        css: {
            position: "absolute",
            boxShadow: "0 0 0 1px #fff, 0 0 0 2px #000, 0 0 40px 1px #000"
        }
    });
    previewWrapper.appendChild(selectionRect);
    updateSelectionRect();
    function toOriginalSpace(p) {
        return {
            x: (0, _bb.BB).clamp((p.x - thumbX) / scaleW, 0, param.canvas.width),
            y: (0, _bb.BB).clamp((p.y - thumbY) / scaleH, 0, param.canvas.height)
        };
    }
    //gen crop from thumb-space points
    function genCrop(p1, p2) {
        let topLeftP = {
            x: Math.min(p1.x, p2.x),
            y: Math.min(p1.y, p2.y)
        };
        let bottomRightP = {
            x: Math.max(p1.x, p2.x),
            y: Math.max(p1.y, p2.y)
        };
        let origTopLeftP = toOriginalSpace(topLeftP);
        let origBottomRightP = toOriginalSpace(bottomRightP);
        origTopLeftP.x = Math.floor(origTopLeftP.x);
        origTopLeftP.y = Math.floor(origTopLeftP.y);
        origBottomRightP.x = Math.ceil(origBottomRightP.x);
        origBottomRightP.y = Math.ceil(origBottomRightP.y);
        return {
            x: origTopLeftP.x,
            y: origTopLeftP.y,
            width: origBottomRightP.x - origTopLeftP.x,
            height: origBottomRightP.y - origTopLeftP.y
        };
    }
    function isReset() {
        return crop.x === 0 && crop.y === 0 && crop.width === param.canvas.width && crop.height === param.canvas.height;
    }
    let startP;
    let startCrop = null;
    let isDragging = false;
    let didMove = false;
    let updateCropTimeout;
    const pointerListener = new (0, _bb.BB).PointerListener({
        target: eventTarget,
        fixScribble: true,
        onPointer: function(event) {
            let fullPos;
            if (event.type === "pointerdown" && event.button === "left") {
                event.eventPreventDefault();
                isDragging = true;
                startP = {
                    x: event.relX,
                    y: event.relY
                };
                if (!isReset() && isInsideSelectionRect(startP)) startCrop = {
                    x: crop.x,
                    y: crop.y,
                    width: crop.width,
                    height: crop.height
                };
                else crop = genCrop(startP, startP);
            } else if (event.type === "pointermove" && event.button === "left") {
                event.eventPreventDefault();
                didMove = true;
                if (startCrop) {
                    crop.x = startCrop.x + Math.round((event.relX - startP.x) / scaleW);
                    crop.y = startCrop.y + Math.round((event.relY - startP.y) / scaleH);
                    crop.x = (0, _bb.BB).clamp(crop.x, 0, param.canvas.width - crop.width);
                    crop.y = (0, _bb.BB).clamp(crop.y, 0, param.canvas.height - crop.height);
                } else crop = genCrop(startP, {
                    x: event.relX,
                    y: event.relY
                });
                updateSelectionRect();
            } else if (event.type === "pointerup" && startP) {
                event.eventPreventDefault();
                isDragging = false;
                startCrop = null;
                startP = null;
                if (crop.width === 0 || crop.height === 0 || !didMove) {
                    resetCrop();
                    updateSelectionRect();
                }
                didMove = false;
                updateCropTimeout = setTimeout(updateCroppedCanvas, 1);
            }
        }
    });
    const keyListener = new (0, _bb.BB).KeyListener({
        onDown: function(keyStr, e, comboStr) {
            if (isDragging) return;
            let doUpdate = false;
            let stepSize = Math.max(1, 1 / scaleW);
            let shiftIsPressed = keyListener.isPressed("shift");
            if (keyStr === "left") {
                if (shiftIsPressed) crop.width = (0, _bb.BB).clamp(crop.width - stepSize, 1, param.canvas.width - crop.x);
                else crop.x = (0, _bb.BB).clamp(crop.x - stepSize, 0, param.canvas.width - crop.width);
                doUpdate = true;
            }
            if (keyStr === "right") {
                if (shiftIsPressed) crop.width = (0, _bb.BB).clamp(crop.width + stepSize, 1, param.canvas.width - crop.x);
                else crop.x = (0, _bb.BB).clamp(crop.x + stepSize, 0, param.canvas.width - crop.width);
                doUpdate = true;
            }
            if (keyStr === "up") {
                if (shiftIsPressed) crop.height = (0, _bb.BB).clamp(crop.height - stepSize, 1, param.canvas.height - crop.y);
                else crop.y = (0, _bb.BB).clamp(crop.y - stepSize, 0, param.canvas.height - crop.height);
                doUpdate = true;
            }
            if (keyStr === "down") {
                if (shiftIsPressed) crop.height = (0, _bb.BB).clamp(crop.height + stepSize, 1, param.canvas.height - crop.y);
                else crop.y = (0, _bb.BB).clamp(crop.y + stepSize, 0, param.canvas.height - crop.height);
                doUpdate = true;
            }
            if (doUpdate) {
                e.preventDefault();
                updateSelectionRect();
                clearTimeout(updateCropTimeout);
                updateCropTimeout = setTimeout(updateCroppedCanvas, 100);
            }
        }
    });
    this.getEl = function() {
        return div;
    };
    this.reset = function() {
        resetCrop();
        updateCroppedCanvas();
        updateSelectionRect();
    };
    this.destroy = function() {
        eventTarget.style.removeProperty("width");
        eventTarget.style.removeProperty("height");
        keyListener.destroy();
        pointerListener.destroy();
    };
    this.isReset = function() {
        return isReset();
    };
    this.getRect = function() {
        return JSON.parse(JSON.stringify(crop));
    };
    this.getCroppedImage = function() {
        return croppedCanvas;
    };
}

},{"../../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9W8Vp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/// <reference path="./types.d.ts" />
/**
 *
 * @param parent
 * @param fullCanvas
 * @param cropCallback
 * @param output - BB.Output
 * @param showCrop - boolean - show crop button
 */ parcelHelpers.export(exports, "clipboardDialog", ()=>clipboardDialog);
var _bb = require("../../../bb/bb");
var _popup = require("./popup");
var _cropCopy = require("../components/crop-copy");
var _language = require("../../../language/language");
function clipboardDialog(parent, fullCanvas, cropCallback, output, showCrop) {
    let clipboardItemIsSupported = false;
    try {
        clipboardItemIsSupported = !!ClipboardItem;
    } catch (e) {}
    const div = document.createElement("div");
    const isSmall = window.innerWidth < 550 || window.innerHeight < 550;
    let topWrapper = (0, _bb.BB).el({
        content: (0, _language.LANG)("crop-drag-to-crop") + (clipboardItemIsSupported ? "" : "<br>" + (0, _language.LANG)("cropcopy-click-hold")),
        css: {
            textAlign: "center"
        }
    });
    div.appendChild(topWrapper);
    let cropCopy = new (0, _cropCopy.CropCopy)({
        width: isSmall ? 340 : 540,
        height: isSmall ? 300 : 350,
        canvas: fullCanvas,
        clipboardItemIsSupported
    });
    (0, _bb.BB).css(cropCopy.getEl(), {
        marginTop: "10px",
        marginLeft: "-20px",
        borderTop: "1px solid #bbb",
        borderBottom: "1px solid #bbb"
    });
    div.appendChild(cropCopy.getEl());
    function toClipboard() {
        const imgURL = cropCopy.getCroppedImage().toDataURL("image/png");
        setTimeout(async function() {
            try {
                const data = await fetch(imgURL);
                const blob = await data.blob();
                await navigator.clipboard.write([
                    new ClipboardItem({
                        [blob.type]: blob
                    }) // todo check is possible?
                ]);
                setTimeout(function() {
                    output.out((0, _language.LANG)("cropcopy-copied"), true);
                }, 200);
            } catch (err) {
                console.error(err.name, err.message);
            }
        }, 0);
    }
    let keyListener = new (0, _bb.BB).KeyListener({
        onDown: function(keyStr, KeyEvent, comboStr) {
            if (comboStr === "ctrl+c") {
                toClipboard();
                closefunc();
            }
        }
    });
    let closefunc;
    function blur() {
        closefunc();
    }
    (0, _bb.BB).addEventListener(window, "blur", blur);
    const buttonArr = [];
    if (clipboardItemIsSupported) buttonArr.push((0, _language.LANG)("cropcopy-btn-copy"));
    if (showCrop) buttonArr.push((0, _language.LANG)("cropcopy-btn-crop"));
    buttonArr.push("Cancel");
    (0, _popup.popup)({
        target: parent,
        message: "<b>" + (showCrop ? `${(0, _language.LANG)("cropcopy-title-copy")} / ${(0, _language.LANG)("cropcopy-title-crop")}` : `${(0, _language.LANG)("cropcopy-title-copy")}`) + "</b>",
        div: div,
        style: isSmall ? {} : {
            width: "500px"
        },
        buttons: buttonArr,
        primaries: [
            (0, _language.LANG)("cropcopy-btn-copy")
        ],
        callback: function(result) {
            if (result === (0, _language.LANG)("cropcopy-btn-copy")) toClipboard();
            else if (result === (0, _language.LANG)("cropcopy-btn-crop")) {
                let rectObj = cropCopy.getRect();
                cropCallback({
                    left: Math.round(-rectObj.x),
                    right: Math.round(rectObj.x + rectObj.width - fullCanvas.width),
                    top: Math.round(-rectObj.y),
                    bottom: Math.round(rectObj.y + rectObj.height - fullCanvas.height)
                });
            }
            (0, _bb.BB).removeEventListener(window, "blur", blur);
            cropCopy.destroy();
            keyListener.destroy();
        },
        clickOnEnter: (0, _language.LANG)("cropcopy-btn-copy"),
        closefunc: function(func) {
            closefunc = func;
        }
    });
}

},{"../../../bb/bb":"dcQKo","./popup":"4Ltiz","../components/crop-copy":"aTBXS","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"luXyU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "klLayerManager", ()=>klLayerManager);
var _bb = require("../../../bb/bb");
var _popup = require("../modals/popup");
var _klHistory = require("../../history/kl-history");
var _options = require("../base-components/options");
var _select = require("../base-components/select");
var _pointSlider = require("../base-components/point-slider");
// @ts-ignore
var _addLayerSvg = require("url:~/src/app/img/ui/add-layer.svg");
var _addLayerSvgDefault = parcelHelpers.interopDefault(_addLayerSvg);
// @ts-ignore
var _duplicateLayerSvg = require("url:~/src/app/img/ui/duplicate-layer.svg");
var _duplicateLayerSvgDefault = parcelHelpers.interopDefault(_duplicateLayerSvg);
// @ts-ignore
var _mergeLayersSvg = require("url:~/src/app/img/ui/merge-layers.svg");
var _mergeLayersSvgDefault = parcelHelpers.interopDefault(_mergeLayersSvg);
// @ts-ignore
var _removeLayerSvg = require("url:~/src/app/img/ui/remove-layer.svg");
var _removeLayerSvgDefault = parcelHelpers.interopDefault(_removeLayerSvg);
// @ts-ignore
var _renameLayerSvg = require("url:~/src/app/img/ui/rename-layer.svg");
var _renameLayerSvgDefault = parcelHelpers.interopDefault(_renameLayerSvg);
var _klCanvas = require("../../canvas/kl-canvas");
var _language = require("../../../language/language");
var _translateBlending = require("../../canvas/translate-blending");
function klLayerManager(p_canvas, p_func, p_rootDiv) {
    let klCanvas = p_canvas;
    let layerElArr = [];
    let layerHeight = 35;
    let layerSpacing = 0;
    let width = 250;
    let oldHistoryState;
    let updatefunc = p_func;
    let uiState = "right"; // 'left | 'right'
    let largeThumbDiv = (0, _bb.BB).el({
        onClick: (0, _bb.BB).handleClick,
        css: {
            position: "absolute",
            right: "280px",
            top: "500px",
            background: "#aaa",
            boxShadow: "1px 1px 3px rgba(0,0,0,0.3)",
            pointerEvents: "none",
            padding: "0",
            border: "1px solid #aaa",
            transition: "opacity 0.3s ease-out",
            userSelect: "none",
            colorScheme: "only light"
        }
    });
    (0, _bb.BB).createCheckerDataUrl(4, function(url) {
        largeThumbDiv.style.backgroundImage = "url(" + url + ")";
    });
    let largeThumbCanvas = (0, _bb.BB).canvas(200, 200);
    largeThumbCanvas.style.display = "block";
    largeThumbDiv.appendChild(largeThumbCanvas);
    let largeThumbTimeout, largeThumbInTimeout;
    let largeThumbInDocument = false;
    let klCanvasLayerArr = klCanvas.getLayers();
    let selectedSpotIndex = klCanvasLayerArr.length - 1;
    let div = document.createElement("div");
    div.style.marginRight = "10px";
    div.style.marginBottom = "10px";
    div.style.marginLeft = "10px";
    div.style.marginTop = "10px";
    div.style.cursor = "default";
    let listdiv = document.createElement("div");
    (0, _bb.BB).css(listdiv, {
        width: width + "px",
        position: "relative"
    });
    function renameLayer(layer) {
        let div = document.createElement("div");
        let label = (0, _bb.BB).el({
            content: (0, _language.LANG)("layers-rename-name") + ":",
            css: {
                marginRight: "5px"
            }
        });
        const row = (0, _bb.BB).el({
            css: {
                display: "flex"
            }
        });
        let input = document.createElement("input");
        input.value = klCanvas.getLayer(layer).name;
        input.setAttribute("data-ignore-focus", "true");
        const clearBtn = (0, _bb.BB).el({
            tagName: "Button",
            content: '<img src="' + (0, _removeLayerSvgDefault.default) + '" height="20"/>',
            title: (0, _language.LANG)("layers-rename-clear"),
            css: {
                marginLeft: "10px"
            },
            onClick: ()=>{
                input.value = "";
                input.focus();
            }
        });
        const suggestions = [
            (0, _language.LANG)("layers-rename-sketch"),
            (0, _language.LANG)("layers-rename-colors"),
            (0, _language.LANG)("layers-rename-shading"),
            (0, _language.LANG)("layers-rename-lines"),
            (0, _language.LANG)("layers-rename-effects"),
            (0, _language.LANG)("background"),
            (0, _language.LANG)("layers-rename-foreground"), 
        ];
        const suggestionBtns = [];
        const row2 = (0, _bb.BB).el({
            css: {
                display: "flex",
                flexWrap: "wrap",
                marginTop: "5px",
                marginLeft: "-5px"
            }
        });
        suggestions.forEach((item)=>{
            const btn = (0, _bb.BB).el({
                parent: row2,
                tagName: "Button",
                content: item,
                onClick: ()=>{
                    input.value = btn.textContent;
                },
                css: {
                    margin: "5px 0 0 5px"
                }
            });
            suggestionBtns.push(btn);
        });
        div.appendChild(label);
        label.append(row, row2);
        row.append(input, clearBtn);
        setTimeout(function() {
            input.focus();
            input.select();
        }, 10);
        (0, _popup.popup)({
            target: p_rootDiv,
            message: `<b>${(0, _language.LANG)("layers-rename-title")}</b>`,
            div: div,
            buttons: [
                (0, _language.LANG)("layers-rename"),
                "Cancel"
            ],
            primaries: [
                (0, _language.LANG)("layers-rename")
            ],
            callback: function(val) {
                (0, _bb.BB).destroyEl(clearBtn);
                suggestionBtns.forEach((item)=>{
                    (0, _bb.BB).destroyEl(item);
                });
                suggestionBtns.splice(0, suggestionBtns.length);
                if (val === (0, _language.LANG)("layers-rename")) {
                    if (input.value === klCanvas.getLayer(layer).name) return;
                    klCanvas.renameLayer(layer, input.value);
                    createLayerList();
                    (0, _klHistory.klHistory).pause(true);
                    updatefunc(layer);
                    (0, _klHistory.klHistory).pause(false);
                }
            },
            clickOnEnter: (0, _language.LANG)("layers-rename")
        });
    }
    let layerListEl = (0, _bb.BB).el({});
    div.disableButtons = function() {}; //probably remove
    div.enableButtons = function() {}; //probably remove
    let addnewBtn = document.createElement("button");
    let duplicateBtn = document.createElement("button");
    let mergeBtn = document.createElement("button");
    let removeBtn = document.createElement("button");
    let renameBtn = document.createElement("button");
    function createButtons() {
        let div = document.createElement("div");
        function async() {
            (0, _bb.BB).makeUnfocusable(addnewBtn);
            (0, _bb.BB).makeUnfocusable(duplicateBtn);
            (0, _bb.BB).makeUnfocusable(mergeBtn);
            (0, _bb.BB).makeUnfocusable(removeBtn);
            (0, _bb.BB).makeUnfocusable(renameBtn);
            addnewBtn.style.cssFloat = "left";
            duplicateBtn.style.cssFloat = "left";
            mergeBtn.style.cssFloat = "left";
            removeBtn.style.cssFloat = "left";
            renameBtn.style.cssFloat = "left";
            addnewBtn.title = (0, _language.LANG)("layers-new");
            duplicateBtn.title = (0, _language.LANG)("layers-duplicate");
            removeBtn.title = (0, _language.LANG)("layers-remove");
            mergeBtn.title = (0, _language.LANG)("layers-merge");
            renameBtn.title = (0, _language.LANG)("layers-rename-title");
            addnewBtn.style.paddingLeft = "5px";
            addnewBtn.style.paddingRight = "3px";
            removeBtn.style.paddingLeft = "5px";
            removeBtn.style.paddingRight = "3px";
            duplicateBtn.style.paddingLeft = "5px";
            duplicateBtn.style.paddingRight = "3px";
            mergeBtn.style.paddingLeft = "5px";
            mergeBtn.style.paddingRight = "3px";
            renameBtn.style.height = "30px";
            renameBtn.style.lineHeight = "20px";
            addnewBtn.innerHTML = "<img src='" + (0, _addLayerSvgDefault.default) + "' height='20'/>";
            duplicateBtn.innerHTML = "<img src='" + (0, _duplicateLayerSvgDefault.default) + "' height='20'/>";
            mergeBtn.innerHTML = "<img src='" + (0, _mergeLayersSvgDefault.default) + "' height='20'/>";
            removeBtn.innerHTML = "<img src='" + (0, _removeLayerSvgDefault.default) + "' height='20'/>";
            renameBtn.innerHTML = "<img src='" + (0, _renameLayerSvgDefault.default) + "' height='20'/>";
            addnewBtn.style.marginRight = "5px";
            removeBtn.style.marginRight = "5px";
            duplicateBtn.style.marginRight = "5px";
            mergeBtn.style.marginRight = "5px";
            div.appendChild(addnewBtn);
            div.appendChild(removeBtn);
            div.appendChild(duplicateBtn);
            div.appendChild(mergeBtn);
            div.appendChild(renameBtn);
            div.appendChild((0, _bb.BB).el({
                css: {
                    clear: "both"
                }
            }));
            let clearboth = document.createElement("div");
            clearboth.style.clear = "both";
            clearboth.style.height = "10px";
            div.appendChild(clearboth);
            addnewBtn.onclick = function() {
                if (klCanvas.addLayer(selectedSpotIndex) === false) return;
                klCanvasLayerArr = klCanvas.getLayers();
                if (klCanvasLayerArr.length === (0, _klCanvas.MAX_LAYERS)) {
                    addnewBtn.disabled = true;
                    duplicateBtn.disabled = true;
                }
                removeBtn.disabled = false;
                selectedSpotIndex = selectedSpotIndex + 1;
                createLayerList();
                (0, _klHistory.klHistory).pause(true);
                updatefunc(selectedSpotIndex);
                (0, _klHistory.klHistory).pause(false);
            };
            duplicateBtn.onclick = function() {
                if (klCanvas.duplicateLayer(selectedSpotIndex) === false) return;
                klCanvasLayerArr = klCanvas.getLayers();
                if (klCanvasLayerArr.length === (0, _klCanvas.MAX_LAYERS)) {
                    addnewBtn.disabled = true;
                    duplicateBtn.disabled = true;
                }
                removeBtn.disabled = false;
                selectedSpotIndex++;
                createLayerList();
                (0, _klHistory.klHistory).pause(true);
                updatefunc(selectedSpotIndex);
                (0, _klHistory.klHistory).pause(false);
            };
            removeBtn.onclick = function() {
                if (layerElArr.length <= 1) return;
                klCanvas.removeLayer(selectedSpotIndex);
                if (selectedSpotIndex > 0) selectedSpotIndex--;
                klCanvasLayerArr = klCanvas.getLayers();
                createLayerList();
                (0, _klHistory.klHistory).pause(true);
                updatefunc(selectedSpotIndex);
                (0, _klHistory.klHistory).pause(false);
                if (klCanvasLayerArr.length === 1) removeBtn.disabled = true;
                if (klCanvasLayerArr.length < (0, _klCanvas.MAX_LAYERS)) {
                    addnewBtn.disabled = false;
                    duplicateBtn.disabled = false;
                }
            };
            mergeBtn.onclick = function() {
                if (selectedSpotIndex <= 0) return;
                function mergeDialog(p) {
                    let div = document.createElement("div");
                    div.innerHTML = (0, _language.LANG)("layers-merge-description");
                    let options = new (0, _options.Options)({
                        optionArr: [
                            {
                                id: p.mixModeStr,
                                label: (0, _translateBlending.translateBlending)(p.mixModeStr)
                            },
                            {
                                id: "source-in",
                                label: "source-in"
                            },
                            {
                                id: "source-out",
                                label: "source-out"
                            },
                            {
                                id: "source-atop",
                                label: "source-atop"
                            },
                            {
                                id: "destination-in",
                                label: "destination-in"
                            },
                            {
                                id: "destination-out",
                                label: "destination-out"
                            },
                            {
                                id: "destination-atop",
                                label: "destination-atop"
                            },
                            {
                                id: "xor",
                                label: "xor"
                            }
                        ],
                        initId: p.mixModeStr,
                        onChange: function(id) {
                            update();
                        },
                        isSmall: true
                    });
                    options.getElement().style.marginTop = "5px";
                    div.appendChild(options.getElement());
                    const thumbDimensions = (0, _bb.BB).fitInto(p.topCanvas.width, p.topCanvas.height, 200, 200, 1);
                    let preview = (0, _bb.BB).canvas(thumbDimensions.width, thumbDimensions.height);
                    preview.title = (0, _language.LANG)("preview");
                    let spacer = document.createElement("div");
                    spacer.innerHTML = "<br/>";
                    spacer.style.clear = "both";
                    div.appendChild(spacer);
                    div.appendChild(preview);
                    (0, _bb.BB).css(preview, {
                        display: "block",
                        marginLeft: "auto",
                        marginRight: "auto",
                        colorScheme: "only light"
                    });
                    preview.style.boxShadow = "0 0 3px rgba(0,0,0,0.5)";
                    (0, _bb.BB).createCheckerDataUrl(4, function(url) {
                        preview.style.backgroundImage = "url(" + url + ")";
                    });
                    let alphaCanvas = (0, _bb.BB).copyCanvas(preview);
                    alphaCanvas.getContext("2d").drawImage(p.topCanvas, 0, 0, alphaCanvas.width, alphaCanvas.height);
                    (0, _bb.BB).convertToAlphaChannelCanvas(alphaCanvas);
                    function update() {
                        let ctx = preview.getContext("2d");
                        ctx.save();
                        ctx.clearRect(0, 0, preview.width, preview.height);
                        if (preview.width > p.topCanvas.width) ctx.imageSmoothingEnabled = false;
                        ctx.drawImage(p.bottomCanvas, 0, 0, preview.width, preview.height);
                        if (options.getValue() === "as-alpha") {
                            ctx.globalCompositeOperation = "destination-in";
                            ctx.globalAlpha = p.topOpacity;
                            ctx.drawImage(alphaCanvas, 0, 0, preview.width, preview.height);
                        } else {
                            ctx.globalCompositeOperation = options.getValue();
                            ctx.globalAlpha = p.topOpacity;
                            ctx.drawImage(p.topCanvas, 0, 0, preview.width, preview.height);
                        }
                        ctx.restore();
                    }
                    update();
                    let keyListener = new (0, _bb.BB).KeyListener({
                        onDown: function(keyStr) {
                            if (keyStr === "right") options.next();
                            if (keyStr === "left") options.previous();
                        }
                    });
                    (0, _popup.popup)({
                        target: p_rootDiv,
                        message: `<b>${(0, _language.LANG)("layers-merge-modal-title")}</b>`,
                        div: div,
                        buttons: [
                            "Ok",
                            "Cancel"
                        ],
                        clickOnEnter: "Ok",
                        callback: function(val) {
                            keyListener.destroy();
                            options.destroy();
                            if (val === "Ok") p.callback(options.getValue());
                        }
                    });
                }
                mergeDialog({
                    topCanvas: klCanvasLayerArr[selectedSpotIndex].context.canvas,
                    bottomCanvas: klCanvasLayerArr[selectedSpotIndex - 1].context.canvas,
                    topOpacity: klCanvas.getLayer(selectedSpotIndex).opacity,
                    mixModeStr: klCanvasLayerArr[selectedSpotIndex].mixModeStr,
                    callback: function(mode) {
                        klCanvas.mergeLayers(selectedSpotIndex, selectedSpotIndex - 1, mode);
                        klCanvasLayerArr = klCanvas.getLayers();
                        selectedSpotIndex--;
                        if (klCanvasLayerArr.length === 1) removeBtn.disabled = true;
                        if (klCanvasLayerArr.length < (0, _klCanvas.MAX_LAYERS)) {
                            addnewBtn.disabled = false;
                            duplicateBtn.disabled = false;
                        }
                        createLayerList();
                        (0, _klHistory.klHistory).pause(true);
                        updatefunc(selectedSpotIndex);
                        (0, _klHistory.klHistory).pause(false);
                    }
                });
            };
            renameBtn.onclick = function() {
                renameLayer(selectedSpotIndex);
            };
        }
        setTimeout(async, 1);
        return div;
    }
    div.appendChild(createButtons());
    let modeWrapper;
    let modeSelect;
    modeWrapper = (0, _bb.BB).el({
        content: (0, _language.LANG)("layers-blending") + "&nbsp;",
        css: {
            fontSize: "15px"
        }
    });
    modeSelect = new (0, _select.Select)({
        optionArr: [
            "source-over",
            null,
            "darken",
            "multiply",
            "color-burn",
            null,
            "lighten",
            "screen",
            "color-dodge",
            null,
            "overlay",
            "soft-light",
            "hard-light",
            null,
            "difference",
            "exclusion",
            null,
            "hue",
            "saturation",
            "color",
            "luminosity", 
        ].map((item)=>{
            return item ? [
                item,
                (0, _translateBlending.translateBlending)(item)
            ] : null;
        }),
        onChange: function(val) {
            klCanvas.setMixMode(selectedSpotIndex, val);
            div.update(selectedSpotIndex);
        },
        css: {
            marginBottom: "10px"
        }
    });
    modeWrapper.appendChild(modeSelect.getElement());
    div.appendChild(modeWrapper);
    function createLayerList() {
        oldHistoryState = (0, _klHistory.klHistory).getState();
        function createLayerEntry(index) {
            let layerName = klCanvas.getLayer(index).name;
            let opacity = klCanvasLayerArr[index].opacity;
            let layercanvas = klCanvasLayerArr[index].context.canvas;
            let layer = document.createElement("div");
            layer.className = "layerBox";
            layerElArr[index] = layer;
            layer.posY = (klCanvasLayerArr.length - 1) * 35 - index * 35;
            (0, _bb.BB).css(layer, {
                width: "250px",
                height: "34px",
                backgroundColor: "rgb( 220, 220, 220)",
                border: "1px solid #aaa",
                position: "absolute",
                left: "0 px",
                top: layer.posY + "px",
                transition: "all 0.1s linear",
                borderRadius: "5px",
                boxSizing: "border-box"
            });
            let innerLayer = document.createElement("div");
            (0, _bb.BB).css(innerLayer, {
                position: "relative"
            });
            let container1 = document.createElement("div");
            (0, _bb.BB).css(container1, {
                width: "250px",
                height: "34px"
            });
            let container2 = document.createElement("div");
            layer.appendChild(innerLayer);
            innerLayer.appendChild(container1);
            innerLayer.appendChild(container2);
            layer.spot = index;
            //thumb
            {
                let thumbDimensions = (0, _bb.BB).fitInto(layercanvas.width, layercanvas.height, 30, 30, 1);
                let thumb = layer.thumb = (0, _bb.BB).canvas(thumbDimensions.width, thumbDimensions.height);
                let thc = thumb.getContext("2d");
                thc.save();
                if (thumb.width > layercanvas.width) thc.imageSmoothingEnabled = false;
                thc.drawImage(layercanvas, 0, 0, thumb.width, thumb.height);
                thc.restore();
                (0, _bb.BB).css(layer.thumb, {
                    position: "absolute",
                    left: (32 - layer.thumb.width) / 2 + "px",
                    top: (32 - layer.thumb.height) / 2 + "px",
                    colorScheme: "only light"
                });
                (0, _bb.BB).createCheckerDataUrl(4, function(url) {
                    thumb.style.backgroundImage = "url(" + url + ")";
                });
            }
            layer.label = document.createElement("div");
            layer.lname = layerName;
            layer.label.append(layer.lname);
            (0, _bb.BB).css(layer.label, {
                position: "absolute",
                left: "38px",
                top: "1px",
                fontSize: "13px",
                width: "170px",
                height: "20px",
                overflow: "hidden",
                color: "#666",
                whiteSpace: "nowrap"
            });
            layer.label.ondblclick = function() {
                renameLayer(layer.spot);
            };
            layer.opacityLabel = document.createElement("div");
            layer.opacity = opacity;
            layer.opacityLabel.append(parseInt("" + layer.opacity * 100) + "%");
            (0, _bb.BB).css(layer.opacityLabel, {
                position: "absolute",
                left: "194px",
                top: "1px",
                fontSize: "13px",
                textAlign: "right",
                width: "50px",
                color: "#666",
                transition: "color 0.2s ease-in-out"
            });
            let oldOpacity;
            let opacitySlider = new (0, _pointSlider.PointSlider)({
                init: layer.opacity,
                width: 204,
                pointSize: 14,
                callback: function(sliderValue, isFirst, isLast) {
                    if (isFirst) {
                        oldOpacity = klCanvas.getLayer(layer.spot).opacity;
                        (0, _klHistory.klHistory).pause(true);
                        return;
                    }
                    if (isLast) {
                        (0, _klHistory.klHistory).pause(false);
                        if (oldOpacity !== sliderValue) klCanvas.layerOpacity(layer.spot, sliderValue);
                        return;
                    }
                    layer.opacityLabel.innerHTML = Math.round(sliderValue * 100) + "%";
                    klCanvas.layerOpacity(layer.spot, sliderValue);
                }
            });
            (0, _bb.BB).css(opacitySlider.getEl(), {
                position: "absolute",
                left: "39px",
                top: "17px"
            });
            layer.opacitySlider = opacitySlider;
            //larger layer preview - hover
            (0, _bb.BB).setEventListener(layer.thumb, "onpointerover", function(e) {
                if (e.buttons !== 0 && (!e.pointerType || e.pointerType !== "touch")) return;
                let thumbDimensions = (0, _bb.BB).fitInto(layercanvas.width, layercanvas.height, 250, 250, 1);
                if (largeThumbCanvas.width !== thumbDimensions.width || largeThumbCanvas.height !== thumbDimensions.height) {
                    largeThumbCanvas.width = thumbDimensions.width;
                    largeThumbCanvas.height = thumbDimensions.height;
                }
                let ctx = largeThumbCanvas.getContext("2d");
                ctx.save();
                if (largeThumbCanvas.width > layercanvas.width) ctx.imageSmoothingEnabled = false;
                ctx.imageSmoothingQuality = "high";
                ctx.clearRect(0, 0, largeThumbCanvas.width, largeThumbCanvas.height);
                ctx.drawImage(layercanvas, 0, 0, largeThumbCanvas.width, largeThumbCanvas.height);
                ctx.restore();
                (0, _bb.BB).css(largeThumbDiv, {
                    top: e.clientY - largeThumbCanvas.height / 2 + "px",
                    opacity: "0"
                });
                if (largeThumbInDocument === false) {
                    document.body.appendChild(largeThumbDiv);
                    largeThumbInDocument = true;
                }
                clearTimeout(largeThumbInTimeout);
                largeThumbInTimeout = setTimeout(function() {
                    (0, _bb.BB).css(largeThumbDiv, {
                        opacity: "1"
                    });
                }, 20);
                clearTimeout(largeThumbTimeout);
            });
            (0, _bb.BB).setEventListener(layer.thumb, "onpointerout", function() {
                clearTimeout(largeThumbInTimeout);
                (0, _bb.BB).css(largeThumbDiv, {
                    opacity: "0"
                });
                clearTimeout(largeThumbTimeout);
                largeThumbTimeout = setTimeout(function() {
                    if (!largeThumbInDocument) return;
                    document.body.removeChild(largeThumbDiv);
                    largeThumbInDocument = false;
                }, 300);
            });
            container1.appendChild(layer.thumb);
            container1.appendChild(layer.label);
            container1.appendChild(layer.opacityLabel);
            container1.appendChild(opacitySlider.getEl());
            let dragstart = false;
            let freshSelection = false;
            //events for moving layers up and down
            function dragEventHandler(event) {
                if (event.type === "pointerdown" && event.button === "left") {
                    (0, _bb.BB).css(layer, {
                        transition: "box-shadow 0.3s ease-in-out"
                    });
                    //dragContainer.appendChild(layer);
                    layer.style.zIndex = "1";
                    lastpos = layer.spot;
                    freshSelection = false;
                    if (!layer.isSelected) {
                        freshSelection = true;
                        div.activateLayer(layer.spot);
                    }
                    dragstart = true;
                } else if (event.type === "pointermove" && event.button === "left") {
                    if (dragstart) {
                        dragstart = false;
                        (0, _bb.BB).css(layer, {
                            boxShadow: "1px 3px 5px rgba(0,0,0,0.4)"
                        });
                    }
                    layer.posY += event.dY;
                    let corrected = Math.max(0, Math.min((klCanvasLayerArr.length - 1) * 35, layer.posY));
                    layer.style.top = corrected + "px";
                    updateLayersVerticalPosition(layer.spot, posToSpot(layer.posY));
                }
                if (event.type === "pointerup") {
                    (0, _bb.BB).css(layer, {
                        transition: "all 0.1s linear"
                    });
                    setTimeout(function() {
                        (0, _bb.BB).css(layer, {
                            boxShadow: ""
                        });
                    }, 20);
                    layer.posY = Math.max(0, Math.min((klCanvasLayerArr.length - 1) * 35, layer.posY));
                    //regularContainer.appendChild(layer);
                    layer.style.zIndex = "";
                    let newSpot = posToSpot(layer.posY);
                    let oldSpot = layer.spot;
                    move(layer.spot, newSpot);
                    if (oldSpot != newSpot) {
                        (0, _klHistory.klHistory).pause(true);
                        updatefunc(selectedSpotIndex);
                        (0, _klHistory.klHistory).pause(false);
                    }
                    if (oldSpot === newSpot && freshSelection) updatefunc(selectedSpotIndex);
                    freshSelection = false;
                }
            }
            layer.pointerListener = new (0, _bb.BB).PointerListener({
                target: container1,
                maxPointers: 1,
                onPointer: dragEventHandler
            });
            layerListEl.appendChild(layer);
        }
        layerElArr = [];
        while(layerListEl.firstChild){
            let child = layerListEl.firstChild;
            child.pointerListener.destroy();
            child.opacitySlider.destroy();
            layerListEl.removeChild(child);
        }
        for(let i = 0; i < klCanvasLayerArr.length; i++)createLayerEntry(i);
        div.activateLayer(selectedSpotIndex);
        updateHeight();
    }
    listdiv.appendChild(layerListEl);
    div.appendChild(listdiv);
    function posToSpot(p) {
        let result = parseInt("" + (p / (layerHeight + layerSpacing) + 0.5));
        result = Math.min(klCanvasLayerArr.length - 1, Math.max(0, result));
        result = klCanvasLayerArr.length - result - 1;
        return result;
    }
    let lastpos = 0;
    //update css position of all layers that are not being dragged, while dragging
    function updateLayersVerticalPosition(id, newspot) {
        newspot = Math.min(klCanvasLayerArr.length - 1, Math.max(0, newspot));
        if (newspot === lastpos) return;
        for(let i = 0; i < klCanvasLayerArr.length; i++){
            if (layerElArr[i].spot === id) continue;
            let posy = layerElArr[i].spot;
            if (layerElArr[i].spot > id) posy--;
            if (posy >= newspot) posy++;
            layerElArr[i].posY = (layerHeight + layerSpacing) * (klCanvasLayerArr.length - posy - 1);
            layerElArr[i].style.top = layerElArr[i].posY + "px";
        }
        lastpos = newspot;
    }
    function move(oldSpotIndex, newSpotIndex) {
        if (isNaN(oldSpotIndex) || isNaN(newSpotIndex)) throw "layermanager - invalid move";
        for(let i = 0; i < klCanvasLayerArr.length; i++)(function(i) {
            let posy = layerElArr[i].spot; // <- here
            if (layerElArr[i].spot === oldSpotIndex) posy = newSpotIndex;
            else {
                if (layerElArr[i].spot > oldSpotIndex) posy--;
                if (posy >= newSpotIndex) posy++;
            }
            layerElArr[i].spot = posy;
            layerElArr[i].posY = (layerHeight + layerSpacing) * (klCanvasLayerArr.length - posy - 1);
            layerElArr[i].style.top = layerElArr[i].posY + "px";
        })(i);
        if (oldSpotIndex === newSpotIndex) return;
        klCanvas.moveLayer(selectedSpotIndex, newSpotIndex - oldSpotIndex);
        klCanvasLayerArr = klCanvas.getLayers();
        selectedSpotIndex = newSpotIndex;
        mergeBtn.disabled = selectedSpotIndex === 0;
    }
    //updating the thumbs in interval
    //don't update when: manager not visible || layer didn't change || is drawing
    let updateThumbsInterval = setInterval(function() {
        if (div.style.display !== "block") return;
        let historyState = (0, _klHistory.klHistory).getState();
        if (historyState === oldHistoryState) return;
        oldHistoryState = historyState;
        for(let i = 0; i < layerElArr.length; i++)if (selectedSpotIndex === layerElArr[i].spot && klCanvasLayerArr[layerElArr[i].spot]) {
            let ctx = layerElArr[i].thumb.getContext("2d");
            ctx.save();
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            if (klCanvasLayerArr[layerElArr[i].spot].context.canvas.width < layerElArr[i].thumb.width) ctx.imageSmoothingEnabled = false;
            ctx.drawImage(klCanvasLayerArr[layerElArr[i].spot].context.canvas, 0, 0, layerElArr[i].thumb.width, layerElArr[i].thumb.height);
            ctx.restore();
        }
    }, 1);
    function updateHeight() {
        layerListEl.style.height = layerElArr.length * 35 + "px";
    }
    // ---- interface ----
    div.update = function(activeLayerSpotIndex) {
        klCanvasLayerArr = klCanvas.getLayers();
        if (activeLayerSpotIndex || activeLayerSpotIndex === 0) selectedSpotIndex = activeLayerSpotIndex;
        removeBtn.disabled = klCanvasLayerArr.length === 1;
        if (klCanvasLayerArr.length === (0, _klCanvas.MAX_LAYERS)) {
            addnewBtn.disabled = true;
            duplicateBtn.disabled = true;
        } else {
            addnewBtn.disabled = false;
            duplicateBtn.disabled = false;
        }
        setTimeout(function() {
            createLayerList();
        }, 1);
    };
    div.getSelected = function() {
        return selectedSpotIndex;
    };
    div.activateLayer = function(spotIndex) {
        if (spotIndex < 0 || spotIndex > layerElArr.length - 1) throw "invalid spotIndex " + spotIndex + ", layerElArr.length " + layerElArr.length;
        selectedSpotIndex = spotIndex;
        modeSelect.setValue(klCanvasLayerArr[selectedSpotIndex].mixModeStr);
        for(let i = 0; i < layerElArr.length; i++)if (selectedSpotIndex === layerElArr[i].spot) {
            layerElArr[i].style.backgroundColor = "rgb( 250, 250, 250)";
            layerElArr[i].label.style.color = "#000";
            layerElArr[i].style.boxShadow = "";
            layerElArr[i].style.border = "1px solid var(--active-highlight-color)";
            layerElArr[i].opacitySlider.setActive(true);
            layerElArr[i].isSelected = true;
        } else {
            layerElArr[i].style.backgroundColor = "rgb( 220, 220, 220)";
            layerElArr[i].label.style.color = "#666";
            layerElArr[i].style.boxShadow = "";
            layerElArr[i].style.border = "1px solid rgb(158, 158, 158)";
            layerElArr[i].opacitySlider.setActive(false);
            layerElArr[i].isSelected = false;
        }
        mergeBtn.disabled = selectedSpotIndex === 0;
    };
    div.setUiState = function(stateStr) {
        uiState = "" + stateStr;
        if (uiState === "left") (0, _bb.BB).css(largeThumbDiv, {
            left: "280px",
            right: ""
        });
        else (0, _bb.BB).css(largeThumbDiv, {
            left: "",
            right: "280px"
        });
    };
    createLayerList();
    return div;
}

},{"../../../bb/bb":"dcQKo","../modals/popup":"4Ltiz","../../history/kl-history":"klzEn","../base-components/options":"huqRY","../base-components/select":"7mzRU","../base-components/point-slider":"gzw3V","url:~/src/app/img/ui/add-layer.svg":"20GKw","url:~/src/app/img/ui/duplicate-layer.svg":"gJwi3","url:~/src/app/img/ui/merge-layers.svg":"c1NXK","url:~/src/app/img/ui/remove-layer.svg":"cI4U0","url:~/src/app/img/ui/rename-layer.svg":"7Jba4","../../canvas/kl-canvas":"l78MY","../../../language/language":"iiYGN","../../canvas/translate-blending":"6hHQR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"20GKw":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "add-layer.2b356a02.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"gJwi3":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "duplicate-layer.35a88297.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"c1NXK":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "merge-layers.47516fd8.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"cI4U0":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "remove-layer.6d1452f5.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"7Jba4":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "rename-layer.129b7a9b.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"l78MY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MAX_LAYERS", ()=>MAX_LAYERS);
/**
 * The image/canvas that the user paints on
 * Has layers. layers have names and opacity.
 *
 * Interacts with the history you specify (for undo/redo)
 */ parcelHelpers.export(exports, "KlCanvas", ()=>KlCanvas);
var _bb = require("../../bb/bb");
var _floodFill = require("../image-operations/flood-fill");
var _shapeTool = require("../image-operations/shape-tool");
var _renderText = require("../image-operations/render-text");
var _klHistory = require("../history/kl-history");
var _drawProject = require("./draw-project");
var _language = require("../../language/language");
var _gradientTool = require("../image-operations/gradient-tool");
const allowedMixModes = [
    "source-over",
    "darken",
    "multiply",
    "color-burn",
    "lighten",
    "screen",
    "color-dodge",
    "overlay",
    "soft-light",
    "hard-light",
    "difference",
    "exclusion",
    "hue",
    "saturation",
    "color",
    "luminosity", 
];
const MAX_LAYERS = 16;
class KlCanvas {
    init(w, h) {
        if (!w || !h || isNaN(w) || isNaN(h) || w < 1 || h < 1) throw new Error("init - invalid canvas size: " + w + ", " + h);
        this.width = w;
        this.height = h;
    }
    emitChange() {
        // some changes don't get captured by the history - e.g. changing opacity as the user drags the slider
        this.changeListenerArr.forEach((item)=>item());
    }
    updateIndices() {
        this.layerCanvasArr.forEach((item, index)=>{
            item.index = index;
        });
    }
    // ---- public ----
    constructor(params, layerNrOffset = 0){
        this.layerNrOffset = layerNrOffset;
        this.layerCanvasArr = [];
        this.pickCanvas = (0, _bb.BB).canvas(1, 1);
        this.history = new (0, _klHistory.DecoyKlHistory)();
        if ("copy" in params) {
            this.width = 1;
            this.height = 1;
        } else if ("width" in params && "height" in params) {
            this.width = params.width;
            this.height = params.height;
        } else {
            this.width = 1;
            this.height = 1;
        }
        this.init(this.width, this.height);
        this.changeListenerArr = [];
        if ("copy" in params) try {
            this.copy(params.copy);
        } catch (e) {
            this.destroy();
            throw e;
        }
        else if ("projectObj" in params) {
            const origLayers = [].concat(params.projectObj.layers);
            this.init(params.projectObj.width, params.projectObj.height);
            if (!origLayers.length) throw new Error("project.layers needs at least 1 layer");
            for(let i = 0; i < origLayers.length; i++){
                if (origLayers[i].mixModeStr && !allowedMixModes.includes(origLayers[i].mixModeStr)) throw new Error("unknown mixModeStr " + origLayers[i].mixModeStr);
                this.addLayer();
                this.layerOpacity(i, origLayers[i].opacity);
                this.layerCanvasArr[i].name = origLayers[i].name;
                this.layerCanvasArr[i].mixModeStr = origLayers[i].mixModeStr ? origLayers[i].mixModeStr : "source-over";
                this.layerCanvasArr[i].getContext("2d").drawImage(origLayers[i].image, 0, 0);
            }
        }
        this.updateIndices();
    }
    setHistory(h) {
        this.history = h;
    }
    /**
     * Resets canvas -> 1 layer, 100% opacity,
     * unless layers provided.
     * @param p
     */ reset(p) {
        if (!p.width || !p.height || p.width < 1 || p.height < 1 || isNaN(p.width) || isNaN(p.height)) throw new Error("invalid canvas size");
        this.history.pause(true);
        this.width = p.width;
        this.height = p.height;
        this.layerCanvasArr.splice(1, Math.max(0, this.layerCanvasArr.length - 1));
        if (p.layers) for(let i = 0; i < p.layers.length; i++){
            let item = p.layers[i];
            if (!this.layerCanvasArr[i]) this.addLayer();
            this.layerCanvasArr[i].name = item.name;
            this.layerCanvasArr[i].width = this.width;
            this.layerCanvasArr[i].height = this.height;
            this.layerCanvasArr[i].mixModeStr = item.mixModeStr ? item.mixModeStr : "source-over";
            this.layerCanvasArr[i].getContext("2d").drawImage(item.image, 0, 0);
            this.layerOpacity(i, item.opacity);
        }
        else {
            this.layerCanvasArr[0].name = p.layerName ? p.layerName : (0, _language.LANG)("layers-layer") + " 1";
            this.layerCanvasArr[0].width = this.width;
            this.layerCanvasArr[0].height = this.height;
            this.layerCanvasArr[0].mixModeStr = "source-over";
            this.layerOpacity(0, 1);
            if (p.color) this.layerFill(0, p.color);
            else if (p.image) this.layerCanvasArr[0].getContext("2d").drawImage(p.image, 0, 0);
        }
        this.updateIndices();
        this.history.pause(false);
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "reset",
            params: [
                p
            ] // dont screw with p
        });
        return this.layerCanvasArr.length - 1;
    }
    isLayerLimitReached() {
        return this.layerCanvasArr.length >= MAX_LAYERS;
    }
    getWidth() {
        return this.width;
    }
    getHeight() {
        return this.height;
    }
    copy(toCopyCanvas) {
        if (toCopyCanvas.getWidth() < 1 || toCopyCanvas.getHeight() < 1 || isNaN(toCopyCanvas.getWidth()) || isNaN(toCopyCanvas.getHeight())) throw new Error("invalid canvas size");
        // keep existing canvases
        let origLayers = toCopyCanvas.getLayers();
        while(this.layerCanvasArr.length > origLayers.length)this.removeLayer(this.layerCanvasArr.length - 1);
        if (toCopyCanvas.getWidth() != this.width || toCopyCanvas.getHeight() != this.height) this.init(toCopyCanvas.getWidth(), toCopyCanvas.getHeight());
        for(let i = 0; i < origLayers.length; i++){
            if (i >= this.layerCanvasArr.length) this.addLayer();
            else {
                this.layerCanvasArr[i].width = this.width;
                this.layerCanvasArr[i].height = this.height;
            }
            this.layerOpacity(i, origLayers[i].opacity);
            this.layerCanvasArr[i].name = origLayers[i].name;
            this.layerCanvasArr[i].mixModeStr = origLayers[i].mixModeStr;
            this.layerCanvasArr[i].getContext("2d").drawImage(origLayers[i].context.canvas, 0, 0);
        }
        this.updateIndices();
    }
    getLayerCount() {
        return this.layerCanvasArr.length;
    }
    resize(w, h, algorithm = "smooth") {
        if (!w || !h || w === this.width && h === this.height || isNaN(w) || isNaN(h) || w < 1 || h < 1) return false;
        w = Math.max(w, 1);
        h = Math.max(h, 1);
        let tmp1, tmp2;
        if (algorithm === "pixelated") {
            tmp1 = (0, _bb.BB).canvas(w, h);
            let tmp1Ctx = tmp1.getContext("2d");
            tmp1Ctx.imageSmoothingEnabled = false;
            for(let i = 0; i < this.layerCanvasArr.length; i++){
                if (i > 0) tmp1Ctx.clearRect(0, 0, w, h);
                let layerCanvas = this.layerCanvasArr[i];
                tmp1Ctx.drawImage(layerCanvas, 0, 0, w, h);
                layerCanvas.width = w;
                layerCanvas.height = h;
                let layerContext = layerCanvas.getContext("2d");
                layerContext.drawImage(tmp1, 0, 0);
            }
        } else if (algorithm === "smooth") {
            tmp1 = (0, _bb.BB).canvas();
            tmp2 = (0, _bb.BB).canvas();
            for(let i1 = 0; i1 < this.layerCanvasArr.length; i1++)(0, _bb.BB).resizeCanvas(this.layerCanvasArr[i1], w, h, tmp1, tmp2);
        } else throw new Error("unknown resize algorithm");
        this.width = w;
        this.height = h;
        return true;
    }
    /**
     * crop / extend
     * @param p
     */ resizeCanvas(p) {
        const newW = Math.round(p.left) + this.width + Math.round(p.right);
        const newH = Math.round(p.top) + this.height + Math.round(p.bottom);
        const offX = Math.round(p.left);
        const offY = Math.round(p.top);
        if (isNaN(newW) || isNaN(newH) || newW < 1 || newH < 1) throw new Error("KlCanvas.resizeCanvas - invalid canvas size");
        for(let i = 0; i < this.layerCanvasArr.length; i++){
            const ctemp = (0, _bb.BB).canvas(this.width, this.height);
            let layerCanvas = this.layerCanvasArr[i];
            let layerCtx = this.layerCanvasArr[i].getContext("2d");
            ctemp.getContext("2d").drawImage(layerCanvas, 0, 0);
            this.layerCanvasArr[i].width = newW;
            this.layerCanvasArr[i].height = newH;
            layerCtx.save();
            if (i === 0 && p.fillColor) {
                layerCtx.fillStyle = (0, _bb.BB).ColorConverter.toRgbStr(p.fillColor);
                layerCtx.fillRect(0, 0, newW, newH);
                layerCtx.clearRect(offX, offY, this.width, this.height);
            }
            layerCtx.drawImage(ctemp, offX, offY);
            layerCtx.restore();
        }
        this.width = newW;
        this.height = newH;
    }
    /**
     * will be inserted on top of selected
     * @param selected
     */ addLayer(selected) {
        if (this.isLayerLimitReached()) return false;
        let canvas = (0, _bb.BB).canvas(this.width, this.height);
        if (!canvas.getContext("2d")) throw new Error("kl-create-canvas-error");
        canvas.mixModeStr = "source-over";
        if (selected === undefined) {
            this.layerCanvasArr[this.layerCanvasArr.length] = canvas;
            selected = Math.max(0, this.layerCanvasArr.length - 1);
        } else {
            this.layerCanvasArr.splice(selected + 1, 0, canvas);
            selected++;
        }
        canvas.name = (0, _language.LANG)("layers-layer") + " " + (this.layerCanvasArr.length + this.layerNrOffset);
        this.history.pause(true);
        this.layerOpacity(selected, 1);
        this.history.pause(false);
        this.updateIndices();
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "addLayer",
            params: [
                selected - 1
            ]
        });
        return selected;
    }
    duplicateLayer(i) {
        if (!this.layerCanvasArr[i] || this.isLayerLimitReached()) return false;
        let canvas = (0, _bb.BB).canvas(this.width, this.height);
        this.layerCanvasArr.splice(i + 1, 0, canvas);
        canvas.name = this.layerCanvasArr[i].name + " " + (0, _language.LANG)("layers-copy");
        canvas.mixModeStr = this.layerCanvasArr[i].mixModeStr;
        canvas.getContext("2d").drawImage(this.layerCanvasArr[i], 0, 0);
        this.history.pause(true);
        this.layerOpacity(i + 1, this.layerCanvasArr[i].opacity);
        this.history.pause(false);
        this.updateIndices();
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "duplicateLayer",
            params: [
                i
            ]
        });
        return i + 1;
    }
    getLayerContext(i, doReturnNull) {
        if (this.layerCanvasArr[i]) return this.layerCanvasArr[i].getContext("2d");
        if (doReturnNull) return null;
        throw new Error("layer of index " + i + " not found (in " + this.layerCanvasArr.length + " layers)");
    }
    removeLayer(i) {
        if (this.layerCanvasArr[i]) {
            this.layerCanvasArr.splice(i, 1);
            this.updateIndices();
        } else return false;
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "removeLayer",
            params: [
                i
            ]
        });
        return Math.max(0, i - 1);
    }
    renameLayer(i, name) {
        if (this.layerCanvasArr[i]) this.layerCanvasArr[i].name = name;
        else return false;
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "renameLayer",
            params: [
                i,
                name
            ]
        });
        return true;
    }
    layerOpacity(i, o) {
        if (!this.layerCanvasArr[i]) return;
        o = Math.max(0, Math.min(1, o));
        this.layerCanvasArr[i].opacity = o;
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "layerOpacity",
            params: [
                i,
                o
            ]
        });
        this.emitChange();
    }
    moveLayer(i, d) {
        if (d === 0) return;
        if (this.layerCanvasArr[i]) {
            const temp = this.layerCanvasArr[i];
            this.layerCanvasArr.splice(i, 1);
            const targetIndex = Math.max(0, Math.min(i + d, this.layerCanvasArr.length));
            this.layerCanvasArr.splice(targetIndex, 0, temp);
            this.updateIndices();
            this.history.push({
                tool: [
                    "canvas"
                ],
                action: "moveLayer",
                params: [
                    i,
                    d
                ]
            });
            return targetIndex;
        }
    }
    mergeLayers(layerBottomIndex, layerTopIndex, mixModeStr) {
        if (!this.layerCanvasArr[layerBottomIndex] || !this.layerCanvasArr[layerTopIndex] || layerBottomIndex === layerTopIndex) return;
        //order messed up
        if (layerBottomIndex > layerTopIndex) {
            let temp = layerBottomIndex;
            layerBottomIndex = layerTopIndex;
            layerTopIndex = temp;
        }
        let topOpacity = this.layerCanvasArr[layerTopIndex].opacity;
        if (topOpacity !== 0 && topOpacity) {
            let ctx = this.layerCanvasArr[layerBottomIndex].getContext("2d");
            ctx.save();
            if (mixModeStr === "as-alpha") {
                (0, _bb.BB).convertToAlphaChannelCanvas(this.layerCanvasArr[layerTopIndex]);
                ctx.globalCompositeOperation = "destination-in";
                ctx.globalAlpha = topOpacity;
                this.layerCanvasArr[layerBottomIndex].getContext("2d").drawImage(this.layerCanvasArr[layerTopIndex], 0, 0);
            } else {
                if (mixModeStr) ctx.globalCompositeOperation = mixModeStr;
                ctx.globalAlpha = topOpacity;
                this.layerCanvasArr[layerBottomIndex].getContext("2d").drawImage(this.layerCanvasArr[layerTopIndex], 0, 0);
            }
            ctx.restore();
            // workaround for chrome bug https://bugs.chromium.org/p/chromium/issues/detail?id=1281185
            // TODO remove if chrome updated
            if (mixModeStr) {
                ctx.save();
                ctx.fillStyle = "rgba(0,0,0,0.01)";
                ctx.fillRect(-0.9999999, -0.9999999, 1, 1);
                ctx.restore();
            }
        }
        this.updateIndices();
        this.history.pause(true);
        this.removeLayer(layerTopIndex);
        this.history.pause(false);
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "mergeLayers",
            params: [
                layerBottomIndex,
                layerTopIndex,
                mixModeStr
            ]
        });
        return layerBottomIndex;
    }
    rotate(deg) {
        while(deg < 0)deg += 360;
        deg %= 360;
        if (deg % 90 != 0 || deg === 0) return;
        let temp = (0, _bb.BB).canvas();
        if (deg === 0 || deg === 180) {
            temp.width = this.width;
            temp.height = this.height;
        } else if (deg === 90 || deg === 270) {
            temp.width = this.height;
            temp.height = this.width;
        }
        let ctx = temp.getContext("2d");
        for(let i = 0; i < this.layerCanvasArr.length; i++){
            ctx.clearRect(0, 0, temp.width, temp.height);
            ctx.save();
            ctx.translate(temp.width / 2, temp.height / 2);
            ctx.rotate(deg * Math.PI / 180);
            if (deg === 180) ctx.drawImage(this.layerCanvasArr[i], -temp.width / 2, -temp.height / 2);
            else if (deg === 90 || deg === 270) ctx.drawImage(this.layerCanvasArr[i], -temp.height / 2, -temp.width / 2);
            this.layerCanvasArr[i].width = temp.width;
            this.layerCanvasArr[i].height = temp.height;
            this.layerCanvasArr[i].getContext("2d").clearRect(0, 0, this.layerCanvasArr[i].width, this.layerCanvasArr[i].height);
            this.layerCanvasArr[i].getContext("2d").drawImage(temp, 0, 0);
            ctx.restore();
        }
        this.width = temp.width;
        this.height = temp.height;
    }
    flip(isHorizontal, isVertical, layerIndex) {
        if (!isHorizontal && !isVertical) return;
        let temp = (0, _bb.BB).canvas(this.width, this.height);
        temp.width = this.width;
        temp.height = this.height;
        let tempCtx = temp.getContext("2d");
        for(let i = 0; i < this.layerCanvasArr.length; i++){
            if ((layerIndex || layerIndex === 0) && i !== layerIndex) continue;
            tempCtx.save();
            tempCtx.clearRect(0, 0, temp.width, temp.height);
            tempCtx.translate(temp.width / 2, temp.height / 2);
            tempCtx.scale(isHorizontal ? -1 : 1, isVertical ? -1 : 1);
            tempCtx.drawImage(this.layerCanvasArr[i], -temp.width / 2, -temp.height / 2);
            tempCtx.restore();
            this.layerCanvasArr[i].getContext("2d").clearRect(0, 0, this.layerCanvasArr[i].width, this.layerCanvasArr[i].height);
            this.layerCanvasArr[i].getContext("2d").drawImage(temp, 0, 0);
        }
    }
    layerFill(layerIndex, colorObj, compositeOperation) {
        let ctx = this.layerCanvasArr[layerIndex].getContext("2d");
        ctx.save();
        if (compositeOperation) ctx.globalCompositeOperation = compositeOperation;
        ctx.fillStyle = "rgba(" + colorObj.r + "," + colorObj.g + "," + colorObj.b + ",1)";
        ctx.fillRect(0, 0, this.layerCanvasArr[layerIndex].width, this.layerCanvasArr[layerIndex].height);
        ctx.restore();
        // workaround for chrome bug https://bugs.chromium.org/p/chromium/issues/detail?id=1281185
        // TODO remove if chrome updated
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,0.01)";
        ctx.fillRect(-0.9999999, -0.9999999, 1, 1);
        ctx.restore();
        /*if (!document.getElementById('testocanvas')) {
            layerCanvasArr[layerIndex].id = 'testocanvas';
            document.body.appendChild(layerCanvasArr[layerIndex]);
            BB.css(layerCanvasArr[layerIndex], {
                position: 'fixed',
                left: '0',
                top: '0',
                zIndex: '1111111',
                transform: 'scale(0.2)',
                border: '10px solid red',
            });
        }
        if (!document.getElementById('testocanvas')) {
            let c = document.createElement('canvas');
            c.width = 1000;
            c.height = 1000;
            let ctx2 = c.getContext('2d');
            ctx2.drawImage(layerCanvasArr[layerIndex], 0, 0);
            c.id = 'testocanvas';
            document.body.appendChild(c);
            BB.css(c, {
                position: 'fixed',
                left: '0',
                top: '0',
                zIndex: '1111111',
                transform: 'scale(0.2)',
                border: '10px solid red',
            });
        }*/ this.history.push({
            tool: [
                "canvas"
            ],
            action: "layerFill",
            params: [
                layerIndex,
                colorObj,
                compositeOperation
            ]
        });
    }
    floodFill(layerIndex, x, y, rgb, opacity, tolerance, sampleStr, grow, isContiguous) {
        if (x < 0 || y < 0 || x >= this.width || y >= this.height || opacity === 0) return;
        tolerance = Math.round(tolerance);
        if (![
            "above",
            "current",
            "all"
        ].includes(sampleStr)) throw new Error("invalid sampleStr");
        let result;
        let srcCtx;
        let srcImageData;
        let srcData;
        let targetCtx;
        let targetImageData;
        let targetData;
        if (sampleStr === "all") {
            let srcCanvas = this.layerCanvasArr.length === 1 ? this.layerCanvasArr[0] : this.getCompleteCanvas(1);
            srcCtx = srcCanvas.getContext("2d");
            srcImageData = srcCtx.getImageData(0, 0, this.width, this.height);
            srcData = srcImageData.data;
            result = (0, _floodFill.floodFillBits)(srcData, this.width, this.height, x, y, tolerance, Math.round(grow), isContiguous);
            srcCanvas = null;
            srcCtx = null;
            srcImageData = null;
            srcData = null;
            targetCtx = this.layerCanvasArr[layerIndex].getContext("2d");
            targetImageData = targetCtx.getImageData(0, 0, this.width, this.height);
        } else {
            let srcIndex = sampleStr === "above" ? layerIndex + 1 : layerIndex;
            if (srcIndex >= this.layerCanvasArr.length) return;
            srcCtx = this.layerCanvasArr[srcIndex].getContext("2d");
            srcImageData = srcCtx.getImageData(0, 0, this.width, this.height);
            srcData = srcImageData.data;
            result = (0, _floodFill.floodFillBits)(srcData, this.width, this.height, x, y, tolerance, Math.round(grow), isContiguous);
            if (layerIndex !== srcIndex) {
                srcCtx = null;
                srcImageData = null;
                srcData = null;
            }
            targetCtx = layerIndex === srcIndex ? srcCtx : this.layerCanvasArr[layerIndex].getContext("2d");
            targetImageData = layerIndex === srcIndex ? srcImageData : targetCtx.getImageData(0, 0, this.width, this.height);
        }
        targetData = targetImageData.data;
        if (rgb) {
            if (opacity === 1) {
                for(let i = 0; i < this.width * this.height; i++)if (result.data[i] === 255) {
                    targetData[i * 4] = rgb.r;
                    targetData[i * 4 + 1] = rgb.g;
                    targetData[i * 4 + 2] = rgb.b;
                    targetData[i * 4 + 3] = 255;
                }
            } else {
                for(let i1 = 0; i1 < this.width * this.height; i1++)if (result.data[i1] === 255) {
                    targetData[i1 * 4] = (0, _bb.BB).mix(targetData[i1 * 4], rgb.r, opacity);
                    targetData[i1 * 4 + 1] = (0, _bb.BB).mix(targetData[i1 * 4 + 1], rgb.g, opacity);
                    targetData[i1 * 4 + 2] = (0, _bb.BB).mix(targetData[i1 * 4 + 2], rgb.b, opacity);
                    targetData[i1 * 4 + 3] = (0, _bb.BB).mix(targetData[i1 * 4 + 3], 255, opacity);
                }
            }
        } else if (opacity === 1) {
            for(let i2 = 0; i2 < this.width * this.height; i2++)if (result.data[i2] === 255) targetData[i2 * 4 + 3] = 0;
        } else {
            for(let i3 = 0; i3 < this.width * this.height; i3++)if (result.data[i3] === 255) targetData[i3 * 4 + 3] = (0, _bb.BB).mix(targetData[i3 * 4 + 3], 0, opacity);
        }
        targetCtx.putImageData(targetImageData, 0, 0);
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "replaceLayer",
            params: [
                layerIndex,
                targetImageData
            ]
        });
    }
    /**
     * draw shape via BB.drawShape
     * @param layerIndex
     * @param shapeObj
     */ drawShape(layerIndex, shapeObj) {
        if (shapeObj.x1 === shapeObj.x2 && shapeObj.y1 === shapeObj.y2) return;
        (0, _shapeTool.drawShape)(this.layerCanvasArr[layerIndex].getContext("2d"), shapeObj);
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "drawShape",
            params: [
                layerIndex,
                (0, _bb.BB).copyObj(shapeObj)
            ]
        });
    }
    drawGradient(layerIndex, gradientObj) {
        (0, _gradientTool.drawGradient)(this.layerCanvasArr[layerIndex].getContext("2d"), gradientObj);
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "drawGradient",
            params: [
                layerIndex,
                (0, _bb.BB).copyObj(gradientObj)
            ]
        });
    }
    text(layerIndex, p) {
        (0, _renderText.renderText)(this.layerCanvasArr[layerIndex], (0, _bb.BB).copyObj(p));
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "text",
            params: [
                layerIndex,
                (0, _bb.BB).copyObj(p)
            ]
        });
    }
    replaceLayer(layerIndex, imageData) {
        let ctx = this.layerCanvasArr[layerIndex].getContext("2d");
        ctx.putImageData(imageData, 0, 0);
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "replaceLayer",
            params: [
                layerIndex,
                imageData
            ]
        });
    }
    clearLayer(layerIndex) {
        let ctx = this.layerCanvasArr[layerIndex].getContext("2d");
        ctx.save();
        ctx.clearRect(0, 0, this.layerCanvasArr[layerIndex].width, this.layerCanvasArr[layerIndex].height);
        ctx.restore();
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "clearLayer",
            params: [
                layerIndex
            ]
        });
    }
    getLayers() {
        return this.layerCanvasArr.map((item)=>{
            return {
                context: item.getContext("2d"),
                opacity: item.opacity,
                name: item.name,
                mixModeStr: item.mixModeStr
            };
        });
    }
    getLayersFast() {
        return this.layerCanvasArr.map((item)=>{
            return {
                canvas: item,
                opacity: item.opacity,
                name: item.name,
                mixModeStr: item.mixModeStr
            };
        });
    }
    getLayerIndex(canvasObj, doReturnNull) {
        for(let i = 0; i < this.layerCanvasArr.length; i++){
            if (this.layerCanvasArr[i] === canvasObj) return i;
        }
        if (!doReturnNull) throw new Error("layer not found (in " + this.layerCanvasArr.length + " layers)");
        return null;
    }
    getLayer(index, doReturnNull) {
        if (this.layerCanvasArr[index]) return {
            context: this.layerCanvasArr[index].getContext("2d"),
            opacity: this.layerCanvasArr[index].opacity,
            name: this.layerCanvasArr[index].name,
            id: index
        };
        if (!doReturnNull) throw new Error("layer of index " + index + " not found (in " + this.layerCanvasArr.length + " layers)");
        return null;
    }
    getColorAt(x, y) {
        x = Math.floor(x);
        y = Math.floor(y);
        let ctx = this.pickCanvas.getContext("2d");
        ctx.save();
        ctx.imageSmoothingEnabled = false;
        ctx.clearRect(0, 0, 1, 1);
        for(let i = 0; i < this.layerCanvasArr.length; i++){
            ctx.globalAlpha = this.layerCanvasArr[i].opacity;
            ctx.globalCompositeOperation = this.layerCanvasArr[i].mixModeStr;
            ctx.drawImage(this.layerCanvasArr[i], -x, -y);
        }
        ctx.restore();
        let imData = ctx.getImageData(0, 0, 1, 1);
        return new (0, _bb.BB).RGB(imData.data[0], imData.data[1], imData.data[2]);
    }
    getCompleteCanvas(factor) {
        return (0, _drawProject.drawProject)(this.getProject(), factor);
    }
    getProject() {
        return {
            width: this.width,
            height: this.height,
            layers: this.layerCanvasArr.map((layer)=>{
                return {
                    name: layer.name,
                    opacity: layer.opacity,
                    mixModeStr: layer.mixModeStr,
                    image: layer
                };
            })
        };
    }
    addChangeListener(func) {
        if (this.changeListenerArr.includes(func)) return;
        this.changeListenerArr.push(func);
    }
    removeChangeListener(func) {
        for(let i = 0; i < this.changeListenerArr.length; i++)if (this.changeListenerArr[i] === func) {
            this.changeListenerArr.splice(i, 1);
            return;
        }
    }
    setMixMode(layerIndex, mixModeStr) {
        if (!this.layerCanvasArr[layerIndex]) throw new Error("invalid layer");
        this.layerCanvasArr[layerIndex].mixModeStr = mixModeStr;
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "setMixMode",
            params: [
                layerIndex,
                "" + mixModeStr
            ]
        });
    }
    /**
     * Set composite drawing step for KlCanvasWorkspace.
     * To apply temporary manipulations to a layer.
     *
     * @param layerIndex
     * @param compositeObj
     */ setComposite(layerIndex, compositeObj) {
        if (!this.layerCanvasArr[layerIndex]) throw new Error("invalid layer");
        this.layerCanvasArr[layerIndex].compositeObj = compositeObj;
    }
    destroy() {
        if (this.layerCanvasArr === null) return;
        this.layerCanvasArr.forEach((canvas)=>{
            (0, _bb.BB).freeCanvas(canvas);
        });
        this.layerCanvasArr = null;
    }
}

},{"../../bb/bb":"dcQKo","../image-operations/flood-fill":"j0xrQ","../image-operations/shape-tool":"90Wty","../image-operations/render-text":"fEvNY","../history/kl-history":"klzEn","./draw-project":"6Yf6D","../../language/language":"iiYGN","../image-operations/gradient-tool":"jhX3B","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j0xrQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Does flood fill, and returns that. an array - 0 not filled. 255 filled
 *
 * returns {
 *     data: Uint8Array
 * }
 *
 * @param rgbaArr Uint8Array rgba
 * @param width int
 * @param height int
 * @param x int
 * @param y int
 * @param tolerance int 0 - 255
 * @param grow int >= 0
 * @param isContiguous boolean
 * @returns {{data: Uint8Array}}
 */ parcelHelpers.export(exports, "floodFillBits", ()=>floodFillBits);
/**
 * Flood fill. Tried https://github.com/binarymax/floodfill.js/ but it implemented tolerance wrong, and had bugs.
 * So, my own implementation. can handle tolerance, grow, opacity.
 * Needs to be optimized.
 */ /**
 * Set values in data within rect to 254, unless they're 255
 *
 * @param data Uint8Array
 * @param width int
 * @param x0 int
 * @param y0 int
 * @param x1 int >x0
 * @param y1 int >y0
 */ function fillRect(data, width, x0, y0, x1, y1) {
    for(let x = x0; x <= x1; x++)for(let y = y0; y <= y1; y++){
        if (data[y * width + x] === 255) continue;
        data[y * width + x] = 254;
    }
}
let mx, my;
/**
 * Get index i moved by dX, dY. in array with dimensions width height.
 * Returns null if outside bounds.
 *
 * @param width int
 * @param height int
 * @param i int
 * @param dX int
 * @param dY int
 * @returns {null|*}
 */ function moveIndex(width, height, i, dX, dY) {
    mx = i % width + dX;
    my = Math.floor(i / width) + dY;
    if (mx < 0 || my < 0 || mx >= width || my >= height) return null;
    return my * width + mx;
}
/**
 * If pixel can be filled (within tolerance) will be set 255 and returns true.
 * returns false if already filled, or i is null
 *
 * @param srcArr Uint8Array rgba
 * @param targetArr Uint8Array
 * @param width int
 * @param height int
 * @param initRgba rgba
 * @param tolerance int 0 - 255
 * @param i int - srcArr index
 * @returns {boolean}
 */ function testAndFill(srcArr, targetArr, width, height, initRgba, tolerance, i) {
    if (i === null || targetArr[i] === 255) return false;
    if (srcArr[i * 4] === initRgba[0] && srcArr[i * 4 + 1] === initRgba[1] && srcArr[i * 4 + 2] === initRgba[2] && srcArr[i * 4 + 3] === initRgba[3]) {
        targetArr[i] = 255;
        return true;
    }
    if (tolerance > 0 && Math.abs(srcArr[i * 4] - initRgba[0]) <= tolerance && Math.abs(srcArr[i * 4 + 1] - initRgba[1]) <= tolerance && Math.abs(srcArr[i * 4 + 2] - initRgba[2]) <= tolerance && Math.abs(srcArr[i * 4 + 3] - initRgba[3]) <= tolerance) {
        targetArr[i] = 255;
        return true;
    }
    return false;
}
/**
 *
 * @param srcArr Uint8Array rgba
 * @param targetArr Uint8Array
 * @param width int
 * @param height int
 * @param px int
 * @param py int
 * @param tolerance int 0 - 255
 * @param grow int >= 0
 * @param isContiguous boolean
 */ function floodFill(srcArr, targetArr, width, height, px, py, tolerance, grow, isContiguous) {
    let initRgba = [
        srcArr[(py * width + px) * 4],
        srcArr[(py * width + px) * 4 + 1],
        srcArr[(py * width + px) * 4 + 2],
        srcArr[(py * width + px) * 4 + 3]
    ];
    if (isContiguous) {
        let q = [];
        q.push(py * width + px);
        targetArr[py * width + px] = 255;
        let i, e;
        while(q.length){
            i = q.pop();
            // queue up unfilled neighbors
            e = moveIndex(width, height, i, -1, 0); // left
            testAndFill(srcArr, targetArr, width, height, initRgba, tolerance, e) && q.push(e);
            e = moveIndex(width, height, i, 1, 0); // right
            testAndFill(srcArr, targetArr, width, height, initRgba, tolerance, e) && q.push(e);
            e = moveIndex(width, height, i, 0, -1); // up
            testAndFill(srcArr, targetArr, width, height, initRgba, tolerance, e) && q.push(e);
            e = moveIndex(width, height, i, 0, 1); // bottom
            testAndFill(srcArr, targetArr, width, height, initRgba, tolerance, e) && q.push(e);
        }
    } else for(let i1 = 0; i1 < width * height; i1++)testAndFill(srcArr, targetArr, width, height, initRgba, tolerance, i1);
    // grow
    if (grow === 0) return;
    // how does it grow? it finds all pixel at the edge.
    // then depending on what kind of edge it is, it draws a rectangle into target
    // the rectangle has the value 254, or else it mess it all up.
    // after it's all done, replaces it with 255
    let x0, x1, y0, y1;
    let l, tl, t, tr, r, br, b, bl; // left, top left, top, top right, etc.
    for(let x = 0; x < width; x++)for(let y = 0; y < height; y++){
        if (targetArr[y * width + x] !== 255) continue;
        // bounds of rectangle
        x0 = x;
        x1 = x;
        y0 = y;
        y1 = y;
        l = targetArr[y * width + x - 1] !== 255;
        tl = targetArr[(y - 1) * width + x - 1] !== 255;
        t = targetArr[(y - 1) * width + x] !== 255;
        tr = targetArr[(y - 1) * width + x + 1] !== 255;
        r = targetArr[y * width + x + 1] !== 255;
        br = targetArr[(y + 1) * width + x + 1] !== 255;
        b = targetArr[(y + 1) * width + x] !== 255;
        bl = targetArr[(y + 1) * width + x - 1] !== 255;
        if (l) x0 = x - grow;
        if (l && tl && t) {
            x0 = x - grow;
            y0 = y - grow;
        }
        if (t) y0 = Math.min(y0, y - grow);
        if (t && tr && r) {
            y0 = Math.min(y0, y - grow);
            x1 = x + grow;
        }
        if (r) x1 = Math.max(x1, x + 1 * grow);
        if (r && br && b) {
            x1 = Math.max(x1, x + 1 * grow);
            y1 = Math.max(y1, y + 1 * grow);
        }
        if (b) y1 = Math.max(y1, y + 1 * grow);
        if (b && bl && l) {
            x0 = Math.min(x0, x - 1 * grow);
            y1 = Math.max(y1, y + 1 * grow);
        }
        if (!l && !tl && !t && !tr && !r && !br && !b && !bl) continue;
        fillRect(targetArr, width, Math.max(0, x0), Math.max(0, y0), Math.min(width - 1, x1), Math.min(height - 1, y1));
    }
    for(let i2 = 0; i2 < width * height; i2++)if (targetArr[i2] === 254) targetArr[i2] = 255;
}
function floodFillBits(rgbaArr, width, height, x, y, tolerance, grow, isContiguous) {
    x = Math.round(x);
    y = Math.round(y);
    let resultArr = new Uint8Array(new ArrayBuffer(width * height));
    floodFill(rgbaArr, resultArr, width, height, x, y, tolerance, grow, isContiguous);
    return {
        data: resultArr
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"90Wty":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Input processor for shape tool.
 * Coordinates are in canvas space.
 * angleRad is the angle of the canvas.
 *
 * @param p - {onShape: func(isDone, x1, y1, x2, y2, angleRad)}
 * @constructor
 */ parcelHelpers.export(exports, "ShapeTool", ()=>ShapeTool);
/**
 * Draw a shape (rectangle, ellipse, line)
 *
 * @param ctx
 * @param shapeObj
 */ parcelHelpers.export(exports, "drawShape", ()=>drawShape);
var _bb = require("../../bb/bb");
function ShapeTool(p) {
    let downX, downY, downAngleRad;
    this.onDown = function(x, y, angleRad) {
        downX = x;
        downY = y;
        downAngleRad = angleRad;
    };
    this.onMove = function(x, y) {
        p.onShape(false, downX, downY, x, y, downAngleRad);
    };
    this.onUp = function(x, y) {
        p.onShape(true, downX, downY, x, y, downAngleRad);
    };
}
function applyDefaults(obj, defaults) {
    for(const property in defaults)if (!(property in obj)) obj[property] = defaults[property];
}
function drawShape(ctx, shapeObj) {
    shapeObj = (0, _bb.BB).copyObj(shapeObj);
    applyDefaults(shapeObj, {
        angleRad: 0,
        isOutwards: false,
        opacity: 1,
        isEraser: false,
        doLockAlpha: false
    });
    if ([
        "rect",
        "ellipse",
        "line"
    ].includes(shapeObj.type)) {
        const lineWidth = Math.round(shapeObj.lineWidth);
        const angleDeg = shapeObj.angleRad * 180 / Math.PI;
        // --- prep color ---
        let colorRGB = shapeObj.isEraser ? {
            r: 255,
            g: 255,
            b: 255
        } : shapeObj.fillRgb ? shapeObj.fillRgb : shapeObj.strokeRgb;
        // --- prep canvas ---
        ctx.save();
        if (shapeObj.opacity) ctx.globalAlpha = shapeObj.opacity;
        if (shapeObj.isEraser) ctx.globalCompositeOperation = "destination-out";
        if (shapeObj.doLockAlpha) ctx.globalCompositeOperation = "source-atop";
        ctx.rotate(-shapeObj.angleRad);
        if (shapeObj.fillRgb) ctx.fillStyle = (0, _bb.BB).ColorConverter.toRgbStr(colorRGB);
        else if (shapeObj.strokeRgb) {
            ctx.strokeStyle = (0, _bb.BB).ColorConverter.toRgbStr(colorRGB);
            ctx.lineWidth = lineWidth;
        }
        let x1 = shapeObj.x1;
        let y1 = shapeObj.y1;
        let x2 = shapeObj.x2;
        let y2 = shapeObj.y2;
        // --- angle snapping ---
        if (shapeObj.isAngleSnap) {
            let r1 = (0, _bb.BB).rotate(x1, y1, shapeObj.angleRad / Math.PI * 180);
            let r2 = (0, _bb.BB).rotate(x2, y2, shapeObj.angleRad / Math.PI * 180);
            let pAngleDeg = (0, _bb.BB).pointsToAngleDeg(r1, r2) + 90;
            let pAngleDegSnapped = Math.round(pAngleDeg / 45) * 45;
            let rotated = (0, _bb.BB).rotateAround({
                x: x1,
                y: y1
            }, {
                x: x2,
                y: y2
            }, pAngleDegSnapped - pAngleDeg);
            x2 = rotated.x;
            y2 = rotated.y;
            // needs to be perfect if p1->p2 aligns with canvas x- or y-axis
            if ((angleDeg + pAngleDegSnapped) % 90 === 0) {
                if (Math.round((angleDeg - pAngleDegSnapped) / 90) % 2 === 0) x2 = x1;
                else y2 = y1;
            }
        }
        let x = x1;
        let y = y1;
        let dX = x2 - x1;
        let dY = y2 - y1;
        // --- 1:1 ratio ---
        if (shapeObj.type !== "line" && shapeObj.isFixedRatio) {
            let r11 = (0, _bb.BB).rotate(shapeObj.x1, shapeObj.y1, shapeObj.angleRad / Math.PI * 180);
            let r21 = (0, _bb.BB).rotate(shapeObj.x2, shapeObj.y2, shapeObj.angleRad / Math.PI * 180);
            let rx = r11.x;
            let ry = r11.y;
            let rdX = r21.x - r11.x;
            let rdY = r21.y - r11.y;
            if (Math.abs(rdX) < Math.abs(rdY)) rdY = Math.abs(rdX) * (rdY < 0 ? -1 : 1);
            else rdX = Math.abs(rdY) * (rdX < 0 ? -1 : 1);
            r21.x = rx + rdX;
            r21.y = ry + rdY;
            r11 = (0, _bb.BB).rotate(r11.x, r11.y, -shapeObj.angleRad / Math.PI * 180);
            r21 = (0, _bb.BB).rotate(r21.x, r21.y, -shapeObj.angleRad / Math.PI * 180);
            x1 = r11.x;
            y1 = r11.y;
            x2 = r21.x;
            y2 = r21.y;
            x = x1;
            y = y1;
            dX = x2 - x1;
            dY = y2 - y1;
        }
        // outwards modifier
        if (shapeObj.isOutwards) {
            x -= dX;
            y -= dY;
            dX *= 2;
            dY *= 2;
            x1 = x;
            y1 = y;
            x2 = x + dX;
            y2 = y + dY;
        }
        let p1;
        let p2;
        if (shapeObj.type === "line") {
            // rounded
            const x1r = Math.round(x1);
            const y1r = Math.round(y1);
            const x2r = Math.round(x2);
            const y2r = Math.round(y2);
            // floored
            const x1f = Math.floor(x1);
            const y1f = Math.floor(y1);
            const x2f = Math.floor(x2);
            const y2f = Math.floor(y2);
            if (lineWidth % 2 === 0) {
                if (y1r === y2r) {
                    p1 = {
                        x: x1f,
                        y: y1r
                    };
                    p2 = {
                        x: x2f,
                        y: y2r
                    };
                    if (x1f < x2f) p2.x += 1;
                    else p1.x += 1;
                } else if (x1r === x2r) {
                    p1 = {
                        x: x1r,
                        y: y1f
                    };
                    p2 = {
                        x: x2r,
                        y: y2f
                    };
                    if (y1f < y2f) p2.y += 1;
                    else p1.y += 1;
                } else {
                    p1 = {
                        x: x1,
                        y: y1
                    };
                    p2 = {
                        x: x2,
                        y: y2
                    };
                }
            } else {
                p1 = {
                    x: x1f,
                    y: y1f
                };
                p2 = {
                    x: x2f,
                    y: y2f
                };
                if (y1f === y2f) {
                    if (x1f < x2f) p2.x += 1;
                    else p1.x += 1;
                    p1.y += 0.5;
                    p2.y += 0.5;
                } else if (x1f === x2f) {
                    if (y1f < y2f) p2.y += 1;
                    else p1.y += 1;
                    p1.x += 0.5;
                    p2.x += 0.5;
                } else {
                    p1.x = x1;
                    p1.y = y1;
                    p2.x = x2;
                    p2.y = y2;
                }
            }
            p1 = (0, _bb.BB).rotate(p1.x, p1.y, shapeObj.angleRad / Math.PI * 180);
            p2 = (0, _bb.BB).rotate(p2.x, p2.y, shapeObj.angleRad / Math.PI * 180);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        } else if (shapeObj.type === "rect") {
            // floored
            const x1f1 = Math.floor(x1);
            const y1f1 = Math.floor(y1);
            const x2f1 = Math.floor(x2);
            const y2f1 = Math.floor(y2);
            if (angleDeg % 90 === 0) {
                if (shapeObj.fillRgb) {
                    if (x1 % 1 === 0) x1 += 1;
                    if (y1 % 1 === 0) y1 += 1;
                    if (x2 % 1 === 0) x2 += 1;
                    if (y2 % 1 === 0) y2 += 1;
                    p1 = {
                        x: x1 < x2 ? x1f1 : x2f1,
                        y: y1 < y2 ? y1f1 : y2f1
                    };
                    p2 = {
                        x: Math.ceil((x1 < x2 ? x2 : x1) - p1.x),
                        y: Math.ceil((y1 < y2 ? y2 : y1) - p1.y)
                    };
                    p2.x = p1.x + p2.x;
                    p2.y = p1.y + p2.y;
                } else if (lineWidth % 2 === 0) {
                    p1 = {
                        x: x1f1,
                        y: y1f1
                    };
                    p2 = {
                        x: x2f1,
                        y: y2f1
                    };
                } else {
                    p1 = {
                        x: x1f1 + 0.5,
                        y: y1f1 + 0.5
                    };
                    p2 = {
                        x: x2f1 + 0.5,
                        y: y2f1 + 0.5
                    };
                }
            } else {
                p1 = {
                    x: x1,
                    y: y1
                };
                p2 = {
                    x: x2,
                    y: y2
                };
            }
            p1 = (0, _bb.BB).rotate(p1.x, p1.y, shapeObj.angleRad / Math.PI * 180);
            p2 = (0, _bb.BB).rotate(p2.x, p2.y, shapeObj.angleRad / Math.PI * 180);
            p2.x = p2.x - p1.x;
            p2.y = p2.y - p1.y;
            if (shapeObj.fillRgb) ctx.fillRect(p1.x, p1.y, p2.x, p2.y);
            else ctx.strokeRect(p1.x, p1.y, p2.x, p2.y);
        } else {
            p1 = (0, _bb.BB).rotate(x1, y1, shapeObj.angleRad / Math.PI * 180);
            p2 = (0, _bb.BB).rotate(x2, y2, shapeObj.angleRad / Math.PI * 180);
            x = p1.x;
            y = p1.y;
            dX = p2.x - p1.x;
            dY = p2.y - p1.y;
            ctx.beginPath();
            ctx.ellipse(x + dX / 2, y + dY / 2, Math.abs(dX / 2), Math.abs(dY / 2), 0, 0, Math.PI * 2);
            if (shapeObj.fillRgb) ctx.fill();
            else ctx.stroke();
        }
        ctx.restore();
    } else throw new Error("unknown shape");
}

},{"../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fEvNY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Draw text on a canvas.
 *
 * @param canvas
 * @param p
 * @returns - bounds. coords relative to p.x p.y
 */ parcelHelpers.export(exports, "renderText", ()=>renderText);
var _bb = require("../../bb/bb");
function renderText(canvas, p) {
    // always at least a space. so bounds aren't just a dot
    let textStr = p.textStr === "" ? " " : p.textStr;
    // --- create el ---
    // create an actual dom element. figure out where exactly each letter is positioned.
    // that way multiline is feasible. canvas can't do multiline or text-align
    let outer = (0, _bb.BB).el({
        css: {
            position: "fixed",
            left: "0",
            top: "0",
            width: "100000px",
            fontSize: p.size + "px",
            lineHeight: p.lineHeight ? p.lineHeight + "px" : "default"
        }
    });
    let div = (0, _bb.BB).el({
        parent: outer,
        css: {
            display: "inline-block",
            textAlign: p.align ? p.align : "left",
            fontFamily: p.font ? p.font : "sans-serif",
            fontSize: p.size + "px",
            fontWeight: p.isBold ? "bold" : "normal",
            fontStyle: p.isItalic ? "italic" : "normal",
            lineHeight: p.lineHeight ? p.lineHeight + "px" : "default",
            opacity: "0",
            pointerEvents: "none"
        }
    });
    let spanStr = "";
    let replaceObj = {
        "\n": "<br>",
        " ": "&nbsp;",
        "	": "&nbsp;&nbsp;&nbsp;&nbsp;"
    };
    for(let i = 0; i < textStr.length; i++){
        if (textStr[i] === "\n") {
            div.appendChild((0, _bb.BB).el({
                tagName: "span",
                textContent: spanStr,
                css: {
                    whiteSpace: "pre"
                }
            }));
            spanStr = "";
            div.appendChild((0, _bb.BB).el({
                tagName: "br"
            }));
            continue;
        }
        spanStr += textStr[i].replace("	", "    ");
    }
    div.appendChild((0, _bb.BB).el({
        tagName: "span",
        textContent: spanStr,
        css: {
            whiteSpace: "pre"
        }
    }));
    document.body.appendChild(outer);
    // --- determine bounds ---
    let bounds = {
        x0: 99999999,
        y0: 99999999,
        x1: 0,
        y1: 0
    };
    for(let i1 = 0; i1 < div.children.length; i1++){
        let el = div.children[i1];
        bounds.x0 = Math.min(bounds.x0, el.offsetLeft);
        bounds.y0 = Math.min(bounds.y0, el.offsetTop);
        bounds.x1 = Math.max(bounds.x1, el.offsetLeft + el.offsetWidth);
        bounds.y1 = Math.max(bounds.y1, el.offsetTop + el.offsetHeight);
    }
    // --- draw ---
    let ctx = canvas.getContext("2d");
    ctx.save();
    let font = [];
    if (p.isItalic) font.push("italic");
    if (p.isBold) font.push("bold");
    font.push(p.size + "px " + (p.font ? p.font : "sans-serif"));
    ctx.font = font.join(" ");
    ctx.fillStyle = p.color ? p.color : "#000";
    let x = p.x;
    let y = p.y;
    if (p.align === "right") x += -bounds.x1 + bounds.x0;
    if (p.align === "center") x += (-bounds.x1 + bounds.x0) / 2;
    ctx.translate(p.x, p.y);
    ctx.rotate(p.angleRad ? -p.angleRad : 0);
    ctx.translate(-p.x, -p.y);
    ctx.translate(x, y);
    // fill
    for(let i2 = 0; i2 < div.children.length; i2++){
        let el1 = div.children[i2];
        //ctx.fillText(el.innerText, 0, 0);
        ctx.fillText(el1.innerText, el1.offsetLeft, el1.offsetTop);
    }
    if (p.isDebug) {
        ctx.lineWidth = 1;
        ctx.strokeRect(0, -p.size * 0.85, bounds.x1, bounds.y1);
        ctx.restore();
        ctx.fillRect(p.x - 1, p.y - 1, 2, 2);
    } else ctx.restore();
    document.body.removeChild(outer);
    return {
        x: x - p.x,
        y: y - p.y - p.size * 0.85,
        width: bounds.x1 - bounds.x0,
        height: bounds.y1 - bounds.y0
    };
}

},{"../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Yf6D":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "drawProject", ()=>drawProject);
var _bb = require("../../bb/bb");
function drawProject(project, factor) {
    let resultCanvas = (0, _bb.BB).canvas(Math.max(1, Math.round(project.width * factor)), Math.max(1, Math.round(project.height * factor)));
    let ctx = resultCanvas.getContext("2d");
    ctx.save();
    if (factor > 1) ctx.imageSmoothingEnabled = false;
    for(let i = 0; i < project.layers.length; i++){
        if (project.layers[i].opacity === 0) continue;
        ctx.globalAlpha = project.layers[i].opacity;
        ctx.globalCompositeOperation = project.layers[i].mixModeStr ? project.layers[i].mixModeStr : "source-over";
        ctx.drawImage(project.layers[i].image, 0, 0, resultCanvas.width, resultCanvas.height);
    }
    ctx.restore();
    return resultCanvas;
}

},{"../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jhX3B":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Input processor for gradient tool.
 * Coordinates are in canvas space.
 * angleRad is the angle of the canvas.
 */ parcelHelpers.export(exports, "GradientTool", ()=>GradientTool);
parcelHelpers.export(exports, "drawGradient", ()=>drawGradient);
var _bb = require("../../bb/bb");
class GradientTool {
    // ---- public ----
    constructor(p){
        this.onGradient = p.onGradient;
    }
    onDown(x, y, angleRad) {
        this.downX = x;
        this.downY = y;
        this.downAngleRad = angleRad;
    }
    onMove(x, y) {
        this.onGradient(false, this.downX, this.downY, x, y, this.downAngleRad);
    }
    onUp(x, y) {
        this.onGradient(true, this.downX, this.downY, x, y, this.downAngleRad);
    }
}
function drawGradient(ctx, gradientObj) {
    ctx.save();
    let x1 = gradientObj.x1;
    let y1 = gradientObj.y1;
    let x2 = gradientObj.x2;
    let y2 = gradientObj.y2;
    if (gradientObj.doSnap) {
        const angleDeg = gradientObj.angleRad * 180 / Math.PI;
        let r1 = (0, _bb.BB).rotate(x1, y1, gradientObj.angleRad / Math.PI * 180);
        let r2 = (0, _bb.BB).rotate(x2, y2, gradientObj.angleRad / Math.PI * 180);
        let pAngleDeg = (0, _bb.BB).pointsToAngleDeg(r1, r2) + 90;
        let pAngleDegSnapped = Math.round(pAngleDeg / 45) * 45;
        let rotated = (0, _bb.BB).rotateAround({
            x: x1,
            y: y1
        }, {
            x: x2,
            y: y2
        }, pAngleDegSnapped - pAngleDeg);
        x2 = rotated.x;
        y2 = rotated.y;
        // needs to be perfect if p1->p2 aligns with canvas x- or y-axis
        if ((angleDeg + pAngleDegSnapped) % 90 === 0) {
            if (Math.round((angleDeg - pAngleDegSnapped) / 90) % 2 === 0) x2 = x1;
            else y2 = y1;
        }
    }
    let baseColor = gradientObj.color1;
    if (gradientObj.isEraser && gradientObj.doLockAlpha) baseColor = {
        r: 255,
        g: 255,
        b: 255
    };
    let color1 = (0, _bb.BB).copyObj(baseColor);
    color1.a = gradientObj.opacity;
    let color2 = (0, _bb.BB).copyObj(baseColor);
    color2.a = 0;
    if (gradientObj.isReversed) {
        const temp = color1;
        color1 = color2;
        color2 = temp;
    }
    let gradient;
    if (gradientObj.type === "linear") {
        gradient = ctx.createLinearGradient(x1, y1, x2, y2);
        gradient.addColorStop(0, (0, _bb.BB).ColorConverter.toRgbaStr(color1));
        gradient.addColorStop(1, (0, _bb.BB).ColorConverter.toRgbaStr(color2));
    } else if (gradientObj.type === "linear-mirror") {
        const d = {
            x: x2 - x1,
            y: y2 - y1
        };
        gradient = ctx.createLinearGradient(x1 - d.x, y1 - d.y, x2, y2);
        gradient.addColorStop(0, (0, _bb.BB).ColorConverter.toRgbaStr(color2));
        gradient.addColorStop(0.5, (0, _bb.BB).ColorConverter.toRgbaStr(color1));
        gradient.addColorStop(1, (0, _bb.BB).ColorConverter.toRgbaStr(color2));
    } else if (gradientObj.type === "radial") {
        const r = (0, _bb.BB).Vec2.dist({
            x: x1,
            y: y1
        }, {
            x: x2,
            y: y2
        });
        gradient = ctx.createRadialGradient(x1, y1, 0, x1, y1, r);
        gradient.addColorStop(0, (0, _bb.BB).ColorConverter.toRgbaStr(color1));
        gradient.addColorStop(1, (0, _bb.BB).ColorConverter.toRgbaStr(color2));
    }
    ctx.fillStyle = gradient;
    if (gradientObj.isEraser) ctx.globalCompositeOperation = "destination-out";
    if (gradientObj.doLockAlpha) ctx.globalCompositeOperation = "source-atop";
    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.restore();
}

},{"../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6hHQR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "translateBlending", ()=>translateBlending);
var _language = require("../../language/language");
function translateBlending(blendMode) {
    if (!blendMode) return (0, _language.LANG)("layers-blend-normal");
    const codes = {
        "source-over": "layers-blend-normal",
        "darken": "layers-blend-darken",
        "multiply": "layers-blend-multiply",
        "color-burn": "layers-blend-color-burn",
        "lighten": "layers-blend-lighten",
        "screen": "layers-blend-screen",
        "color-dodge": "layers-blend-color-dodge",
        "overlay": "layers-blend-overlay",
        "soft-light": "layers-blend-soft-light",
        "hard-light": "layers-blend-hard-light",
        "difference": "layers-blend-difference",
        "exclusion": "layers-blend-exclusion",
        "hue": "layers-blend-hue",
        "saturation": "layers-blend-saturation",
        "color": "layers-blend-color",
        "luminosity": "layers-blend-luminosity"
    };
    if (!(blendMode in codes)) throw new Error("unknown blend mode");
    return (0, _language.LANG)(codes[blendMode]);
}

},{"../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kspFU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Overlay for KlCanvasWorkspace.
 * - brush circle
 * - eyedropper circle
 * - compass needle (rotation hud)
 */ parcelHelpers.export(exports, "WorkspaceSvgOverlay", ()=>WorkspaceSvgOverlay);
var _bb = require("../../bb/bb");
class WorkspaceSvgOverlay {
    // ---- public ----
    constructor(p){
        this.rootElement = (0, _bb.BB).createSvg({
            elementType: "svg",
            width: "" + p.width,
            height: "" + p.height
        });
        (0, _bb.BB).css(this.rootElement, {
            position: "absolute",
            left: "0",
            top: "0",
            pointerEvents: "none",
            userSelect: "none"
        });
        //brush circles
        this.brushCircleOuter = (0, _bb.BB).createSvg({
            elementType: "circle",
            r: "10",
            stroke: "rgba(0,0,0,0.7)",
            "stroke-width": "1",
            fill: "none"
        });
        this.brushCircleInner = (0, _bb.BB).createSvg({
            elementType: "circle",
            r: "9",
            stroke: "rgba(255,255,255,0.7)",
            "stroke-width": "1",
            fill: "none"
        });
        this.rootElement.append(this.brushCircleOuter, this.brushCircleInner);
        //color picker preview circle
        this.pickerPreviewBorder = (0, _bb.BB).createSvg({
            elementType: "circle",
            r: "47",
            stroke: "black",
            "stroke-width": "22",
            fill: "none"
        });
        this.pickerPreviewBorder.style.opacity = "0";
        this.pickerPreviewCol = (0, _bb.BB).createSvg({
            elementType: "circle",
            r: "47",
            stroke: "black",
            "stroke-width": "20",
            fill: "none"
        });
        this.pickerPreviewCol.style.opacity = "0";
        this.rootElement.append(this.pickerPreviewBorder, this.pickerPreviewCol);
        //rotation compass
        this.compassSize = 30;
        this.compass = (0, _bb.BB).createSvg({
            elementType: "g",
            transform: "translate(" + p.width / 2 + ", " + p.height / 2 + ")"
        });
        (0, _bb.BB).css(this.compass, {
            transition: "opacity 0.25s ease-in-out",
            opacity: "0"
        });
        this.compassInner = (0, _bb.BB).createSvg({
            elementType: "g",
            transform: "rotate(45)"
        });
        this.compassBaseCircle = (0, _bb.BB).createSvg({
            elementType: "circle",
            fill: "rgba(0,0,0,0.9)",
            stroke: "none",
            cx: "0",
            cy: "0",
            r: "" + this.compassSize
        });
        this.compassLineCircle = (0, _bb.BB).createSvg({
            elementType: "circle",
            fill: "none",
            stroke: "rgba(255,255,255,0.75)",
            "stroke-width": "1",
            cx: "0",
            cy: "0",
            r: "" + this.compassSize * 0.9
        });
        this.compassUpperTriangle = (0, _bb.BB).createSvg({
            elementType: "path",
            fill: "#f00",
            stroke: "none",
            d: "M -" + this.compassSize * 0.25 + ",0 " + this.compassSize * 0.25 + ",0 0,-" + this.compassSize * 0.9 + " z"
        });
        this.compassLowerTriangle = (0, _bb.BB).createSvg({
            elementType: "path",
            fill: "#fff",
            stroke: "none",
            d: "M -" + this.compassSize * 0.25 + ",0 " + this.compassSize * 0.25 + ",0 0," + this.compassSize * 0.9 + " z"
        });
        this.compassInner.append(this.compassBaseCircle, this.compassLineCircle, this.compassUpperTriangle, this.compassLowerTriangle);
        this.compass.append(this.compassInner);
        this.rootElement.append(this.compass);
    }
    getElement() {
        return this.rootElement;
    }
    setSize(width, height) {
        this.rootElement.setAttribute("width", "" + width);
        this.rootElement.setAttribute("height", "" + height);
        this.compass.setAttribute("transform", "translate(" + width / 2 + ", " + height / 2 + ")");
    }
    updateCursor(p) {
        if ("x" in p) {
            this.brushCircleOuter.setAttribute("cx", "" + p.x);
            this.brushCircleInner.setAttribute("cx", "" + p.x);
        }
        if ("y" in p) {
            this.brushCircleOuter.setAttribute("cy", "" + p.y);
            this.brushCircleInner.setAttribute("cy", "" + p.y);
        }
        if ("radius" in p) {
            this.brushCircleOuter.setAttribute("r", "" + Math.max(0, p.radius));
            this.brushCircleInner.setAttribute("r", "" + Math.max(0, p.radius - 1));
        }
        if ("isVisible" in p) {
            this.brushCircleOuter.style.opacity = p.isVisible ? "1" : "0";
            this.brushCircleInner.style.opacity = p.isVisible ? "1" : "0";
        }
    }
    updateColorPreview(p) {
        if ("x" in p) {
            this.pickerPreviewCol.setAttribute("cx", "" + p.x);
            this.pickerPreviewBorder.setAttribute("cx", "" + p.x);
        }
        if ("y" in p) {
            this.pickerPreviewCol.setAttribute("cy", "" + p.y);
            this.pickerPreviewBorder.setAttribute("cy", "" + p.y);
        }
        if ("color" in p) {
            this.pickerPreviewCol.setAttribute("stroke", (0, _bb.BB).ColorConverter.toRgbStr(p.color));
            let borderColor = (0, _bb.BB).testIsWhiteBestContrast(p.color) ? "rgba(255,255,255,0.5)" : "rgba(0,0,0,0.5)";
            this.pickerPreviewBorder.setAttribute("stroke", borderColor);
        }
        if ("isVisible" in p) {
            this.pickerPreviewCol.style.opacity = p.isVisible ? "1" : "0";
            this.pickerPreviewBorder.style.opacity = p.isVisible ? "1" : "0";
        }
    }
    updateCompass(p) {
        if ("angleDeg" in p) {
            this.compassInner.setAttribute("transform", "rotate(" + p.angleDeg + ")");
            this.compassLineCircle.style.opacity = p.angleDeg % 90 === 0 ? "1" : "0";
        }
        if ("isVisible" in p) this.compass.style.opacity = p.isVisible ? "1" : "0";
    }
}

},{"../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ep4xw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Work area that displays the KlCanvas.
 * - pan, zoom, rotate (also via multi-touch)
 * - input modes: drawing, hand, pick, fill, text // transform, select
 * - drawing input events
 * - view change events
 * - eyedropper input events (pick)
 * - draws cursor, eyedropper overlay
 *
 * subscribes to klCanvas changes
 * listens to kl history for changes
 * and you can manually trigger redraw
 */ parcelHelpers.export(exports, "KlCanvasWorkspace", ()=>KlCanvasWorkspace);
var _bb = require("../../bb/bb");
var _workspaceSvgOverlay = require("./workspace-svg-overlay");
var _klHistory = require("../history/kl-history");
// @ts-ignore
var _cursorPickerPng = require("url:~/src/app/img/ui/cursor-picker.png");
var _cursorPickerPngDefault = parcelHelpers.interopDefault(_cursorPickerPng);
// @ts-ignore
var _cursorZoomEwPng = require("url:~/src/app/img/ui/cursor-zoom-ew.png");
var _cursorZoomEwPngDefault = parcelHelpers.interopDefault(_cursorZoomEwPng);
// @ts-ignore
var _cursorFillPng = require("url:~/src/app/img/ui/cursor-fill.png");
var _cursorFillPngDefault = parcelHelpers.interopDefault(_cursorFillPng);
// @ts-ignore
var _cursorTextPng = require("url:~/src/app/img/ui/cursor-text.png");
var _cursorTextPngDefault = parcelHelpers.interopDefault(_cursorTextPng);
var _kl = require("../kl");
const MIN_SCALE = 0.0625;
const MAX_SCALE = 64;
let TMode;
(function(TMode) {
    TMode[TMode["Draw"] = 0] = "Draw";
    TMode[TMode["Hand"] = 1] = "Hand";
    TMode[TMode["HandGrabbing"] = 2] = "HandGrabbing";
    TMode[TMode["Pick"] = 3] = "Pick";
    TMode[TMode["Zoom"] = 4] = "Zoom";
    TMode[TMode["Rotate"] = 5] = "Rotate";
    TMode[TMode["Rotating"] = 6] = "Rotating";
    TMode[TMode["Fill"] = 7] = "Fill";
    TMode[TMode["Gradient"] = 8] = "Gradient";
    TMode[TMode["Text"] = 9] = "Text";
    TMode[TMode["Shape"] = 10] = "Shape";
})(TMode || (TMode = {}));
const ANIMATION_SPEED = 0.3; // rate of transition towards targetTransform
class KlCanvasWorkspace {
    getRenderedTransform() {
        // rounded x & y so canvas is less blurry.
        const result = this.renderedTransformObj;
        result.x = this.highResTransformObj.x;
        result.y = this.highResTransformObj.y;
        result.scale = this.highResTransformObj.scale;
        result.angle = this.highResTransformObj.angle;
        if (result.angle % (Math.PI / 2) === 0 && result.scale % 1 === 0) {
            result.x = Math.round(result.x);
            result.y = Math.round(result.y);
        }
        return result;
    }
    updateChangeListener() {
        this.klCanvas.addChangeListener(()=>{
            this.lastRenderedState = -1;
            this.reqFrame();
        });
    }
    updateCursor(modeInt, doForce) {
        if (modeInt === this.currentMode && !doForce) return;
        const oldMode = this.currentMode;
        this.currentMode = modeInt;
        this.lastRenderedState = -1;
        if (this.currentMode === TMode.Draw) this.rootEl.style.cursor = "crosshair";
        else if (this.currentMode === TMode.Hand) this.rootEl.style.cursor = "grab";
        else if (this.currentMode === TMode.HandGrabbing) this.rootEl.style.cursor = "grabbing";
        else if (this.currentMode === TMode.Pick) this.rootEl.style.cursor = "url('" + (0, _cursorPickerPngDefault.default) + "') 0 15, crosshair";
        else if (this.currentMode === TMode.Zoom) this.rootEl.style.cursor = "url('" + (0, _cursorZoomEwPngDefault.default) + "') 7 7, zoom-in";
        else if (this.currentMode === TMode.Rotate) this.rootEl.style.cursor = "grab";
        else if (this.currentMode === TMode.Rotating) this.rootEl.style.cursor = "grabbing";
        else if (this.currentMode === TMode.Fill) this.rootEl.style.cursor = "url('" + (0, _cursorFillPngDefault.default) + "') 1 12, crosshair";
        else if (this.currentMode === TMode.Gradient) this.rootEl.style.cursor = "crosshair";
        else if (this.currentMode === TMode.Text) this.rootEl.style.cursor = "url('" + (0, _cursorTextPngDefault.default) + "') 1 12, crosshair";
        else if (this.currentMode === TMode.Shape) this.rootEl.style.cursor = "crosshair";
        if ([
            TMode.Draw,
            TMode.Pick,
            TMode.Fill,
            TMode.Text,
            TMode.Shape
        ].includes(this.globalMode)) {
            const oldIsHand = [
                TMode.Hand,
                TMode.HandGrabbing
            ].includes(oldMode);
            const currentIsHand = [
                TMode.Hand,
                TMode.HandGrabbing
            ].includes(this.currentMode);
            if (!oldIsHand && currentIsHand) this.mainDoubleTapper.setAllowedPointerTypeArr([
                "mouse",
                "pen",
                "touch"
            ]);
            if (oldIsHand && !currentIsHand) this.mainDoubleTapper.setAllowedPointerTypeArr([
                "touch"
            ]);
        }
        if (this.currentMode !== TMode.Pick) this.svgOverlay.updateColorPreview({
            isVisible: false
        });
    }
    /**
     * returns false if no change of zoom
     * @param stepNum
     * @param centerX
     * @param centerY
     * @private
     */ internalZoomByStep(stepNum, centerX, centerY) {
        const step = Math.log2(this.targetTransformObj.scale);
        let newStep = step / Math.abs(stepNum);
        newStep += stepNum > 0 ? 1 : -1;
        newStep = Math.round(newStep);
        newStep *= Math.abs(stepNum);
        const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, Math.pow(2, newStep)));
        //has zoomed?
        if (newScale === this.targetTransformObj.scale) return false;
        const effectiveFactor = newScale / this.targetTransformObj.scale;
        this.targetTransformObj.scale = newScale;
        let matrix = (0, _bb.BB).Matrix.getIdentity();
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createTranslationMatrix(centerX, centerY));
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createScaleMatrix(effectiveFactor));
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createTranslationMatrix(-centerX, -centerY));
        let origin = [
            this.targetTransformObj.x,
            this.targetTransformObj.y,
            0,
            1
        ];
        origin = (0, _bb.BB).Matrix.multiplyMatrixAndPoint(matrix, origin);
        this.targetTransformObj.x = origin[0];
        this.targetTransformObj.y = origin[1];
        this.transformIsDirty = true;
        return true;
    }
    /**
     * mixes two transform objects. modifies A
     * @param transformA
     * @param transformB
     * @param blendFactor 0 -> A, 1 -> B
     * @private
     */ mixTransformObj(transformA, transformB, blendFactor) {
        if (transformA.angle === transformB.angle) {
            transformA.scale = (0, _bb.BB).mix(transformA.scale, transformB.scale, blendFactor);
            transformA.x = (0, _bb.BB).mix(transformA.x, transformB.x, blendFactor);
            transformA.y = (0, _bb.BB).mix(transformA.y, transformB.y, blendFactor);
            transformA.angle = (0, _bb.BB).mix(transformA.angle, transformB.angle, blendFactor);
            return;
        }
        const w = this.klCanvas.getWidth();
        const h = this.klCanvas.getHeight();
        // --- determine centerPosA, centerPosB ---
        const centerPosA = this.canvasToWorkspaceCoord({
            x: w / 2,
            y: h / 2
        }, transformA);
        const centerPosB = this.canvasToWorkspaceCoord({
            x: w / 2,
            y: h / 2
        }, transformB);
        // --- centerPosMixed ---
        transformA.x = (0, _bb.BB).mix(centerPosA.x, centerPosB.x, blendFactor);
        transformA.y = (0, _bb.BB).mix(centerPosA.y, centerPosB.y, blendFactor);
        // --- scale and angle ---
        transformA.scale = (0, _bb.BB).mix(transformA.scale, transformB.scale, blendFactor);
        transformA.angle = (0, _bb.BB).mix(transformA.angle, transformB.angle, blendFactor);
        // --- x and y ---
        const mixedPos = this.canvasToWorkspaceCoord({
            x: -w / 2,
            y: -h / 2
        }, transformA);
        transformA.x = mixedPos.x;
        transformA.y = mixedPos.y;
    }
    render() {
        if (this.doResizeCanvas) {
            this.doResizeCanvas = false;
            this.renderTargetCanvas.width = this.renderWidth;
            this.renderTargetCanvas.height = this.renderHeight;
        }
        this.renderContext(this.renderTargetCtx);
    }
    /**
     * is the gray background that surrounds canvas visible?
     * @private
     */ testBgVisible() {
        //bring workspace points (corners of workspace) into canvas coordinate system
        //then check if any corner point is outside of the canvas -> that means the bg is visible
        const workspacePointArr = [
            [
                0,
                0
            ],
            [
                this.renderWidth,
                0
            ],
            [
                this.renderWidth,
                this.renderHeight
            ],
            [
                0,
                this.renderHeight
            ]
        ];
        const art = this.getRenderedTransform();
        //setup transformation matrix
        let matrix = (0, _bb.BB).Matrix.getIdentity();
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createScaleMatrix(1 / art.scale));
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createRotationMatrix(-art.angle));
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createTranslationMatrix(-art.x, -art.y));
        //transform points, then test if outside of canvas
        for(let i = 0; i < workspacePointArr.length; i++){
            let coords = [
                workspacePointArr[i][0],
                workspacePointArr[i][1],
                0,
                1
            ];
            coords = (0, _bb.BB).Matrix.multiplyMatrixAndPoint(matrix, coords);
            if (!(0 <= coords[0] && coords[0] <= this.klCanvas.getWidth() && 0 <= coords[1] && coords[1] <= this.klCanvas.getHeight())) //if not inside -> bg visible
            return true;
        }
        return false;
    }
    renderContext(ctx) {
        const w = this.klCanvas.getWidth();
        const h = this.klCanvas.getHeight();
        const art = this.getRenderedTransform();
        if (art.scale >= 4 || art.scale === 1 && art.angle === 0) ctx.imageSmoothingEnabled = false;
        else {
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = "low"; // art.scale >= 1 ? 'low' : 'medium';
        }
        //ctx.imageSmoothingEnabled = false;
        //renderTargetCtx.globalCompositeOperation  = 'multiply';
        ctx.save();
        {
            if (this.bgVisible) {
                ctx.fillStyle = "rgb(158,158,158)"; // 'rgb(185,185,185)';
                ctx.fillRect(0, 0, this.renderWidth, this.renderHeight);
            } else ctx.clearRect(0, 0, this.renderWidth, this.renderHeight);
            if (this.bgVisible) {
                ctx.save();
                ctx.translate(art.x, art.y);
                ctx.scale(art.scale, art.scale);
                ctx.rotate(art.angle);
                ctx.imageSmoothingEnabled = false;
                //outline
                const borderSize = 1;
                ctx.globalAlpha = 0.2;
                ctx.drawImage(this.emptyCanvas, -borderSize / art.scale, -borderSize / art.scale, w + borderSize * 2 / art.scale, h + borderSize * 2 / art.scale);
                ctx.globalAlpha = 1;
                //erase
                ctx.globalCompositeOperation = "destination-out";
                ctx.drawImage(this.emptyCanvas, 0, 0, w, h);
                ctx.restore();
            }
            /*const region = new Path2D();
            region.rect(80, 10, 20, 130);
            ctx.clip(region);*/ ctx.translate(art.x, art.y);
            ctx.scale(art.scale, art.scale);
            ctx.rotate(art.angle);
            const layerArr = this.klCanvas.getLayersFast();
            for(let i = 0; i < layerArr.length; i++)if (layerArr[i].opacity > 0) {
                ctx.globalAlpha = layerArr[i].opacity;
                ctx.globalCompositeOperation = layerArr[i].mixModeStr;
                if (layerArr[i].canvas.compositeObj) {
                    if (this.compositeCanvas.width !== layerArr[i].canvas.width || this.compositeCanvas.height !== layerArr[i].canvas.height) {
                        this.compositeCanvas.width = layerArr[i].canvas.width;
                        this.compositeCanvas.height = layerArr[i].canvas.height;
                    } else this.compositeCtx.clearRect(0, 0, this.compositeCanvas.width, this.compositeCanvas.height);
                    this.compositeCtx.drawImage(layerArr[i].canvas, 0, 0);
                    layerArr[i].canvas.compositeObj.draw(this.compositeCtx);
                    ctx.drawImage(this.compositeCanvas, 0, 0, w, h);
                } else ctx.drawImage(layerArr[i].canvas, 0, 0, w, h);
            }
            ctx.globalAlpha = 1;
        }
        ctx.restore();
        // rotation hud
        if (TMode.Rotate === this.currentMode || TMode.Rotating === this.currentMode) this.svgOverlay.updateCompass({
            isVisible: true,
            angleDeg: art.angle / Math.PI * 180
        });
        else this.svgOverlay.updateCompass({
            isVisible: false
        });
    }
    workspaceToCanvasCoord(p) {
        const art = this.getRenderedTransform();
        let matrix = (0, _bb.BB).Matrix.getIdentity();
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createScaleMatrix(1 / art.scale));
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createRotationMatrix(-art.angle));
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createTranslationMatrix(-art.x, -art.y));
        let coords = [
            p.x,
            p.y,
            0,
            1
        ];
        coords = (0, _bb.BB).Matrix.multiplyMatrixAndPoint(matrix, coords);
        return {
            x: coords[0],
            y: coords[1]
        };
    }
    canvasToWorkspaceCoord(p, transformObj) {
        let matrix = (0, _bb.BB).Matrix.getIdentity();
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createTranslationMatrix(transformObj.x, transformObj.y));
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createRotationMatrix(transformObj.angle));
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createScaleMatrix(transformObj.scale));
        let coords = [
            p.x,
            p.y,
            0,
            1
        ];
        coords = (0, _bb.BB).Matrix.multiplyMatrixAndPoint(matrix, coords);
        return {
            x: coords[0],
            y: coords[1]
        };
    }
    snapAngleRad(angleRad, snapDegIncrement, maxDistDeg) {
        let angleDeg = angleRad * 180 / Math.PI;
        const modDeg = Math.abs(angleDeg % snapDegIncrement);
        const dist = Math.min(modDeg, snapDegIncrement - modDeg);
        if (dist <= maxDistDeg) angleDeg = Math.round(angleDeg / snapDegIncrement) * snapDegIncrement;
        return angleDeg / 180 * Math.PI;
    }
    /**
     * angle always in range [-PI, PI]
     * @param angleRad
     * @private
     */ minimizeAngleRad(angleRad) {
        angleRad = angleRad % (2 * Math.PI);
        if (angleRad > Math.PI) angleRad -= 2 * Math.PI;
        else if (angleRad < -Math.PI) angleRad += 2 * Math.PI;
        return angleRad;
    }
    resetInputProcessor() {
        this.currentInputProcessor = null;
        this.updateCursor(this.globalMode);
        this.reqFrame(true);
    }
    reqFrame(doRedrawCanvas) {
        this.animationFrameRequested = true;
        if (doRedrawCanvas) this.lastRenderedState = -1;
    }
    updateLoop() {
        window.requestAnimationFrame(()=>this.updateLoop());
        const newState = (0, _klHistory.klHistory).getState();
        const doRender = this.lastRenderedState < newState;
        //handle variable framerate
        const nowTime = performance.now();
        const elapsedFrames = (nowTime - this.lastRenderTime) * 60 / 1000; //how many frames elapsed since last render if fps were 60fps
        this.lastRenderTime = nowTime;
        if (this.animationFrameRequested || doRender) {
            this.animationFrameRequested = false;
            this.checkChange(elapsedFrames);
        }
    }
    checkChange(elapsedFrames) {
        const newState = (0, _klHistory.klHistory).getState();
        const doRender = this.lastRenderedState < newState || this.highResTransformObj.scale !== this.targetTransformObj.scale || this.highResTransformObj.x !== this.targetTransformObj.x || this.highResTransformObj.y !== this.targetTransformObj.y;
        //update transform
        if (!this.doAnimateTranslate && (this.highResTransformObj.scale === this.targetTransformObj.scale || Math.abs(this.highResTransformObj.scale - this.targetTransformObj.scale) < 0.008 * this.targetTransformObj.scale)) {
            this.highResTransformObj.scale = this.targetTransformObj.scale;
            this.highResTransformObj.x = this.targetTransformObj.x;
            this.highResTransformObj.y = this.targetTransformObj.y;
            this.highResTransformObj.angle = this.targetTransformObj.angle;
            if (this.transformIsDirty) {
                this.transformIsDirty = false;
                this.bgVisible = this.testBgVisible();
            }
            this.svgOverlay.updateCursor({
                radius: this.brushRadius * this.highResTransformObj.scale
            });
        } else if ((this.highResTransformObj.x === this.targetTransformObj.x || Math.abs(this.highResTransformObj.x - this.targetTransformObj.x) < 0.5) && (this.highResTransformObj.y === this.targetTransformObj.y || Math.abs(this.highResTransformObj.y - this.targetTransformObj.y) < 0.5) && (this.highResTransformObj.scale === this.targetTransformObj.scale || Math.abs(this.highResTransformObj.scale - this.targetTransformObj.scale) < 0.008 * this.targetTransformObj.scale)) {
            this.highResTransformObj.scale = this.targetTransformObj.scale;
            this.highResTransformObj.x = this.targetTransformObj.x;
            this.highResTransformObj.y = this.targetTransformObj.y;
            this.highResTransformObj.angle = this.targetTransformObj.angle;
            this.doAnimateTranslate = false;
            if (this.transformIsDirty) {
                this.transformIsDirty = false;
                this.bgVisible = this.testBgVisible();
            }
            this.svgOverlay.updateCursor({
                radius: this.brushRadius * this.highResTransformObj.scale
            });
        } else {
            this.reqFrame(); //probably needs another frame
            const blendFactor = Math.min(1, ANIMATION_SPEED * elapsedFrames);
            this.mixTransformObj(this.highResTransformObj, this.targetTransformObj, blendFactor);
            this.bgVisible = true; // spare yourself the calculation
            this.svgOverlay.updateCursor({
                radius: this.brushRadius * this.highResTransformObj.scale
            });
        }
        if (this.pointer && this.currentMode == TMode.Draw && !this.usesCssCursor) this.svgOverlay.updateCursor({
            x: this.pointer.x,
            y: this.pointer.y,
            isVisible: true
        });
        else this.svgOverlay.updateCursor({
            isVisible: false
        });
        if (doRender) {
            //console.log('scale', this.renderedTransform.scale, 'x', this.renderedTransform.x, 'y', this.renderedTransform.y);
            this.lastRenderedState = newState;
            const start = performance.now();
            this.render();
            this.renderTime = (0, _bb.BB).mix(this.renderTime, performance.now() - start, 0.05);
        }
        doRender;
    }
    // ---- public ----
    constructor(p){
        const _this = this;
        this.rootEl = (0, _bb.BB).el({
            css: {
                position: "absolute",
                left: "0",
                right: "0",
                top: "0",
                bottom: "0",
                cursor: "crosshair",
                userSelect: "none",
                colorScheme: "only light"
            }
        });
        this.klCanvas = p.klCanvas;
        this.onViewChange = p.onViewChange;
        this.renderTargetCanvas = (0, _bb.BB).canvas(p.width, p.height);
        this.renderTargetCtx = this.renderTargetCanvas.getContext("2d");
        this.renderWidth = p.width;
        this.renderHeight = p.height;
        this.compositeCanvas = (0, _bb.BB).canvas(1, 1); // for drawing klcanvas layer composite
        this.compositeCtx = this.compositeCanvas.getContext("2d");
        this.doResizeCanvas = false;
        this.oldTransformObj = null;
        this.targetTransformObj = {
            x: 0,
            y: 0,
            scale: 1,
            angle: 0
        };
        this.highResTransformObj = {
            x: 0,
            y: 0,
            scale: 1,
            angle: 0
        };
        this.renderedTransformObj = {
            x: null,
            y: null,
            scale: null,
            angle: null
        };
        this.cursorPos = {
            x: 0,
            y: 0
        };
        this.usesCssCursor = false;
        this.bgVisible = true;
        this.transformIsDirty = true;
        this.doAnimateTranslate = true;
        this.svgOverlay = new (0, _workspaceSvgOverlay.WorkspaceSvgOverlay)({
            width: p.width,
            height: p.height
        });
        (0, _bb.BB).css(this.renderTargetCanvas, {
            userSelect: "none",
            pointerEvents: "none"
        });
        (0, _bb.BB).createCheckerDataUrl(8, (url)=>{
            this.renderTargetCanvas.style.background = "url(" + url + ")";
        });
        this.rootEl.appendChild(this.renderTargetCanvas);
        this.rootEl.appendChild(this.svgOverlay.getElement());
        (0, _bb.BB).addEventListener(this.rootEl, "touchend", (e)=>{
            e.preventDefault();
            return false;
        });
        (0, _bb.BB).addEventListener(this.rootEl, "contextmenu", (e)=>{
            e.preventDefault();
            return false;
        });
        (0, _bb.BB).addEventListener(this.rootEl, "dragstart", (e)=>{
            e.preventDefault();
            return false;
        });
        this.emptyCanvas = (0, _bb.BB).canvas(1, 1);
        {
            const ctx = this.emptyCanvas.getContext("2d");
            ctx.fillRect(0, 0, 1, 1);
        }
        this.keyListener = new (0, _bb.BB).KeyListener({
            onDown: (keyStr, event, comboStr, isRepeat)=>{
                if ((0, _kl.KL).dialogCounter.get() > 0 || (0, _bb.BB).isInputFocused(true)) return;
                if (keyStr === "alt") event.preventDefault();
                if (isRepeat) return;
                if (this.currentInputProcessor) this.currentInputProcessor.onKeyDown(keyStr, event, comboStr, isRepeat);
                else {
                    if ([
                        TMode.Draw,
                        TMode.Pick,
                        TMode.Fill,
                        TMode.Gradient,
                        TMode.Text,
                        TMode.Shape
                    ].includes(this.globalMode) && comboStr === "space") {
                        this.currentInputProcessor = this.inputProcessorObj.spaceHand;
                        this.currentInputProcessor.onKeyDown(keyStr, event, comboStr, isRepeat);
                        return;
                    }
                    if ([
                        TMode.Draw,
                        TMode.Hand,
                        TMode.Fill,
                        TMode.Gradient,
                        TMode.Text,
                        TMode.Shape
                    ].includes(this.globalMode) && comboStr === "alt") {
                        this.currentInputProcessor = this.inputProcessorObj.altPicker;
                        this.currentInputProcessor.onKeyDown(keyStr, event, comboStr, isRepeat);
                        return;
                    }
                    if ([
                        "r",
                        "shift+r"
                    ].includes(comboStr)) {
                        this.currentInputProcessor = this.inputProcessorObj.rotate;
                        this.currentInputProcessor.onKeyDown(keyStr, event, comboStr, isRepeat);
                        return;
                    }
                    if ("z" === comboStr) {
                        this.currentInputProcessor = this.inputProcessorObj.zoom;
                        this.currentInputProcessor.onKeyDown(keyStr, event, comboStr, isRepeat);
                        return;
                    }
                }
            },
            onUp: (keyStr, event, oldComboStr)=>{
                // prevent menu bar in Firefox
                if (keyStr === "alt") event.preventDefault();
                if (this.currentInputProcessor) this.currentInputProcessor.onKeyUp(keyStr, event, oldComboStr);
            }
        });
        this.updateChangeListener();
        this.currentMode = TMode.Draw;
        this.globalMode = TMode.Draw;
        this.renderTime = 0;
        this.lastDrawEvent = null;
        this.linetoolProcessor = new (0, _bb.BB).EventChain.LinetoolProcessor({
            onDraw: (event)=>{
                const getMatrix = ()=>{
                    const art = this.getRenderedTransform();
                    let matrix = (0, _bb.BB).Matrix.getIdentity();
                    matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createScaleMatrix(1 / art.scale));
                    matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createRotationMatrix(-art.angle));
                    matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createTranslationMatrix(-art.x, -art.y));
                    return matrix;
                };
                if (event.type === "line" && !this.lastDrawEvent) {
                    const matrix = getMatrix();
                    let coords = [
                        event.x1,
                        event.y1,
                        0,
                        1
                    ];
                    coords = (0, _bb.BB).Matrix.multiplyMatrixAndPoint(matrix, coords);
                    this.lastDrawEvent = {
                        x: coords[0],
                        y: coords[1],
                        pressure: event.pressure1
                    };
                    return;
                }
                if ("x" in event || "x0" in event) {
                    const matrix1 = getMatrix();
                    if ("x" in event) {
                        let coords1 = [
                            event.x,
                            event.y,
                            0,
                            1
                        ];
                        coords1 = (0, _bb.BB).Matrix.multiplyMatrixAndPoint(matrix1, coords1);
                        event.x = coords1[0];
                        event.y = coords1[1];
                    }
                    if ("x0" in event) {
                        event.x0 = this.lastDrawEvent.x;
                        event.y0 = this.lastDrawEvent.y;
                        event.pressure0 = this.lastDrawEvent.pressure;
                        let coords2 = [
                            event.x1,
                            event.y1,
                            0,
                            1
                        ];
                        coords2 = (0, _bb.BB).Matrix.multiplyMatrixAndPoint(matrix1, coords2);
                        event.x1 = coords2[0];
                        event.y1 = coords2[1];
                        this.lastDrawEvent = {
                            x: event.x1,
                            y: event.y1,
                            pressure: event.pressure1
                        };
                    }
                }
                if ([
                    "down",
                    "move"
                ].includes(event.type)) this.lastDrawEvent = event;
                p.onDraw(event);
            }
        });
        this.pointer = null;
        this.isDrawing = false;
        this.inputProcessorObj = {
            draw: {
                onPointer: (val)=>{
                    this.reqFrame();
                    this.updateCursor(TMode.Draw);
                    const comboStr = this.keyListener.getComboStr();
                    const event = {
                        scale: this.highResTransformObj.scale
                    };
                    event.shiftIsPressed = comboStr === "shift";
                    event.pressure = val.pressure;
                    event.isCoalesced = !!val.isCoalesced;
                    if (val.type === "pointerdown") {
                        this.isDrawing = true;
                        event.type = "down";
                    } else if (val.button) event.type = "move";
                    else if (val.type === "pointerup") {
                        this.isDrawing = false;
                        event.type = "up";
                        this.linetoolProcessor.process(event);
                        this.resetInputProcessor();
                        return;
                    } else return;
                    event.x = val.relX;
                    event.y = val.relY;
                    this.linetoolProcessor.process(event);
                },
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{},
                onKeyUp: (keyStr, event, oldComboStr)=>{}
            },
            fill: {
                onPointer: (event)=>{
                    this.reqFrame();
                    this.updateCursor(TMode.Fill);
                    if (event.type === "pointerdown") {
                        const coord = this.workspaceToCanvasCoord({
                            x: event.relX,
                            y: event.relY
                        });
                        p.onFill(Math.floor(coord.x), Math.floor(coord.y));
                    } else if (event.type === "pointerup") {
                        this.resetInputProcessor();
                        return;
                    }
                },
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{},
                onKeyUp: (keyStr, event, oldComboStr)=>{}
            },
            gradient: {
                onPointer: (event)=>{
                    this.reqFrame();
                    this.updateCursor(TMode.Gradient);
                    const coord = this.workspaceToCanvasCoord({
                        x: event.relX,
                        y: event.relY
                    });
                    if (event.type === "pointerdown") {
                        this.isDrawing = true;
                        p.onGradient("down", coord.x, coord.y, this.renderedTransformObj.angle);
                    } else if (event.type === "pointermove") p.onGradient("move", coord.x, coord.y, this.renderedTransformObj.angle);
                    else if (event.type === "pointerup") {
                        this.isDrawing = false;
                        p.onGradient("up", coord.x, coord.y, this.renderedTransformObj.angle);
                        this.resetInputProcessor();
                    }
                },
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{},
                onKeyUp: (keyStr, event, oldComboStr)=>{}
            },
            text: {
                onPointer: (event)=>{
                    this.reqFrame();
                    this.updateCursor(TMode.Text);
                    if (event.type === "pointerdown") {
                        const coord = this.workspaceToCanvasCoord({
                            x: event.relX,
                            y: event.relY
                        });
                        p.onText(Math.floor(coord.x), Math.floor(coord.y), this.renderedTransformObj.angle);
                    } else if (event.type === "pointerup") {
                        this.resetInputProcessor();
                        return;
                    }
                },
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{},
                onKeyUp: (keyStr, event, oldComboStr)=>{}
            },
            shape: {
                onPointer: (event)=>{
                    this.reqFrame();
                    this.updateCursor(TMode.Shape);
                    const coord = this.workspaceToCanvasCoord({
                        x: event.relX,
                        y: event.relY
                    });
                    if (event.type === "pointerdown") {
                        this.isDrawing = true;
                        p.onShape("down", coord.x, coord.y, this.renderedTransformObj.angle);
                    } else if (event.type === "pointermove") p.onShape("move", coord.x, coord.y, this.renderedTransformObj.angle);
                    else if (event.type === "pointerup") {
                        this.isDrawing = false;
                        p.onShape("up", coord.x, coord.y, this.renderedTransformObj.angle);
                        this.resetInputProcessor();
                    }
                },
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{},
                onKeyUp: (keyStr, event, oldComboStr)=>{}
            },
            hand: {
                onPointer: (event)=>{
                    this.updateCursor(TMode.Hand);
                    if ([
                        "left",
                        "middle"
                    ].includes(event.button)) {
                        this.updateCursor(TMode.HandGrabbing);
                        this.targetTransformObj.x += event.dX;
                        this.targetTransformObj.y += event.dY;
                        this.highResTransformObj = JSON.parse(JSON.stringify(this.targetTransformObj));
                        this.doAnimateTranslate = false;
                        this.transformIsDirty = true;
                        this.reqFrame(true);
                    } else if (event.type === "pointerup") this.resetInputProcessor();
                },
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{},
                onKeyUp: (keyStr, event, oldComboStr)=>{}
            },
            spaceHand: {
                onPointer: (event)=>{
                    this.updateCursor(TMode.Hand);
                    if ([
                        "left",
                        "middle"
                    ].includes(event.button)) {
                        this.updateCursor(TMode.HandGrabbing);
                        this.targetTransformObj.x += event.dX;
                        this.targetTransformObj.y += event.dY;
                        this.highResTransformObj = JSON.parse(JSON.stringify(this.targetTransformObj));
                        this.doAnimateTranslate = false;
                        this.transformIsDirty = true;
                        this.reqFrame(true);
                    }
                },
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{
                    if (comboStr !== "space") this.resetInputProcessor();
                    else this.updateCursor(TMode.Hand);
                },
                onKeyUp: (keyStr, event, oldComboStr)=>{
                    this.resetInputProcessor();
                }
            },
            zoom: {
                onPointer: (event)=>{
                    this.updateCursor(TMode.Zoom);
                    if (event.button === "left" && !event.isCoalesced && event.dX != 0) {
                        const offsetX = event.pageX - event.relX;
                        const offsetY = event.pageY - event.relY;
                        this.internalZoomByStep(event.dX / 175, event.downPageX - offsetX, event.downPageY - offsetY);
                        this.highResTransformObj = JSON.parse(JSON.stringify(this.targetTransformObj));
                        this.lastRenderedState = -1;
                        this.reqFrame();
                        this.onViewChange({
                            changed: [
                                "scale"
                            ],
                            angle: this.targetTransformObj.angle,
                            scale: this.targetTransformObj.scale
                        });
                    }
                },
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{
                    if (comboStr !== "z") this.resetInputProcessor();
                    else this.updateCursor(TMode.Zoom);
                },
                onKeyUp: (keyStr, event, oldComboStr)=>{
                    this.resetInputProcessor();
                }
            },
            picker: {
                onPointer: (event)=>{
                    this.updateCursor(TMode.Pick);
                    if ([
                        "left",
                        "right"
                    ].includes(event.button) && !event.isCoalesced || event.type === "pointerup") {
                        const coord = this.workspaceToCanvasCoord({
                            x: event.relX,
                            y: event.relY
                        });
                        const pickedColor = this.klCanvas.getColorAt(coord.x, coord.y);
                        p.onPick(pickedColor, event.type === "pointerup");
                        this.svgOverlay.updateColorPreview({
                            x: event.relX,
                            y: event.relY,
                            color: pickedColor,
                            isVisible: event.type !== "pointerup"
                        });
                        if (event.type === "pointerup") this.resetInputProcessor();
                    }
                },
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{},
                onKeyUp: (keyStr, event, oldComboStr)=>{}
            },
            altPicker: {
                onPointer: (event)=>{
                    this.updateCursor(TMode.Pick);
                    if ([
                        "left",
                        "right"
                    ].includes(event.button) && !event.isCoalesced || event.type === "pointerup") {
                        const coord = this.workspaceToCanvasCoord({
                            x: event.relX,
                            y: event.relY
                        });
                        const pickedColor = this.klCanvas.getColorAt(coord.x, coord.y);
                        p.onPick(pickedColor, event.type === "pointerup");
                        this.svgOverlay.updateColorPreview({
                            x: event.relX,
                            y: event.relY,
                            color: pickedColor,
                            isVisible: event.type !== "pointerup"
                        });
                    }
                },
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{
                    if (comboStr !== "alt") this.resetInputProcessor();
                    else this.updateCursor(TMode.Pick);
                },
                onKeyUp: (keyStr, event, oldComboStr)=>{
                    this.resetInputProcessor();
                }
            },
            rotate: {
                onPointer: (event)=>{
                    this.updateCursor(event.button === "left" ? TMode.Rotating : TMode.Rotate);
                    if (event.type === "pointerdown" && event.button === "left") this.oldTransformObj = JSON.parse(JSON.stringify(this.targetTransformObj));
                    else if (event.button === "left" && !event.isCoalesced && this.oldTransformObj) {
                        const offsetX = event.pageX - event.relX;
                        const offsetY = event.pageY - event.relY;
                        //rotation done around center
                        const centerObj = {
                            x: this.renderWidth / 2,
                            y: this.renderHeight / 2
                        };
                        const startAngleRad = (0, _bb.BB).Vec2.angle(centerObj, {
                            x: event.downPageX - offsetX,
                            y: event.downPageY - offsetY
                        });
                        const angleRad = (0, _bb.BB).Vec2.angle(centerObj, {
                            x: event.pageX - offsetX,
                            y: event.pageY - offsetY
                        });
                        let dAngleRad = angleRad - startAngleRad;
                        //apply angle
                        this.targetTransformObj = JSON.parse(JSON.stringify(this.oldTransformObj));
                        this.targetTransformObj.angle += dAngleRad;
                        if (this.keyListener.isPressed("shift")) {
                            this.targetTransformObj.angle = Math.round(this.targetTransformObj.angle / Math.PI * 8) * Math.PI / 8; //snap the angle to 45/2 degs
                            dAngleRad = this.targetTransformObj.angle - this.oldTransformObj.angle;
                        }
                        this.targetTransformObj.angle = this.minimizeAngleRad(this.targetTransformObj.angle);
                        //rotate transform.xy
                        let matrix = (0, _bb.BB).Matrix.getIdentity();
                        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createTranslationMatrix(centerObj.x, centerObj.y));
                        //matrix = BB.Matrix.multiplyMatrices(matrix, BB.Matrix.createScaleMatrix(effectiveFactor));
                        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createRotationMatrix(dAngleRad));
                        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createTranslationMatrix(-centerObj.x, -centerObj.y));
                        //matrix = multiplyMatrices(matrix, createTranslationMatrix(val.x - val.startX, val.y - val.startY));
                        let origin = [
                            this.targetTransformObj.x,
                            this.targetTransformObj.y,
                            0,
                            1
                        ];
                        origin = (0, _bb.BB).Matrix.multiplyMatrixAndPoint(matrix, origin);
                        this.targetTransformObj.x = origin[0];
                        this.targetTransformObj.y = origin[1];
                        this.highResTransformObj = JSON.parse(JSON.stringify(this.targetTransformObj));
                        this.transformIsDirty = true;
                        this.lastRenderedState = -1;
                        this.reqFrame();
                        this.onViewChange({
                            changed: [
                                "angle"
                            ],
                            scale: this.targetTransformObj.scale,
                            angle: this.targetTransformObj.angle
                        });
                    }
                },
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{
                    if ([
                        "r",
                        "r+shift",
                        "shift+r",
                        "r+left",
                        "r+right",
                        "r+left+right",
                        "r+right+left",
                        "r+up"
                    ].includes(comboStr)) this.updateCursor(TMode.Rotate);
                    else this.resetInputProcessor();
                },
                onKeyUp: (keyStr, event, oldComboStr)=>{
                    const comboStr = this.keyListener.getComboStr();
                    if ([
                        "r",
                        "r+shift",
                        "shift+r",
                        "r+left",
                        "r+right",
                        "r+left+right",
                        "r+right+left",
                        "r+up"
                    ].includes(comboStr)) this.updateCursor(TMode.Rotate);
                    else this.resetInputProcessor();
                }
            }
        };
        this.currentInputProcessor = null;
        this.angleIsExtraSticky = false;
        this.pinchZoomer = new (0, _bb.BB).EventChain.PinchZoomer({
            onPinch: (event)=>{
                if (event.type === "move") {
                    if (!this.oldTransformObj) {
                        this.oldTransformObj = JSON.parse(JSON.stringify(this.targetTransformObj));
                        this.angleIsExtraSticky = this.targetTransformObj.angle % (Math.PI / 2) === 0;
                    }
                    this.targetTransformObj = JSON.parse(JSON.stringify(this.oldTransformObj));
                    event.scale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, this.targetTransformObj.scale * event.scale)) / this.targetTransformObj.scale;
                    this.targetTransformObj.scale *= event.scale;
                    this.targetTransformObj.angle += event.angleRad;
                    this.targetTransformObj.angle = this.minimizeAngleRad(this.snapAngleRad(this.targetTransformObj.angle, 90, this.angleIsExtraSticky ? 12 : 4));
                    if (this.targetTransformObj.angle % (Math.PI / 2) !== 0) this.angleIsExtraSticky = false;
                    //targetTransformObj.angle = minimizeAngleRad(snapAngleRad(targetTransformObj.angle, 90, 7));
                    event.angleRad = this.targetTransformObj.angle - this.oldTransformObj.angle;
                    //calc translation
                    {
                        let matrix = (0, _bb.BB).Matrix.getIdentity();
                        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createTranslationMatrix(event.relX, event.relY));
                        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createScaleMatrix(event.scale));
                        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createRotationMatrix(event.angleRad));
                        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createTranslationMatrix(-event.relX, -event.relY));
                        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createTranslationMatrix(event.relX - event.downRelX, event.relY - event.downRelY));
                        let origin = [
                            this.targetTransformObj.x,
                            this.targetTransformObj.y,
                            0,
                            1
                        ];
                        origin = (0, _bb.BB).Matrix.multiplyMatrixAndPoint(matrix, origin);
                        this.targetTransformObj.x = origin[0];
                        this.targetTransformObj.y = origin[1];
                    }
                    this.highResTransformObj = (0, _bb.BB).copyObj(this.targetTransformObj);
                    //if (event.scale !== 1) {
                    this.onViewChange({
                        changed: [
                            "scale",
                            "angle"
                        ],
                        scale: this.targetTransformObj.scale,
                        angle: this.targetTransformObj.angle
                    });
                    //}
                    this.reqFrame();
                    this.transformIsDirty = true;
                    this.lastRenderedState = -1;
                } else if (event.type === "end") this.oldTransformObj = null;
            }
        });
        const onDoubleTap = (event)=>{
            if (_this.fitView()) {
                this.lastRenderedState = -1;
                this.reqFrame();
            } else {
                // zoom 2 steps further
                let didZoom = this.internalZoomByStep(2, event.relX, event.relY);
                if (didZoom) this.onViewChange({
                    changed: [
                        "scale"
                    ],
                    angle: this.targetTransformObj.angle,
                    scale: this.targetTransformObj.scale
                });
                //updateCursor(TMode.Draw, true);
                this.lastRenderedState = -1;
            }
        };
        this.mainDoubleTapper = new (0, _bb.BB).EventChain.DoubleTapper({
            onDoubleTap
        });
        this.middleDoubleTapper = new (0, _bb.BB).EventChain.DoubleTapper({
            onDoubleTap
        });
        this.middleDoubleTapper.setAllowedButtonArr([
            "middle"
        ]);
        this.twoFingerTap = new (0, _bb.BB).EventChain.NFingerTapper({
            fingers: 2,
            onTap: ()=>{
                p.onUndo();
            }
        });
        this.threeFingerTap = new (0, _bb.BB).EventChain.NFingerTapper({
            fingers: 3,
            onTap: ()=>{
                p.onRedo();
            }
        });
        this.pointerEventChain = new (0, _bb.BB).EventChain.EventChain({
            chainArr: [
                this.twoFingerTap,
                this.threeFingerTap,
                this.mainDoubleTapper,
                this.middleDoubleTapper,
                this.pinchZoomer,
                new (0, _bb.BB).EventChain.OnePointerLimiter(),
                new (0, _bb.BB).EventChain.CoalescedExploder()
            ]
        });
        this.pointerEventChain.setChainOut((event)=>{
            this.cursorPos.x = event.relX;
            this.cursorPos.y = event.relY;
            if (event.type === "pointerup" && event.pointerType === "touch") {
                this.pointer = null;
                this.lastRenderedState = -1;
                this.reqFrame();
            } else {
                if (!this.pointer) this.pointer = {
                    x: 0,
                    y: 0
                };
                this.pointer.x = event.relX;
                this.pointer.y = event.relY;
            }
            if (this.currentInputProcessor) this.currentInputProcessor.onPointer(event);
            else {
                let comboStr = this.keyListener.getComboStr();
                if (this.globalMode === TMode.Draw) {
                    if ([
                        "",
                        "shift",
                        "ctrl"
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "left") {
                        this.currentInputProcessor = this.inputProcessorObj.draw;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ""
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "right") {
                        this.currentInputProcessor = this.inputProcessorObj.picker;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ""
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "middle") {
                        this.currentInputProcessor = this.inputProcessorObj.hand;
                        this.currentInputProcessor.onPointer(event);
                    } else {
                        this.updateCursor(TMode.Draw);
                        this.reqFrame();
                    }
                } else if (this.globalMode === TMode.Hand) {
                    if (event.type === "pointerdown" && [
                        "left",
                        "middle"
                    ].includes(event.button)) {
                        this.currentInputProcessor = this.inputProcessorObj.hand;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ""
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "right") {
                        this.currentInputProcessor = this.inputProcessorObj.picker;
                        this.currentInputProcessor.onPointer(event);
                    } else this.updateCursor(TMode.Hand);
                } else if (this.globalMode === TMode.Pick) {
                    if (event.type === "pointerdown" && [
                        "left",
                        "right"
                    ].includes(event.button)) {
                        this.currentInputProcessor = this.inputProcessorObj.picker;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ""
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "middle") {
                        this.currentInputProcessor = this.inputProcessorObj.hand;
                        this.currentInputProcessor.onPointer(event);
                    } else this.updateCursor(TMode.Pick);
                } else if (this.globalMode === TMode.Fill) {
                    if (event.type === "pointerdown" && event.button === "left") {
                        this.currentInputProcessor = this.inputProcessorObj.fill;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ""
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "right") {
                        this.currentInputProcessor = this.inputProcessorObj.picker;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ""
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "middle") {
                        this.currentInputProcessor = this.inputProcessorObj.hand;
                        this.currentInputProcessor.onPointer(event);
                    } else {
                        this.updateCursor(TMode.Fill);
                        this.reqFrame();
                    }
                } else if (this.globalMode === TMode.Gradient) {
                    if ([
                        "",
                        "shift",
                        "ctrl"
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "left") {
                        this.currentInputProcessor = this.inputProcessorObj.gradient;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ""
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "right") {
                        this.currentInputProcessor = this.inputProcessorObj.picker;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ""
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "middle") {
                        this.currentInputProcessor = this.inputProcessorObj.hand;
                        this.currentInputProcessor.onPointer(event);
                    } else {
                        this.updateCursor(TMode.Gradient);
                        this.reqFrame();
                    }
                } else if (this.globalMode === TMode.Text) {
                    if (event.type === "pointerdown" && event.button === "left") {
                        this.currentInputProcessor = this.inputProcessorObj.text;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ""
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "right") {
                        this.currentInputProcessor = this.inputProcessorObj.picker;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ""
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "middle") {
                        this.currentInputProcessor = this.inputProcessorObj.hand;
                        this.currentInputProcessor.onPointer(event);
                    } else {
                        this.updateCursor(TMode.Text);
                        this.reqFrame();
                    }
                } else if (this.globalMode === TMode.Shape) {
                    if ([
                        "",
                        "shift",
                        "ctrl"
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "left") {
                        this.currentInputProcessor = this.inputProcessorObj.shape;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ""
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "right") {
                        this.currentInputProcessor = this.inputProcessorObj.picker;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ""
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "middle") {
                        this.currentInputProcessor = this.inputProcessorObj.hand;
                        this.currentInputProcessor.onPointer(event);
                    } else {
                        this.updateCursor(TMode.Shape);
                        this.reqFrame();
                    }
                }
            }
        });
        //prevent ctrl scroll -> zooming page
        (0, _bb.BB).addEventListener(this.rootEl, "wheel", (event)=>{
            event.preventDefault();
        });
        setTimeout(()=>{
            this.pointerListener = new (0, _bb.BB).PointerListener({
                target: this.rootEl,
                fixScribble: true,
                onPointer: (e)=>{
                    if (e.type === "pointerdown" && e.button === "middle") try {
                        e.eventPreventDefault();
                    } catch (e1) {}
                    // prevent manual slider input keeping focus on iPad
                    if (e.type === "pointerdown") (0, _bb.BB).unfocusAnyInput();
                    /*if (e.type === 'pointermove') {
                        BB.throwOut(JSON.stringify(e));
                    }*/ this.pointerEventChain.chainIn(e);
                },
                onWheel: (wheelEvent)=>{
                    if (this.isDrawing) return;
                    this.reqFrame();
                    let didZoom = this.internalZoomByStep(-wheelEvent.deltaY / (this.keyListener.isPressed("shift") ? 8 : 2), wheelEvent.relX, wheelEvent.relY);
                    if (didZoom) this.onViewChange({
                        changed: [
                            "scale"
                        ],
                        angle: this.targetTransformObj.angle,
                        scale: this.targetTransformObj.scale
                    });
                    //updateCursor(TMode.Draw, true);
                    this.lastRenderedState = -1;
                },
                onEnterLeave: (isOver)=>{
                    if (!isOver) {
                        if (!this.isDrawing) {
                            this.pointer = null;
                            this.lastRenderedState = -1;
                        }
                    }
                },
                maxPointers: 4
            });
        }, 1);
        this.brushRadius = 1;
        this.animationFrameRequested = false;
        //setup rendering
        this.lastRenderedState = -2;
        this.lastRenderTime = performance.now();
        window.requestAnimationFrame(()=>this.updateLoop());
        this.resetView();
    }
    getElement() {
        return this.rootEl;
    }
    setCanvas(klC) {
        this.klCanvas = klC;
        this.lastDrawEvent = null;
        this.resetView();
        this.updateChangeListener();
        this.lastRenderedState = -1;
        this.reqFrame();
    }
    /**
     * set size of workspace area in pixels
     * @param width
     * @param height
     */ setSize(width, height) {
        const oldWidth = this.renderWidth;
        const oldHeight = this.renderHeight;
        if (width === oldWidth && height === oldHeight) return;
        this.doResizeCanvas = true;
        this.renderWidth = width;
        this.renderHeight = height;
        this.svgOverlay.setSize(width, height);
        this.targetTransformObj.x += (width - oldWidth) / 2;
        this.targetTransformObj.y += (height - oldHeight) / 2;
        this.highResTransformObj.x = this.targetTransformObj.x;
        this.highResTransformObj.y = this.targetTransformObj.y;
        this.bgVisible = this.testBgVisible();
        this.lastRenderedState = -1;
        this.reqFrame();
    }
    setMode(modeStr) {
        //only sets the base mode
        if (modeStr === "draw") {
            this.globalMode = TMode.Draw;
            this.mainDoubleTapper.setAllowedPointerTypeArr([
                "touch"
            ]);
        }
        if (modeStr === "fill") {
            this.globalMode = TMode.Fill;
            this.mainDoubleTapper.setAllowedPointerTypeArr([
                "touch"
            ]);
        }
        if (modeStr === "gradient") {
            this.globalMode = TMode.Gradient;
            this.mainDoubleTapper.setAllowedPointerTypeArr([
                "touch"
            ]);
        }
        if (modeStr === "text") {
            this.globalMode = TMode.Text;
            this.mainDoubleTapper.setAllowedPointerTypeArr([
                "touch"
            ]);
        }
        if (modeStr === "shape") {
            this.globalMode = TMode.Shape;
            this.mainDoubleTapper.setAllowedPointerTypeArr([
                "touch"
            ]);
        }
        if (modeStr === "hand") {
            this.globalMode = TMode.Hand;
            this.mainDoubleTapper.setAllowedPointerTypeArr([
                "mouse",
                "pen",
                "touch"
            ]);
        }
        if (modeStr === "pick") {
            this.globalMode = TMode.Pick;
            this.mainDoubleTapper.setAllowedPointerTypeArr([
                "touch"
            ]);
        }
    }
    getMode() {
        if (this.globalMode === TMode.Draw) return "draw";
        if (this.globalMode === TMode.Fill) return "fill";
        if (this.globalMode === TMode.Gradient) return "gradient";
        if (this.globalMode === TMode.Text) return "text";
        if (this.globalMode === TMode.Shape) return "shape";
        if (this.globalMode === TMode.Hand) return "hand";
        if (this.globalMode === TMode.Pick) return "pick";
    }
    setEnabled(b) {
    // todo
    }
    setCursorSize(diameter) {
        this.brushRadius = diameter / 2;
        this.svgOverlay.updateCursor({
            radius: this.brushRadius * this.highResTransformObj.scale
        });
        if (this.pointer === null) {
            clearTimeout(this.hideBrushCursorTimeout);
            this.svgOverlay.updateCursor({
                x: this.renderWidth / 2,
                y: this.renderHeight / 2,
                isVisible: true
            });
            // @ts-ignore
            this.hideBrushCursorTimeout = setTimeout(()=>{
                if (this.pointer !== null) return;
                this.svgOverlay.updateCursor({
                    isVisible: false
                });
            }, 500);
        }
    }
    zoomByStep(stepNum) {
        if (!this.internalZoomByStep(stepNum, this.renderWidth / 2, this.renderHeight / 2)) return;
        this.lastRenderedState = -1;
        this.reqFrame();
        this.onViewChange({
            changed: [
                "scale"
            ],
            angle: this.targetTransformObj.angle,
            scale: this.targetTransformObj.scale
        });
    }
    resetView(doAnimate) {
        this.targetTransformObj.scale = 1;
        this.targetTransformObj.angle = 0;
        this.targetTransformObj.x = (this.renderWidth - this.klCanvas.getWidth()) / 2;
        this.targetTransformObj.y = (this.renderHeight - this.klCanvas.getHeight()) / 2;
        if (!doAnimate) this.highResTransformObj = JSON.parse(JSON.stringify(this.targetTransformObj));
        else {
            this.doAnimateTranslate = true;
            this.transformIsDirty = true;
        }
        this.bgVisible = this.testBgVisible();
        this.reqFrame();
        if (doAnimate) this.onViewChange({
            changed: [
                "scale",
                "angle"
            ],
            scale: this.targetTransformObj.scale,
            angle: this.targetTransformObj.angle
        });
    }
    /**
     * fit into view. center. snap angle. padding
     * returns true if transform changes
     */ fitView() {
        // determine new transform
        const newAngle = this.snapAngleRad(this.targetTransformObj.angle, 90, 90);
        //calc width and height of bounds
        const canvasPointsArr = [
            [
                0,
                0
            ],
            [
                this.klCanvas.getWidth(),
                0
            ],
            [
                this.klCanvas.getWidth(),
                this.klCanvas.getHeight()
            ],
            [
                0,
                this.klCanvas.getHeight()
            ],
            [
                this.klCanvas.getWidth() / 2,
                this.klCanvas.getHeight() / 2
            ]
        ];
        //setup transformation matrix
        let matrix = (0, _bb.BB).Matrix.getIdentity();
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createRotationMatrix(newAngle));
        //rotate points
        for(let i = 0; i < canvasPointsArr.length; i++){
            let coords = [
                canvasPointsArr[i][0],
                canvasPointsArr[i][1],
                0,
                1
            ];
            coords = (0, _bb.BB).Matrix.multiplyMatrixAndPoint(matrix, coords);
            canvasPointsArr[i][0] = coords[0];
            canvasPointsArr[i][1] = coords[1];
        }
        const boundsObj = {
            x0: null,
            y0: null,
            x1: null,
            y1: null
        };
        for(let i1 = 0; i1 < canvasPointsArr.length; i1++){
            if (boundsObj.x0 === null || canvasPointsArr[i1][0] < boundsObj.x0) boundsObj.x0 = canvasPointsArr[i1][0];
            if (boundsObj.y0 === null || canvasPointsArr[i1][1] < boundsObj.y0) boundsObj.y0 = canvasPointsArr[i1][1];
            if (boundsObj.x1 === null || canvasPointsArr[i1][0] > boundsObj.x1) boundsObj.x1 = canvasPointsArr[i1][0];
            if (boundsObj.y1 === null || canvasPointsArr[i1][1] > boundsObj.y1) boundsObj.y1 = canvasPointsArr[i1][1];
        }
        const boundsWidth = boundsObj.x1 - boundsObj.x0;
        const boundsHeight = boundsObj.y1 - boundsObj.y0;
        //fit bounds
        const padding = 0;
        const { width: fitWidth  } = (0, _bb.BB).fitInto(boundsWidth, boundsHeight, this.renderWidth - padding, this.renderHeight - padding, 1);
        //determine scale
        const factor = fitWidth / boundsWidth;
        const newTargetTransformObj = {
            angle: newAngle,
            x: this.renderWidth / 2 - (canvasPointsArr[4][0] - canvasPointsArr[0][0]) * factor,
            y: this.renderHeight / 2 - (canvasPointsArr[4][1] - canvasPointsArr[0][1]) * factor,
            scale: factor
        };
        if (newTargetTransformObj.angle === this.targetTransformObj.angle && Math.abs(newTargetTransformObj.x - this.targetTransformObj.x) < 0.0000000001 && Math.abs(newTargetTransformObj.y - this.targetTransformObj.y) < 0.0000000001 && newTargetTransformObj.scale === this.targetTransformObj.scale) return false;
        this.targetTransformObj = newTargetTransformObj;
        this.doAnimateTranslate = true;
        this.transformIsDirty = true;
        this.reqFrame();
        this.onViewChange({
            changed: [
                "scale",
                "angle"
            ],
            scale: this.targetTransformObj.scale,
            angle: this.targetTransformObj.angle
        });
        return true;
    }
    setAngle(angleDeg, isRelative) {
        //rotation done around center
        const centerObj = {
            x: this.renderWidth / 2,
            y: this.renderHeight / 2
        };
        const oldAngleRad = this.targetTransformObj.angle;
        const angleRad = angleDeg / 180 * Math.PI;
        if (isRelative) this.targetTransformObj.angle += angleRad;
        else this.targetTransformObj.angle = angleRad;
        this.targetTransformObj.angle = this.minimizeAngleRad(this.snapAngleRad(this.targetTransformObj.angle, 90, 4));
        //rotate transform.xy
        let matrix = (0, _bb.BB).Matrix.getIdentity();
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createTranslationMatrix(centerObj.x, centerObj.y));
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createRotationMatrix(this.targetTransformObj.angle - oldAngleRad));
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createTranslationMatrix(-centerObj.x, -centerObj.y));
        let origin = [
            this.targetTransformObj.x,
            this.targetTransformObj.y,
            0,
            1
        ];
        origin = (0, _bb.BB).Matrix.multiplyMatrixAndPoint(matrix, origin);
        this.targetTransformObj.x = origin[0];
        this.targetTransformObj.y = origin[1];
        this.highResTransformObj = JSON.parse(JSON.stringify(this.targetTransformObj));
        this.transformIsDirty = true;
        this.reqFrame(true);
    }
    /**
     * translate canvas by viewport pixels
     * @param tx
     * @param ty
     */ translateView(tx, ty) {
        const scale = 40;
        this.targetTransformObj.x += tx * scale;
        this.targetTransformObj.y += ty * scale;
        this.transformIsDirty = true;
        this.doAnimateTranslate = true;
        this.reqFrame(true);
    }
    getIsDrawing() {
        return this.isDrawing;
    }
    getScale() {
        return this.targetTransformObj.scale;
    }
    getAngleDeg() {
        return this.targetTransformObj.angle * 180 / Math.PI;
    }
    getMaxScale() {
        return MAX_SCALE;
    }
    getMinScale() {
        return MIN_SCALE;
    }
    requestFrame() {
        this.lastRenderedState = -1;
        this.reqFrame();
    }
    setLastDrawEvent(x, y, pressure) {
        if (x === null) {
            this.lastDrawEvent = null;
            return;
        }
        if (!this.lastDrawEvent) this.lastDrawEvent = {
            x: 0,
            y: 0,
            pressure: 0
        };
        this.lastDrawEvent.x = x;
        this.lastDrawEvent.y = y;
        this.lastDrawEvent.pressure = pressure;
    }
}

},{"../../bb/bb":"dcQKo","./workspace-svg-overlay":"kspFU","../history/kl-history":"klzEn","url:~/src/app/img/ui/cursor-picker.png":"dHXNL","url:~/src/app/img/ui/cursor-zoom-ew.png":"eO8zC","url:~/src/app/img/ui/cursor-fill.png":"1oaKL","url:~/src/app/img/ui/cursor-text.png":"bH5zQ","../kl":"8nmWp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dHXNL":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "cursor-picker.9d4082ab.png" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"eO8zC":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "cursor-zoom-ew.0898df17.png" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"1oaKL":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "cursor-fill.efbe9462.png" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"bH5zQ":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "cursor-text.1788d825.png" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"gRZnS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * preview of image with layers. can do mix modes and opacity.
 * creates a canvas.
 *
 * p = {
 *     width: 123,
 *     height: 123,
 *     layers: [// can be changed after the fact
 *         {
 *             image: Canvas,
 *             opacity: 1,
 *             mixModeStr: 'source-over'
 *         }
 *     ]
 * }
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "KlCanvasPreview", ()=>KlCanvasPreview);
var _bb = require("../../bb/bb");
function KlCanvasPreview(p) {
    const scale = p.width / p.layers[0].image.width;
    const width = scale > 1 ? p.layers[0].image.width : p.width;
    const height = scale > 1 ? p.layers[0].image.height : p.height;
    let canvas = (0, _bb.BB).canvas(width, height);
    canvas.style.backgroundImage = "url(" + (0, _bb.BB).createCheckerDataUrl(8) + ")";
    let ctx = canvas.getContext("2d");
    (0, _bb.BB).css(canvas, {
        width: "100%",
        height: "100%",
        imageRendering: scale > 1 ? "pixelated" : null
    });
    function render() {
        ctx.save();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for(let i = 0; i < p.layers.length; i++){
            ctx.globalAlpha = p.layers[i].opacity;
            ctx.globalCompositeOperation = p.layers[i].mixModeStr;
            if (canvas.width > p.layers[i].image.width) ctx.imageSmoothingEnabled = false;
            ctx.drawImage(p.layers[i].image, 0, 0, canvas.width, canvas.height);
        }
        ctx.restore();
    }
    setTimeout(render, 0);
    // --- interface ---
    this.getElement = function() {
        return canvas;
    };
    this.render = function() {
        render();
    };
}

},{"../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"izcGJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Free Transform UI
 * rotate, scale, translate
 *
 * - if rotation is multiple of 90¬∞ it will snap to pixels, to be more useful for pixel art
 * - when rotation goes from non-multiple of 90¬∞ to a multiple, it will snap position and width height to pixels
 * - transform.x, transform.y can sit between pixels (by 0.5) if width or height is odd number.
 *      - this is what complicates things
 * - if transform region small, corner grips move out of the way
 *
 * iX iY, iP.x, iP.y - i indicates image space
 * tX tY, tP.x, tP.y - t indicates transform space
 *
 * Not sure if can be used for navigable canvas. (especially if canvas rotates view)
 * Probably can't be extended for distort. Needs a different approach.
 *
 * --- DOM structure ---
 * rootEl {
 * 	transEl [
 * 		boundsEl
 * 		edges[]
 * 		corners[] - round grips in the corner of transform region
 * 		angleGrip
 * 	]
 * }
 *
 */ parcelHelpers.export(exports, "FreeTransform", ()=>FreeTransform);
var _bb = require("../../../bb/bb");
// @ts-ignore
var _cursorRotatePng = require("url:~/src/app/img/ui/cursor-rotate.png");
var _cursorRotatePngDefault = parcelHelpers.interopDefault(_cursorRotatePng);
/**
 * snap entire transform to pixel grid. changes transform
 *
 * for x y:
 * If a dimension has an even size, it be an integer.
 * If it's uneven, it's sits exactly half way between two pixels.
 *
 * @param transform
 */ function snapToPixel(transform) {
    if (Math.abs(transform.angleDeg) % 90 !== 0) return;
    transform.width = Math.round(transform.width);
    transform.height = Math.round(transform.height);
    // 0¬∞ is original orientation.
    // At 90¬∞ and 270¬∞ width and height become swapped due to different orientation.
    const whSwapped = Math.abs(transform.angleDeg - 90) % 180 === 0;
    transform.x = (whSwapped ? transform.height : transform.width) % 2 === 0 ? Math.round(transform.x) : Math.round(transform.x - 0.5) + 0.5;
    transform.y = (whSwapped ? transform.width : transform.height) % 2 === 0 ? Math.round(transform.y) : Math.round(transform.y - 0.5) + 0.5;
}
function copyTransform(transform) {
    return {
        x: transform.x,
        y: transform.y,
        width: transform.width,
        height: transform.height,
        angleDeg: transform.angleDeg
    };
}
/**
 * image space to transform space
 * - origin of transform space is at center of transform bounds.
 * - same scale as image space. -> one unit is x: 1/width, y: 1/height
 * - up is where transform points up
 * - x goes right
 * - y goes down
 * @param x
 * @param y
 * @param transform
 */ function toTransformSpace(x, y, transform) {
    let px, py;
    px = x - transform.x;
    py = y - transform.y;
    const rot = (0, _bb.BB).rotateAround({
        x: 0,
        y: 0
    }, {
        x: px,
        y: py
    }, -transform.angleDeg);
    px = rot.x;
    py = rot.y;
    return {
        x: px,
        y: py
    };
}
/**
 * transform space to image space
 * @param x
 * @param y
 * @param transform
 */ function toImageSpace(x, y, transform) {
    const rot = (0, _bb.BB).rotateAround({
        x: 0,
        y: 0
    }, {
        x: x,
        y: y
    }, transform.angleDeg);
    return {
        x: rot.x + transform.x,
        y: rot.y + transform.y
    };
}
class FreeTransform {
    scaled = {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        corners: [
            {
                x: 0,
                y: 0
            }
        ]
    };
    minSnapDist = 7;
    cornerCursors = [
        "nw",
        "n",
        "ne",
        "e",
        "se",
        "s",
        "sw",
        "w"
    ];
    gripSize = 14;
    edgeSize = 10;
    corners = [];
    edges = [];
    updateScaled() {
        this.scaled.x = this.transform.x * this.scale;
        this.scaled.y = this.transform.y * this.scale;
        this.scaled.width = this.transform.width * this.scale;
        this.scaled.height = this.transform.height * this.scale;
        this.scaled.corners = this.corners.map((item)=>{
            return {
                x: item.x * this.scale,
                y: item.y * this.scale
            };
        });
    }
    /**
     * Returns snapped point, if ix, iy snaps. If no snapping, returns point unchanged.
     * both in image space
     *
     * @param iX - image space
     * @param iY - image space
     * @private
     */ snapCorner(iX, iY) {
        if (!this.snappingEnabled) return {
            x: iX,
            y: iY
        };
        let dist;
        const snap = {
            x: null,
            y: null,
            dist: {
                x: null,
                y: null
            }
        };
        for(let e = 0; e < this.snapX.length; e++){
            dist = Math.abs(iX - this.snapX[e]);
            if (dist < this.minSnapDist / this.scale) {
                if (snap.x === null || dist < snap.dist.x) {
                    snap.x = this.snapX[e];
                    snap.dist.x = dist;
                }
            }
        }
        for(let e1 = 0; e1 < this.snapY.length; e1++){
            dist = Math.abs(iY - this.snapY[e1]);
            if (dist < this.minSnapDist / this.scale) {
                if (snap.y === null || dist < snap.dist.y) {
                    snap.y = this.snapY[e1];
                    snap.dist.y = dist;
                }
            }
        }
        if (snap.x === null && snap.y === null) return {
            x: iX,
            y: iY
        };
        return {
            x: snap.x ?? iX,
            y: snap.y ?? iY
        };
    }
    /**
     * If constrained return nearest corner pos that fits aspect ratio
     *
     * @param cornerIndex
     * @param iX
     * @param iY
     * @private
     */ constrainCorner(cornerIndex, iX, iY) {
        if (!this.isConstrained) return {
            x: iX,
            y: iY
        };
        const flip = this.transform.width * this.transform.height < 0 ? -1 : 1;
        return (0, _bb.BB).projectPointOnLine({
            x: this.transform.x,
            y: this.transform.y
        }, toImageSpace(this.ratio, flip * ([
            0,
            2
        ].includes(cornerIndex) ? 1 : -1), this.transform), {
            x: iX,
            y: iY
        });
    }
    /**
     * Update corners according to width height.
     * Not their DOM.
     */ updateCornerPositions() {
        this.corners[0].x = -this.transform.width / 2; // top left
        this.corners[0].y = -this.transform.height / 2;
        this.corners[1].x = this.transform.width / 2; // top right
        this.corners[1].y = -this.transform.height / 2;
        this.corners[2].x = this.transform.width / 2; // bottom right
        this.corners[2].y = this.transform.height / 2;
        this.corners[3].x = -this.transform.width / 2; // bottom left
        this.corners[3].y = this.transform.height / 2;
    }
    /**
     * If constrained and dragging an edge, restore aspect ratio
     * Updates corner positions.
     *
     * @param widthChanged
     * @param heightChanged
     * @private
     */ restoreRatio(widthChanged, heightChanged) {
        if (!this.isConstrained) return;
        const angle90 = Math.abs(this.transform.angleDeg) % 90 === 0;
        const whSwapped = Math.abs(this.transform.angleDeg - 90) % 180 === 0;
        if (heightChanged && !widthChanged) {
            const newHeight = Math.abs(this.corners[3].y - this.corners[0].y);
            let newWidth = this.ratio * newHeight;
            if (angle90) newWidth = (whSwapped ? this.transform.y % 1 : this.transform.x % 1) === 0 ? (0, _bb.BB).roundEven(newWidth) : (0, _bb.BB).roundUneven(newWidth);
            if (this.corners[1].x - this.corners[0].x < 0) newWidth *= -1;
            this.corners[0].x = -newWidth / 2;
            this.corners[3].x = -newWidth / 2;
            this.corners[1].x = newWidth / 2;
            this.corners[2].x = newWidth / 2;
        }
        if (!heightChanged && widthChanged) {
            const newWidth1 = Math.abs(this.corners[0].x - this.corners[1].x);
            let newHeight1 = newWidth1 / this.ratio;
            if (angle90) newHeight1 = (whSwapped ? this.transform.x % 1 : this.transform.y % 1) === 0 ? (0, _bb.BB).roundEven(newHeight1) : (0, _bb.BB).roundUneven(newHeight1);
            if (this.corners[3].y - this.corners[0].y < 0) newHeight1 *= -1;
            this.corners[0].y = -newHeight1 / 2;
            this.corners[1].y = -newHeight1 / 2;
            this.corners[2].y = newHeight1 / 2;
            this.corners[3].y = newHeight1 / 2;
        }
    }
    /**
     * update transform based on corners
     * @private
     */ updateTransformViaCorners() {
        // calc transform center in image space
        const rot = (0, _bb.BB).rotateAround({
            x: 0,
            y: 0
        }, {
            x: (this.corners[0].x + this.corners[1].x) / 2,
            y: (this.corners[0].y + this.corners[3].y) / 2
        }, this.transform.angleDeg);
        this.transform.x = rot.x + this.transform.x;
        this.transform.y = rot.y + this.transform.y;
        // update size
        this.transform.width = this.corners[1].x - this.corners[0].x;
        this.transform.height = this.corners[3].y - this.corners[0].y;
        // new center means corners changed their position
        this.updateCornerPositions();
        this.updateDOM();
    }
    /**
     * updates DOM according to transform
     * @param skipCallback
     */ updateDOM(skipCallback) {
        this.updateScaled();
        (0, _bb.BB).css(this.transEl, {
            left: this.scaled.x + "px",
            top: this.scaled.y + "px",
            transformOrigin: "0 0",
            transform: "rotate(" + this.transform.angleDeg + "deg)"
        });
        (0, _bb.BB).css(this.boundsEl, {
            width: Math.abs(this.scaled.width) + "px",
            height: Math.abs(this.scaled.height) + "px",
            left: Math.min(this.scaled.corners[0].x, this.scaled.corners[1].x) + "px",
            top: Math.min(this.scaled.corners[0].y, this.scaled.corners[3].y) + "px"
        });
        this.corners[0].updateDOM();
        this.corners[1].updateDOM();
        this.corners[2].updateDOM();
        this.corners[3].updateDOM();
        this.edges[0].updateDOM();
        this.edges[1].updateDOM();
        this.edges[2].updateDOM();
        this.edges[3].updateDOM();
        this.angleGrip.x = 0;
        this.angleGrip.y = -Math.abs(this.transform.height * this.scale) / 2 - 20;
        this.angleGrip.updateDOM();
        if (!skipCallback) {
            if (this.callback) this.callback(copyTransform(this.transform));
        }
    }
    // --- public ---
    constructor(params){
        this.transform = {
            x: params.x,
            y: params.y,
            width: params.width,
            height: params.height,
            angleDeg: params.angleDeg
        };
        this.isConstrained = !!params.isConstrained;
        this.snapX = params.snapX;
        this.snapY = params.snapY;
        this.callback = params.callback;
        this.scale = params.scale;
        this.snappingEnabled = true;
        this.ratio = this.transform.width / this.transform.height;
        this.rootEl = (0, _bb.BB).el({
            className: "kl-free-transform",
            css: {
                userSelect: "none"
            }
        });
        this.transEl = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                position: "absolute"
            }
        });
        this.boundsEl = (0, _bb.BB).el({
            css: {
                position: "absolute",
                cursor: "move",
                boxShadow: "rgba(255, 255, 255, 0.5) 0 0 0 1px inset, rgba(0, 0, 0, 0.5) 0 0 0 1px"
            }
        });
        const pointerRemainder = {
            x: 0,
            y: 0
        };
        function resetRemainder() {
            pointerRemainder.x = 0;
            pointerRemainder.y = 0;
        }
        this.keyListener = new (0, _bb.BB).KeyListener({});
        let boundsStartP = {
            x: 0,
            y: 0
        };
        this.boundsPointerListener = new (0, _bb.BB).PointerListener({
            target: this.boundsEl,
            fixScribble: true,
            onPointer: (event)=>{
                event.eventPreventDefault();
                if (event.type === "pointerdown") boundsStartP = {
                    x: this.transform.x,
                    y: this.transform.y
                };
                if (event.type === "pointermove" && event.button === "left") {
                    this.transform.x = boundsStartP.x + (event.pageX - event.downPageX) / this.scale;
                    this.transform.y = boundsStartP.y + (event.pageY - event.downPageY) / this.scale;
                    let dist;
                    let snap = {};
                    if (this.snappingEnabled) {
                        let i;
                        for(i = 0; i < this.snapX.length; i++){
                            dist = Math.abs(this.transform.x - this.snapX[i]);
                            if (dist < this.minSnapDist / this.scale) {
                                if (!snap.x || dist < snap.distX) {
                                    snap.x = this.snapX[i];
                                    snap.distX = dist;
                                }
                            }
                        }
                        for(i = 0; i < this.snapY.length; i++){
                            dist = Math.abs(this.transform.y - this.snapY[i]);
                            if (dist < this.minSnapDist / this.scale) {
                                if (!snap.y || dist < snap.distY) {
                                    snap.y = this.snapY[i];
                                    snap.distY = dist;
                                }
                            }
                        }
                        let iP;
                        for(i = 0; i < 4; i++){
                            iP = toImageSpace(this.corners[i].x, this.corners[i].y, this.transform);
                            let j;
                            for(j = 0; j < this.snapX.length; j++){
                                dist = Math.abs(iP.x - this.snapX[j]);
                                if (dist < this.minSnapDist / this.scale) {
                                    if (!snap.x || dist < snap.distX) {
                                        snap.x = this.snapX[j] - (iP.x - this.transform.x);
                                        snap.distX = dist;
                                    }
                                }
                            }
                            for(j = 0; j < this.snapY.length; j++){
                                dist = Math.abs(iP.y - this.snapY[j]);
                                if (dist < this.minSnapDist / this.scale) {
                                    if (!snap.y || dist < snap.distY) {
                                        snap.y = this.snapY[j] - (iP.y - this.transform.y);
                                        snap.distY = dist;
                                    }
                                }
                            }
                        }
                    }
                    if (this.keyListener.getComboStr() === "shift") {
                        let projected = (0, _bb.BB).projectPointOnLine({
                            x: 0,
                            y: boundsStartP.y
                        }, {
                            x: 10,
                            y: boundsStartP.y
                        }, {
                            x: this.transform.x,
                            y: this.transform.y
                        });
                        let dist1 = (0, _bb.BB).dist(projected.x, projected.y, this.transform.x, this.transform.y);
                        snap = {};
                        snap.x = projected.x;
                        snap.y = projected.y;
                        snap.distX = dist1;
                        snap.distY = dist1;
                        projected = (0, _bb.BB).projectPointOnLine({
                            x: boundsStartP.x,
                            y: 0
                        }, {
                            x: boundsStartP.x,
                            y: 10
                        }, {
                            x: this.transform.x,
                            y: this.transform.y
                        });
                        dist1 = (0, _bb.BB).dist(projected.x, projected.y, this.transform.x, this.transform.y);
                        if (dist1 < snap.distX) {
                            snap.x = projected.x;
                            snap.y = projected.y;
                            snap.distX = dist1;
                            snap.distY = dist1;
                        }
                        projected = (0, _bb.BB).projectPointOnLine({
                            x: boundsStartP.x,
                            y: boundsStartP.y
                        }, {
                            x: boundsStartP.x + 1,
                            y: boundsStartP.y + 1
                        }, {
                            x: this.transform.x,
                            y: this.transform.y
                        });
                        dist1 = (0, _bb.BB).dist(projected.x, projected.y, this.transform.x, this.transform.y);
                        if (dist1 < snap.distX) {
                            snap.x = projected.x;
                            snap.y = projected.y;
                            snap.distX = dist1;
                            snap.distY = dist1;
                        }
                        projected = (0, _bb.BB).projectPointOnLine({
                            x: boundsStartP.x,
                            y: boundsStartP.y
                        }, {
                            x: boundsStartP.x + 1,
                            y: boundsStartP.y - 1
                        }, {
                            x: this.transform.x,
                            y: this.transform.y
                        });
                        dist1 = (0, _bb.BB).dist(projected.x, projected.y, this.transform.x, this.transform.y);
                        if (dist1 < snap.distX) {
                            snap.x = projected.x;
                            snap.y = projected.y;
                            snap.distX = dist1;
                            snap.distY = dist1;
                        }
                    }
                    if (snap.x != undefined) this.transform.x = snap.x;
                    if (snap.y != undefined) this.transform.y = snap.y;
                    // snap to pixels
                    if (Math.abs(this.transform.angleDeg) % 90 === 0) {
                        snapToPixel(this.transform);
                        this.updateCornerPositions();
                    }
                    this.updateDOM();
                }
            }
        });
        for(let i = 0; i < 4; i++)((i)=>{
            const g = this.corners[i] = {
                i: i,
                el: (0, _bb.BB).el({
                    css: {
                        width: this.gripSize + "px",
                        height: this.gripSize + "px",
                        background: "#fff",
                        /*background: [
                                '#ff0000',
                                '#00ff00',
                                '#0000ff',
                                '#ff00ff',
                            ][i],*/ borderRadius: this.gripSize + "px",
                        position: "absolute",
                        boxShadow: "inset 0 0 0 2px #000"
                    }
                }),
                x: 0,
                y: 0,
                virtualPos: {
                    x: 0,
                    y: 0
                },
                updateDOM: null,
                pointerListener: null
            };
            g.updateDOM = ()=>{
                // grip position
                // if gets small, offset grips, so easier to handle
                const offsetArr = [
                    [
                        -1,
                        -1
                    ],
                    [
                        1,
                        -1
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        -1,
                        1
                    ]
                ].map((item)=>{
                    item[0] *= this.transform.width > 0 ? 1 : -1;
                    item[1] *= this.transform.height > 0 ? 1 : -1;
                    return item;
                });
                const tinyOffset = Math.abs(this.scaled.width) < 20 || Math.abs(this.scaled.height) < 20 ? 10 : 0;
                (0, _bb.BB).css(g.el, {
                    left: this.scaled.corners[g.i].x - this.gripSize / 2 + offsetArr[i][0] * tinyOffset + "px",
                    top: this.scaled.corners[g.i].y - this.gripSize / 2 + offsetArr[i][1] * tinyOffset + "px"
                });
                // cursor
                let angle = (0, _bb.BB).pointsToAngleDeg({
                    x: this.transform.x,
                    y: this.transform.y
                }, toImageSpace(g.x, g.y, this.transform)) + 135; // offset so nw is 0
                while(angle < 0)angle += 360;
                let index = Math.round(angle / 45) % this.cornerCursors.length;
                (0, _bb.BB).css(g.el, {
                    cursor: this.cornerCursors[index] + "-resize"
                });
            };
            g.pointerListener = new (0, _bb.BB).PointerListener({
                target: this.corners[i].el,
                fixScribble: true,
                onPointer: (event)=>{
                    event.eventPreventDefault();
                    if (event.type === "pointerdown" && event.button === "left") this.corners[i].virtualPos = toImageSpace(this.corners[i].x, this.corners[i].y, this.transform);
                    else if (event.type === "pointermove" && event.button === "left") {
                        this.corners[i].virtualPos.x += event.dX / this.scale;
                        this.corners[i].virtualPos.y += event.dY / this.scale;
                        let iP = {
                            x: this.corners[i].virtualPos.x,
                            y: this.corners[i].virtualPos.y
                        };
                        iP = this.constrainCorner(i, iP.x, iP.y);
                        if (!this.isConstrained) iP = this.snapCorner(iP.x, iP.y);
                        if (Math.abs(this.transform.angleDeg) % 90 === 0) {
                            iP.x = Math.round(iP.x);
                            iP.y = Math.round(iP.y);
                        }
                        const tP = toTransformSpace(iP.x, iP.y, this.transform);
                        const dX = tP.x - this.corners[i].x;
                        const dY = tP.y - this.corners[i].y;
                        this.corners[i].x = tP.x;
                        this.corners[i].y = tP.y;
                        let indexes = [];
                        if (i === 0) indexes = [
                            3,
                            1,
                            2
                        ];
                        else if (i === 1) indexes = [
                            2,
                            0,
                            3
                        ];
                        else if (i === 2) indexes = [
                            1,
                            3,
                            0
                        ];
                        else if (i === 3) indexes = [
                            0,
                            2,
                            1
                        ];
                        this.corners[indexes[0]].x = this.corners[i].x;
                        this.corners[indexes[1]].y = this.corners[i].y;
                        if (this.keyListener.isPressed("shift")) {
                            this.corners[indexes[2]].x -= dX;
                            this.corners[indexes[2]].y -= dY;
                            this.corners[indexes[1]].x = this.corners[indexes[2]].x;
                            this.corners[indexes[0]].y = this.corners[indexes[2]].y;
                        }
                        this.updateTransformViaCorners();
                    }
                }
            });
        })(i);
        this.updateCornerPositions();
        this.updateScaled();
        let isInverted;
        for(let i1 = 0; i1 < 4; i1++)((i)=>{
            this.edges[i] = {
                el: (0, _bb.BB).el({
                    css: {
                        width: this.edgeSize + "px",
                        height: this.edgeSize + "px",
                        /*background: [
                                '#ff000044',
                                '#00ff0044',
                                '#0000ff44',
                                '#ff00ff44',
                            ][i],*/ position: "absolute"
                    }
                }),
                updateDOM: null,
                pointerListener: null
            };
            const g = this.edges[i];
            g.updateDOM = ()=>{
                if (i === 0) (0, _bb.BB).css(g.el, {
                    left: Math.min(this.scaled.corners[0].x, this.scaled.corners[1].x) + "px",
                    top: Math.min(this.scaled.corners[0].y, this.scaled.corners[3].y) - this.edgeSize + "px",
                    width: Math.abs(this.scaled.width) + "px",
                    height: this.edgeSize + "px"
                });
                else if (i === 1) (0, _bb.BB).css(g.el, {
                    left: Math.max(this.scaled.corners[0].x, this.scaled.corners[1].x) + "px",
                    top: Math.min(this.scaled.corners[1].y, this.scaled.corners[2].y) + "px",
                    width: this.edgeSize + "px",
                    height: Math.abs(this.scaled.height) + "px"
                });
                else if (i === 2) (0, _bb.BB).css(g.el, {
                    left: Math.min(this.scaled.corners[3].x, this.scaled.corners[2].x) + "px",
                    top: Math.max(this.scaled.corners[0].y, this.scaled.corners[3].y) + "px",
                    width: Math.abs(this.scaled.width) + "px",
                    height: this.edgeSize + "px"
                });
                else if (i === 3) (0, _bb.BB).css(g.el, {
                    left: Math.min(this.scaled.corners[0].x, this.scaled.corners[1].x) - this.edgeSize + "px",
                    top: Math.min(this.scaled.corners[0].y, this.scaled.corners[3].y) + "px",
                    width: this.edgeSize + "px",
                    height: Math.abs(this.scaled.height) + "px"
                });
                let angleOffset = Math.round(this.transform.angleDeg / 45);
                while(angleOffset < 0)angleOffset += 8;
                angleOffset = (i * 2 + 1 + angleOffset) % this.cornerCursors.length;
                g.el.style.cursor = this.cornerCursors[angleOffset] + "-resize";
            };
            const isVertical = [
                0,
                2
            ].includes(i);
            g.pointerListener = new (0, _bb.BB).PointerListener({
                target: this.edges[i].el,
                fixScribble: true,
                onPointer: (event)=>{
                    event.eventPreventDefault();
                    if (event.type === "pointerdown" && event.button === "left") {
                        if (isVertical) isInverted = this.corners[0].y >= this.corners[3].y;
                        else isInverted = this.corners[0].x >= this.corners[1].x;
                        resetRemainder();
                    }
                    if (event.type === "pointermove" && event.button === "left") {
                        const tfD = (0, _bb.BB).rotateAround({
                            x: 0,
                            y: 0
                        }, {
                            x: event.dX / this.scale,
                            y: event.dY / this.scale
                        }, -this.transform.angleDeg);
                        let ti = {
                            dX: tfD.x,
                            dY: tfD.y
                        };
                        if (Math.abs(this.transform.angleDeg) % 90 === 0) ti = (0, _bb.BB).intDxy(pointerRemainder, tfD.x, tfD.y);
                        let indexes = [];
                        if (i === 0) indexes = [
                            2,
                            3,
                            0,
                            1
                        ];
                        else if (i === 1) indexes = [
                            0,
                            3,
                            1,
                            2
                        ];
                        else if (i === 2) indexes = [
                            0,
                            1,
                            2,
                            3
                        ];
                        else if (i === 3) indexes = [
                            1,
                            2,
                            0,
                            3
                        ];
                        let dimension = isVertical ? "y" : "x";
                        let d = isVertical ? ti.dY : ti.dX;
                        if (isInverted) {
                            this.corners[indexes[0]][dimension] += d;
                            this.corners[indexes[1]][dimension] += d;
                        } else {
                            this.corners[indexes[2]][dimension] += d;
                            this.corners[indexes[3]][dimension] += d;
                        }
                        if (this.keyListener.isPressed("shift")) {
                            if (isInverted) {
                                this.corners[indexes[2]][dimension] -= d;
                                this.corners[indexes[3]][dimension] -= d;
                            } else {
                                this.corners[indexes[0]][dimension] -= d;
                                this.corners[indexes[1]][dimension] -= d;
                            }
                        }
                        if (isVertical) this.restoreRatio(false, true);
                        else this.restoreRatio(true, false);
                        this.updateTransformViaCorners();
                    }
                }
            });
        })(i1);
        this.angleGrip = {
            el: (0, _bb.BB).el({
                css: {
                    cursor: "url(" + (0, _cursorRotatePngDefault.default) + ") 10 10, move",
                    width: this.gripSize + "px",
                    height: this.gripSize + "px",
                    background: "#0ff",
                    borderRadius: this.gripSize + "px",
                    position: "absolute",
                    boxShadow: "inset 0 0 0 2px #000"
                }
            }),
            x: 0,
            y: 0,
            snap: false,
            updateDOM: ()=>{
                (0, _bb.BB).css(this.angleGrip.el, {
                    left: this.angleGrip.x - this.gripSize / 2 + "px",
                    top: this.angleGrip.y - this.gripSize / 2 + "px"
                });
            }
        };
        (0, _bb.BB).el({
            parent: this.angleGrip.el,
            css: {
                width: "2px",
                height: "13px",
                left: this.gripSize / 2 - 1 + "px",
                top: this.gripSize + "px",
                background: "#0ff",
                position: "absolute"
            }
        });
        this.anglePointerListener = new (0, _bb.BB).PointerListener({
            target: this.angleGrip.el,
            fixScribble: true,
            onPointer: (event)=>{
                event.eventPreventDefault();
                if (event.type === "pointermove" && event.button === "left") {
                    const bounds = this.rootEl.getBoundingClientRect();
                    const offset = {
                        x: bounds.left - this.rootEl.scrollLeft,
                        y: bounds.top - this.rootEl.scrollTop
                    };
                    const iP = {
                        x: (event.clientX - offset.x) / this.scale,
                        y: (event.clientY - offset.y) / this.scale
                    };
                    const a = (0, _bb.BB).pointsToAngleDeg({
                        x: this.transform.x,
                        y: this.transform.y
                    }, iP) + 90;
                    this.transform.angleDeg = a;
                    const snapDeg = Math.round(a / 360 * 8) * 45;
                    if (this.keyListener.getComboStr() === "shift") this.transform.angleDeg = snapDeg;
                    else if (this.snappingEnabled && Math.abs(snapDeg - a) < 8) this.transform.angleDeg = snapDeg;
                    this.updateDOM();
                }
                if (event.type === "pointerup") {
                    if (Math.abs(this.transform.angleDeg) % 90 === 0) {
                        snapToPixel(this.transform);
                        this.updateCornerPositions();
                        this.updateDOM();
                    }
                }
            }
        });
        snapToPixel(this.transform);
        this.updateDOM(true);
        (0, _bb.BB).append(this.transEl, [
            this.boundsEl,
            this.edges[0].el,
            this.edges[1].el,
            this.edges[2].el,
            this.edges[3].el,
            this.corners[0].el,
            this.corners[1].el,
            this.corners[2].el,
            this.corners[3].el,
            this.angleGrip.el, 
        ]);
    }
    getTransform() {
        return copyTransform(this.transform);
    }
    setConstrained(b) {
        this.isConstrained = !!b;
        if (b && this.transform.width !== 0 && this.transform.height !== 0) this.ratio = Math.abs(this.transform.width / this.transform.height);
    }
    setSnapping(s) {
        this.snappingEnabled = !!s;
    }
    setPos(p) {
        this.transform.x = p.x;
        this.transform.y = p.y;
        this.updateDOM(true);
    }
    move(dX, dY) {
        this.transform.x += dX;
        this.transform.y += dY;
        this.updateDOM(false);
    }
    setSize(w, h) {
        this.transform.width = w;
        this.transform.height = h;
        if (Math.abs(this.transform.angleDeg) % 90 === 0) snapToPixel(this.transform);
        this.updateCornerPositions();
        this.updateDOM(false);
    }
    setAngleDeg(a) {
        this.transform.angleDeg = a;
        if (Math.abs(this.transform.angleDeg) % 90 === 0) {
            snapToPixel(this.transform);
            this.updateCornerPositions();
        }
        this.updateDOM(true);
    }
    getElement() {
        return this.rootEl;
    }
    getRatio() {
        return this.ratio;
    }
    destroy() {
        this.keyListener.destroy();
        this.boundsPointerListener.destroy();
        this.corners[0].pointerListener.destroy();
        this.corners[1].pointerListener.destroy();
        this.corners[2].pointerListener.destroy();
        this.corners[3].pointerListener.destroy();
        this.edges[0].pointerListener.destroy();
        this.edges[1].pointerListener.destroy();
        this.edges[2].pointerListener.destroy();
        this.edges[3].pointerListener.destroy();
        this.anglePointerListener.destroy();
    }
}

},{"../../../bb/bb":"dcQKo","url:~/src/app/img/ui/cursor-rotate.png":"ezHiW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ezHiW":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "cursor-rotate.e23c5d0d.png" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"3quPq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * a basic canvas where you can transform one layer(move around, rotate, scale)
 *
 * @param params
 * @returns {HTMLDivElement}
 * @constructor
 */ parcelHelpers.export(exports, "FreeTransformCanvas", ()=>FreeTransformCanvas);
var _bb = require("../../../bb/bb");
var _canvasPreview = require("../../canvas-ui/canvas-preview");
var _freeTransform = require("./free-transform");
function FreeTransformCanvas(params) {
    /*
    div
        innerWrapper
            klCanvasPreview
            transform.div
    */ let previewFit = (0, _bb.BB).fitInto(params.imageWidth, params.imageHeight, params.elementWidth - 20, params.elementHeight - 60, 1);
    let scale = previewFit.width / params.imageWidth;
    let div = (0, _bb.BB).el({
        css: {
            width: params.elementWidth + "px",
            height: params.elementHeight + "px",
            backgroundColor: "#9e9e9e",
            boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
            overflow: "hidden",
            userSelect: "none",
            position: "relative",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            colorScheme: "only light"
        }
    });
    div.oncontextmenu = function() {
        return false;
    };
    let innerWrapper = (0, _bb.BB).el({
        css: {
            position: "relative",
            boxShadow: "0 0 5px rgba(0,0,0,0.5)",
            width: previewFit.width + "px",
            height: previewFit.height + "px"
        }
    });
    div.appendChild(innerWrapper);
    let previewLayerArr = params.layers.map((item)=>{
        return {
            image: item.image,
            mixModeStr: item.mixModeStr,
            opacity: item.opacity
        };
    });
    previewLayerArr[previewLayerArr.length - 1].image = (0, _bb.BB).canvas(scale > 1 ? params.imageWidth : previewFit.width, scale > 1 ? params.imageHeight : previewFit.height);
    let klCanvasPreview = new (0, _canvasPreview.KlCanvasPreview)({
        width: previewFit.width,
        height: previewFit.height,
        layers: previewLayerArr
    });
    innerWrapper.appendChild(klCanvasPreview.getElement());
    let freeTransform;
    let initTransform;
    function updatePreview() {
        if (!freeTransform) return;
        let transform = freeTransform.getTransform();
        if (scale < 1) {
            transform.x *= scale;
            transform.y *= scale;
            transform.width *= scale;
            transform.height *= scale;
        }
        let destCanvas = previewLayerArr[params.transformIndex].image;
        let ctx = destCanvas.getContext("2d");
        ctx.save();
        ctx.clearRect(0, 0, destCanvas.width, destCanvas.height);
        (0, _bb.BB).drawTransformedImageWithBounds(ctx, params.layers[params.transformIndex].image, transform, null, (0, _bb.BB).testShouldPixelate(transform, transform.width / initTransform.width, transform.height / initTransform.height));
        ctx.restore();
        klCanvasPreview.render();
    }
    {
        let transformSize = {
            width: params.layers[params.transformIndex].image.width * scale,
            height: params.layers[params.transformIndex].image.height * scale
        };
        if (transformSize.width > previewFit.width || transformSize.height > previewFit.height) transformSize = (0, _bb.BB).fitInto(params.layers[params.transformIndex].image.width, params.layers[params.transformIndex].image.height, previewFit.width, previewFit.height, 1);
        initTransform = {
            x: params.imageWidth / 2,
            y: params.imageHeight / 2,
            width: params.layers[params.transformIndex].image.width,
            height: params.layers[params.transformIndex].image.height
        };
        freeTransform = new (0, _freeTransform.FreeTransform)({
            x: initTransform.x,
            y: initTransform.y,
            width: initTransform.width,
            height: initTransform.height,
            angleDeg: 0,
            isConstrained: true,
            snapX: [
                0,
                params.imageWidth
            ],
            snapY: [
                0,
                params.imageHeight
            ],
            scale: scale,
            callback: (transform)=>{
                updatePreview();
            }
        });
    }
    (0, _bb.BB).css(freeTransform.getElement(), {
        position: "absolute",
        left: "0",
        top: "0"
    });
    innerWrapper.appendChild(freeTransform.getElement());
    setTimeout(updatePreview, 0);
    // --- interface ---
    this.move = function(dX, dY) {
        freeTransform.move(dX, dY);
    };
    this.reset = function() {
        let w = params.layers[params.transformIndex].image.width;
        let h = params.layers[params.transformIndex].image.height;
        freeTransform.setSize(w, h);
        freeTransform.setPos({
            x: w / 2,
            y: h / 2
        });
        freeTransform.setAngleDeg(0);
        updatePreview();
    };
    this.setTransformFit = function() {
        let fit = (0, _bb.BB).fitInto(params.layers[params.transformIndex].image.width, params.layers[params.transformIndex].image.height, params.imageWidth, params.imageHeight, 1);
        freeTransform.setSize(fit.width, fit.height);
        freeTransform.setPos({
            x: fit.width / 2,
            y: fit.height / 2
        });
        freeTransform.setAngleDeg(0);
        updatePreview();
    };
    this.setTransformCenter = function() {
        freeTransform.setPos({
            x: params.imageWidth / 2,
            y: params.imageHeight / 2
        });
        freeTransform.setAngleDeg(0);
        updatePreview();
    };
    //gives you the transformation in the original scale
    this.getTransformation = function() {
        if (!freeTransform) return false;
        return freeTransform.getTransform();
    };
    this.getIsPixelated = ()=>{
        const transform = freeTransform.getTransform();
        return (0, _bb.BB).testShouldPixelate(transform, transform.width / initTransform.width, transform.height / initTransform.height);
    };
    this.getElement = function() {
        return div;
    };
    this.destroy = function() {
        freeTransform.destroy();
    };
}

},{"../../../bb/bb":"dcQKo","../../canvas-ui/canvas-preview":"gRZnS","./free-transform":"izcGJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bajkn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/*
	Cropper params
	{
		x: int, //pos in relation zum bild
		y: int,
		w: int,
		h: int,
		scale: float, //zoom
		callback: function //wenn sich was √§ndert
	}
	the div that you append this to must be relative
*/ parcelHelpers.export(exports, "Cropper", ()=>Cropper);
var _bb = require("../../../bb/bb");
function Cropper(params) {
    let x = params.x, y = params.y, width = params.width, height = params.height, scale = params.scale, callback = params.callback, maxW = params.maxW, maxH = params.maxH;
    let div = document.createElement("div");
    let gripCursors = [
        "nw",
        "n",
        "ne",
        "e",
        "se",
        "s",
        "sw",
        "w"
    ];
    let keyListener = new (0, _bb.BB).KeyListener({});
    (0, _bb.BB).css(div, {
        position: "absolute",
        left: x * scale + "px",
        top: y * scale + "px"
    });
    let outline = document.createElement("div");
    (0, _bb.BB).css(outline, {
        position: "absolute",
        border: "1px dashed #fff",
        cursor: "move"
    });
    outline.update = function() {
        (0, _bb.BB).css(outline, {
            left: grips[0].x * scale - 1 + "px",
            top: grips[0].y * scale - 1 + "px",
            width: (grips[2].x - grips[0].x) * scale + "px",
            height: (grips[2].y - grips[0].y) * scale + "px"
        });
    };
    let pointerRemainder = {
        x: 0,
        y: 0
    };
    let outlinePointerListener = new (0, _bb.BB).PointerListener({
        target: outline,
        onPointer: function(event) {
            event.eventPreventDefault();
            if (event.type === "pointermove" && event.button === "left") {
                const { dX , dY  } = (0, _bb.BB).intDxy(pointerRemainder, event.dX / scale, event.dY / scale);
                grips[0].x += dX;
                grips[0].y += dY;
                grips[1].x += dX;
                grips[1].y += dY;
                grips[2].x += dX;
                grips[2].y += dY;
                grips[3].x += dX;
                grips[3].y += dY;
                update();
            }
            if (event.type === "pointerup") commit();
        }
    });
    let thirdsHorizontal = document.createElement("div");
    (0, _bb.BB).css(thirdsHorizontal, {
        position: "absolute",
        borderTop: "1px solid #0ff",
        borderBottom: "1px solid #0ff"
    });
    thirdsHorizontal.update = function() {
        (0, _bb.BB).css(thirdsHorizontal, {
            left: grips[0].x * scale + "px",
            top: (grips[0].y + (grips[2].y - grips[0].y) / 3) * scale + "px",
            width: (grips[2].x - grips[0].x) * scale + "px",
            height: (grips[2].y - grips[0].y) / 3 * scale + "px"
        });
    };
    let thirdsVertical = document.createElement("div");
    (0, _bb.BB).css(thirdsVertical, {
        position: "absolute",
        borderLeft: "1px solid #0ff",
        borderRight: "1px solid #0ff"
    });
    thirdsVertical.update = function() {
        (0, _bb.BB).css(thirdsVertical, {
            left: (grips[0].x + (grips[2].x - grips[0].x) / 3) * scale + "px",
            top: grips[0].y * scale + "px",
            width: (grips[2].x - grips[0].x) / 3 * scale + "px",
            height: (grips[2].y - grips[0].y) * scale + "px"
        });
    };
    const gripSize = 40;
    const gripOverlay = 10;
    let grips = [
        {
            x: 0,
            y: 0
        },
        {
            x: width,
            y: 0
        },
        {
            x: width,
            y: height
        },
        {
            x: 0,
            y: height
        }
    ];
    function transformTop(dY) {
        grips[0].y += dY;
        grips[0].y = Math.max(grips[3].y - maxH, Math.min(grips[3].y - 1, grips[0].y));
        grips[1].y = grips[0].y;
    }
    function transformRight(dX) {
        grips[1].x += dX;
        grips[1].x = Math.min(grips[0].x + maxW, Math.max(grips[0].x + 1, grips[1].x));
        grips[2].x = grips[1].x;
    }
    function transformBottom(dY) {
        grips[2].y += dY;
        grips[2].y = Math.min(grips[1].y + maxH, Math.max(grips[1].y + 1, grips[2].y));
        grips[3].y = grips[2].y;
    }
    function transformLeft(dX) {
        grips[0].x += dX;
        grips[0].x = Math.max(grips[1].x - maxW, Math.min(grips[1].x - 1, grips[0].x));
        grips[3].x = grips[0].x;
    }
    function commit() {
        pointerRemainder.x = 0;
        pointerRemainder.y = 0;
        callback(getTransform());
    }
    let edges = [];
    for(let i = 0; i < 4; i++)(function(i) {
        edges[i] = document.createElement("div");
        let g = edges[i];
        g.style.width = gripSize + "px";
        g.style.height = gripSize + "px";
        //g.style.background = "#0f0";
        g.style.position = "absolute";
        g.update = function() {
            if (i === 0) {
                g.style.left = grips[0].x * scale + gripOverlay + "px";
                g.style.top = grips[0].y * scale - gripSize * 2 + gripOverlay + "px";
                g.style.width = (grips[1].x - grips[0].x) * scale - gripOverlay * 2 + "px";
                g.style.height = gripSize * 2 + "px";
            } else if (i === 1) {
                g.style.left = grips[1].x * scale - gripOverlay + "px";
                g.style.top = grips[1].y * scale + gripOverlay + "px";
                g.style.width = gripSize * 2 + "px";
                g.style.height = (grips[2].y - grips[1].y) * scale - gripOverlay * 2 + "px";
            } else if (i === 2) {
                g.style.left = grips[3].x * scale + gripOverlay + "px";
                g.style.top = grips[3].y * scale - gripOverlay + "px";
                g.style.width = (grips[2].x - grips[3].x) * scale - gripOverlay * 2 + "px";
                g.style.height = gripSize * 2 + "px";
            } else if (i === 3) {
                g.style.left = grips[0].x * scale - gripSize * 2 + gripOverlay + "px";
                g.style.top = grips[0].y * scale + gripOverlay + "px";
                g.style.width = gripSize * 2 + "px";
                g.style.height = (grips[3].y - grips[0].y) * scale - gripOverlay * 2 + "px";
            }
            let angleOffset = i * 2 + 1;
            g.style.cursor = gripCursors[angleOffset] + "-resize";
        };
    })(i);
    let darken = [];
    for(let i1 = 0; i1 < 4; i1++)(function(i) {
        darken[i] = document.createElement("div");
        let g = darken[i];
        g.style.position = "absolute";
        g.style.background = "#000";
        g.style.opacity = "0.5";
        g.update = function() {
            if (i === 0) {
                g.style.left = grips[0].x * scale + "px";
                g.style.top = grips[0].y * scale - 8000 + "px";
                g.style.width = (grips[1].x - grips[0].x) * scale + "px";
                g.style.height = "8000px";
            } else if (i === 1) {
                g.style.left = grips[1].x * scale + "px";
                g.style.top = grips[1].y * scale - 8000 + "px";
                g.style.width = "8000px";
                g.style.height = "16000px";
            } else if (i === 2) {
                g.style.left = grips[3].x * scale + "px";
                g.style.top = grips[3].y * scale + "px";
                g.style.width = (grips[2].x - grips[3].x) * scale + "px";
                g.style.height = "8000px";
            } else if (i === 3) {
                g.style.left = grips[0].x * scale - 8000 + "px";
                g.style.top = grips[0].y * scale - 8000 + "px";
                g.style.width = "8000px";
                g.style.height = "16000px";
            }
        };
    })(i1);
    let edge0PointerListener = new (0, _bb.BB).PointerListener({
        target: edges[0],
        fixScribble: true,
        onPointer: function(event) {
            event.eventPreventDefault();
            if (event.type === "pointermove" && event.button === "left") {
                const { dX , dY  } = (0, _bb.BB).intDxy(pointerRemainder, event.dX / scale, event.dY / scale);
                transformTop(dY);
                if (keyListener.isPressed("shift")) transformBottom(-dY);
                update();
            }
            if (event.type === "pointerup") commit();
        }
    });
    let edge1PointerListener = new (0, _bb.BB).PointerListener({
        target: edges[1],
        fixScribble: true,
        onPointer: function(event) {
            event.eventPreventDefault();
            if (event.type === "pointermove" && event.button === "left") {
                const { dX , dY  } = (0, _bb.BB).intDxy(pointerRemainder, event.dX / scale, event.dY / scale);
                transformRight(dX);
                if (keyListener.isPressed("shift")) transformLeft(-dX);
                update();
            }
            if (event.type === "pointerup") commit();
        }
    });
    let edge2PointerListener = new (0, _bb.BB).PointerListener({
        target: edges[2],
        fixScribble: true,
        onPointer: function(event) {
            event.eventPreventDefault();
            if (event.type === "pointermove" && event.button === "left") {
                const { dX , dY  } = (0, _bb.BB).intDxy(pointerRemainder, event.dX / scale, event.dY / scale);
                transformBottom(dY);
                if (keyListener.isPressed("shift")) transformTop(-dY);
                update();
            }
            if (event.type === "pointerup") commit();
        }
    });
    let edge3PointerListener = new (0, _bb.BB).PointerListener({
        target: edges[3],
        fixScribble: true,
        onPointer: function(event) {
            event.eventPreventDefault();
            if (event.type === "pointermove" && event.button === "left") {
                const { dX , dY  } = (0, _bb.BB).intDxy(pointerRemainder, event.dX / scale, event.dY / scale);
                transformLeft(dX);
                if (keyListener.isPressed("shift")) transformRight(-dX);
                update();
            }
            if (event.type === "pointerup") commit();
        }
    });
    let cornerElArr = [];
    (function() {
        for(let i = 0; i < 4; i++)(function(i) {
            cornerElArr[i] = document.createElement("div");
            let g = cornerElArr[i];
            (0, _bb.BB).css(g, {
                //background: '#f00',
                width: gripSize * 2 + "px",
                height: gripSize * 2 + "px",
                position: "absolute"
            });
            g.style.cursor = [
                "nwse-resize",
                "nesw-resize"
            ][i % 2];
            g.update = function() {
                if (i === 0) (0, _bb.BB).css(g, {
                    left: grips[0].x * scale - gripSize * 2 + gripOverlay + "px",
                    top: grips[0].y * scale - gripSize * 2 + gripOverlay + "px"
                });
                else if (i === 1) (0, _bb.BB).css(g, {
                    left: grips[1].x * scale - gripOverlay + "px",
                    top: grips[1].y * scale - gripSize * 2 + gripOverlay + "px"
                });
                else if (i === 2) (0, _bb.BB).css(g, {
                    left: grips[1].x * scale - gripOverlay + "px",
                    top: grips[2].y * scale - gripOverlay + "px"
                });
                else if (i === 3) (0, _bb.BB).css(g, {
                    left: grips[0].x * scale - gripSize * 2 + gripOverlay + "px",
                    top: grips[2].y * scale - gripOverlay + "px"
                });
            };
        })(i);
    })();
    //top left
    let corner0PointerListener = new (0, _bb.BB).PointerListener({
        target: cornerElArr[0],
        fixScribble: true,
        onPointer: function(event) {
            event.eventPreventDefault();
            if (event.type === "pointermove" && event.button === "left") {
                const { dX , dY  } = (0, _bb.BB).intDxy(pointerRemainder, event.dX / scale, event.dY / scale);
                transformLeft(dX);
                transformTop(dY);
                if (keyListener.isPressed("shift")) {
                    transformRight(-dX);
                    transformBottom(-dY);
                }
                update();
            }
            if (event.type === "pointerup") commit();
        }
    });
    //top right
    let corner1PointerListener = new (0, _bb.BB).PointerListener({
        target: cornerElArr[1],
        fixScribble: true,
        onPointer: function(event) {
            event.eventPreventDefault();
            if (event.type === "pointermove" && event.button === "left") {
                const { dX , dY  } = (0, _bb.BB).intDxy(pointerRemainder, event.dX / scale, event.dY / scale);
                transformRight(dX);
                transformTop(dY);
                if (keyListener.isPressed("shift")) {
                    transformLeft(-dX);
                    transformBottom(-dY);
                }
                update();
            }
            if (event.type === "pointerup") commit();
        }
    });
    //bottom right
    let corner2PointerListener = new (0, _bb.BB).PointerListener({
        target: cornerElArr[2],
        fixScribble: true,
        onPointer: function(event) {
            event.eventPreventDefault();
            if (event.type === "pointermove" && event.button === "left") {
                const { dX , dY  } = (0, _bb.BB).intDxy(pointerRemainder, event.dX / scale, event.dY / scale);
                transformRight(dX);
                transformBottom(dY);
                if (keyListener.isPressed("shift")) {
                    transformLeft(-dX);
                    transformTop(-dY);
                }
                update();
            }
            if (event.type === "pointerup") commit();
        }
    });
    //bottom left
    let corner3PointerListener = new (0, _bb.BB).PointerListener({
        target: cornerElArr[3],
        fixScribble: true,
        onPointer: function(event) {
            event.eventPreventDefault();
            if (event.type === "pointermove" && event.button === "left") {
                const { dX , dY  } = (0, _bb.BB).intDxy(pointerRemainder, event.dX / scale, event.dY / scale);
                transformLeft(dX);
                transformBottom(dY);
                if (keyListener.isPressed("shift")) {
                    transformRight(-dX);
                    transformTop(-dY);
                }
                update();
            }
            if (event.type === "pointerup") commit();
        }
    });
    function getTransform() {
        grips[1].x -= grips[0].x;
        grips[1].y -= grips[0].y;
        grips[2].x -= grips[0].x;
        grips[2].y -= grips[0].y;
        grips[3].x -= grips[0].x;
        grips[3].y -= grips[0].y;
        x += grips[0].x;
        y += grips[0].y;
        grips[0].x = 0;
        grips[0].y = 0;
        return {
            x: x,
            y: y,
            width: grips[1].x,
            height: grips[2].y
        };
    }
    div.append(darken[1], darken[0], darken[2], darken[3], thirdsHorizontal, thirdsVertical, outline, edges[1], edges[0], edges[2], edges[3], cornerElArr[0], cornerElArr[1], cornerElArr[2], cornerElArr[3]);
    function update() {
        edges[0].update();
        edges[1].update();
        edges[2].update();
        edges[3].update();
        cornerElArr[0].update();
        cornerElArr[1].update();
        cornerElArr[2].update();
        cornerElArr[3].update();
        darken[0].update();
        darken[1].update();
        darken[2].update();
        darken[3].update();
        outline.update();
        thirdsHorizontal.update();
        thirdsVertical.update();
    }
    update();
    // --- interface ---
    this.getTransform = getTransform;
    this.setTransform = function(p) {
        x = p.x;
        y = p.y;
        width = p.width;
        height = p.height;
        (0, _bb.BB).css(div, {
            left: x * scale + "px",
            top: y * scale + "px"
        });
        grips[0].x = 0;
        grips[0].y = 0;
        grips[1].x = width;
        grips[1].y = 0;
        grips[2].x = width;
        grips[2].y = height;
        grips[3].x = 0;
        grips[3].y = height;
        update();
        commit();
    };
    this.setScale = function(s) {
        scale = s;
        (0, _bb.BB).css(div, {
            left: x * scale + "px",
            top: y * scale + "px"
        });
        update();
    };
    this.showThirds = function(b) {
        if (b) {
            thirdsHorizontal.style.display = "block";
            thirdsVertical.style.display = "block";
        } else {
            thirdsHorizontal.style.display = "none";
            thirdsVertical.style.display = "none";
        }
    };
    this.getElement = function() {
        return div;
    };
    this.destroy = function() {
        keyListener.destroy();
        outlinePointerListener.destroy();
        corner0PointerListener.destroy();
        corner1PointerListener.destroy();
        corner2PointerListener.destroy();
        corner3PointerListener.destroy();
        edge0PointerListener.destroy();
        edge1PointerListener.destroy();
        edge2PointerListener.destroy();
        edge3PointerListener.destroy();
    };
}

},{"../../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1YtXQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Previews currently active layer
 * thumbnail (hover shows bigger preview), layername, opacity
 *
 * internally listens to kl history. updates when there's a change.
 * but you need to update it when the active layer changed. (different canvas object)
 *
 * update visibility for performance
 *
 * p = {
 *     onClick: function() // when clicking on layer name
 *     klRootEl: klRootEl,
 * }
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "LayerPreview", ()=>LayerPreview);
var _bb = require("../../../bb/bb");
var _klHistory = require("../../history/kl-history");
var _language = require("../../../language/language");
function LayerPreview(p) {
    // internally redraws with in an interval. checks history is something changed
    // this update will be animated
    // it will not be animated if the resolution changed
    // also redraws when you call updateLayer - not animated
    // syncs via updateLayer, and internally updates layer opacity via a hack
    let div = (0, _bb.BB).el({});
    let layerObj;
    let isVisible = true;
    const height = 40;
    const canvasSize = height - 10;
    const largeCanvasSize = 300;
    let lastDrawnState = -2;
    let lastDrawnSize = {
        width: 0,
        height: 0
    };
    let animationCanvas = (0, _bb.BB).canvas(); // to help animate the transition
    let animationCanvasCtx = animationCanvas.getContext("2d");
    const animationLength = 30;
    let animationCount = 0; // >0 means it's animating
    let largeCanvasIsVisible = false;
    let largeCanvasAnimationTimeout;
    const largeCanvasAnimationDurationMs = 300;
    let uiState = "right"; // 'left' | 'right'
    // --- setup dom ---
    let contentWrapperEl = (0, _bb.BB).el({
        css: {
            display: "flex",
            alignItems: "center",
            height: height + "px",
            color: "#666"
        }
    });
    let canvasWrapperEl = (0, _bb.BB).el({
        css: {
            //background: '#f00',
            minWidth: height + "px",
            height: height + "px",
            display: "flex",
            justifyContent: "center",
            alignItems: "center"
        }
    });
    let canvas = (0, _bb.BB).canvas(canvasSize, canvasSize);
    let canvasCtx = canvas.getContext("2d");
    canvas.title = (0, _language.LANG)("layers-active-layer");
    (0, _bb.BB).css(canvas, {
        boxShadow: "0 0 0 1px #9e9e9e",
        colorScheme: "only light"
    });
    let nameWrapper = (0, _bb.BB).el({
        css: {
            //background: '#ff0',
            flexGrow: "1",
            paddingLeft: "10px",
            fontSize: "13px",
            overflow: "hidden",
            position: "relative"
        }
    });
    let nameLabelEl = (0, _bb.BB).el({
        content: "",
        css: {
            cssFloat: "left",
            whiteSpace: "nowrap"
        }
    });
    let nameFadeEl = (0, _bb.BB).el({
        css: {
            backgroundImage: "linear-gradient(to right, rgba(221,221,221,0) 0%, rgba(221,221,221,0.8) 100%)",
            position: "absolute",
            right: "0",
            top: "0",
            width: "50px",
            height: "100%"
        }
    });
    let clickableEl = (0, _bb.BB).el({
        css: {
            //background: 'rgba(0,255,0,0.6)',
            position: "absolute",
            left: "10px",
            top: "0",
            width: "90px",
            height: "100%"
        }
    });
    if (p.onClick) {
        (0, _bb.BB).addEventListener(clickableEl, "click", function() {
            p.onClick();
        });
        (0, _bb.BB).addEventListener(canvas, "click", function() {
            p.onClick();
        });
    }
    let opacityEl = (0, _bb.BB).el({
        content: (0, _language.LANG)("opacity") + "<br>100%",
        css: {
            minWidth: "60px",
            fontSize: "12px",
            textAlign: "center",
            background: "#dddddd",
            color: "#555"
        }
    });
    const largeCanvasWrapper = (0, _bb.BB).el({
        onClick: (0, _bb.BB).handleClick,
        css: {
            pointerEvents: "none",
            background: "#fff",
            position: "absolute",
            right: "280px",
            top: "10px",
            border: "1px solid #aaa",
            boxShadow: "1px 1px 3px rgba(0,0,0,0.3)",
            transition: "opacity " + largeCanvasAnimationDurationMs + "ms ease-in-out",
            userSelect: "none",
            display: "block",
            webkitTouchCallout: "none",
            colorScheme: "only light"
        }
    });
    let largeCanvas = (0, _bb.BB).canvas(largeCanvasSize, largeCanvasSize);
    largeCanvasWrapper.append(largeCanvas);
    let largeCanvasCtx = largeCanvas.getContext("2d");
    (0, _bb.BB).css(largeCanvas, {
        display: "block"
    });
    div.appendChild(contentWrapperEl);
    contentWrapperEl.appendChild(canvasWrapperEl);
    canvasWrapperEl.appendChild(canvas);
    contentWrapperEl.appendChild(nameWrapper);
    nameWrapper.appendChild(nameLabelEl);
    nameWrapper.appendChild(nameFadeEl);
    nameWrapper.appendChild(clickableEl);
    contentWrapperEl.appendChild(opacityEl);
    let animationCanvasCheckerPattern = animationCanvasCtx.createPattern((0, _bb.BB).createCheckerCanvas(4), "repeat");
    let largeCanvasCheckerPattern = canvasCtx.createPattern((0, _bb.BB).createCheckerCanvas(4), "repeat");
    // --- update logic ---
    // cross-fade done via 2 canvases (old and new state)
    // both have checkerboard background drawn on them, both fully opaque
    // -> no "lighter" is needed for accurate cross-fading
    function animate() {
        if (animationCount === 0) return;
        animationCount--;
        canvasCtx.save();
        canvasCtx.globalAlpha = Math.pow((animationLength - animationCount) / animationLength, 2);
        canvasCtx.drawImage(animationCanvas, 0, 0);
        canvasCtx.restore();
        if (animationCount > 0) requestAnimationFrame(animate);
    }
    function draw(isInstant) {
        if (!isVisible) return;
        nameLabelEl.textContent = layerObj.name;
        opacityEl.innerHTML = (0, _language.LANG)("opacity") + "<br>" + Math.round(layerObj.opacity * 100) + "%";
        let layerCanvas = layerObj.context.canvas;
        if (layerCanvas.width !== lastDrawnSize.width || layerCanvas.height !== lastDrawnSize.height) {
            let canvasDimensions = (0, _bb.BB).fitInto(layerCanvas.width, layerCanvas.height, canvasSize, canvasSize, 1);
            canvas.width = Math.round(canvasDimensions.width);
            canvas.height = Math.round(canvasDimensions.height);
            isInstant = true;
        }
        animationCanvas.width = canvas.width;
        animationCanvas.height = canvas.height;
        animationCanvasCtx.save();
        animationCanvasCtx.imageSmoothingEnabled = false;
        animationCanvasCtx.fillStyle = animationCanvasCheckerPattern;
        animationCanvasCtx.fillRect(0, 0, animationCanvas.width, animationCanvas.height);
        animationCanvasCtx.drawImage(layerCanvas, 0, 0, animationCanvas.width, animationCanvas.height);
        animationCanvasCtx.restore();
        if (isInstant) {
            animationCount = 0;
            canvasCtx.save();
            canvasCtx.drawImage(animationCanvas, 0, 0);
            canvasCtx.restore();
        } else {
            animationCount = animationLength;
            animate();
        }
        drawLargeCanvas();
        lastDrawnState = (0, _klHistory.klHistory).getState();
        lastDrawnSize.width = layerCanvas.width;
        lastDrawnSize.height = layerCanvas.height;
    }
    function update() {
        draw(true);
    }
    setInterval(function() {
        if (!layerObj) return;
        let currentState = (0, _klHistory.klHistory).getState();
        if (currentState === lastDrawnState) return;
        //update opacity w hack
        layerObj.opacity = layerObj.context.canvas.opacity;
        draw(false);
    }, 2000);
    //is always instant
    function drawLargeCanvas() {
        if (!largeCanvasIsVisible || !layerObj) return;
        let layerCanvas = layerObj.context.canvas;
        let canvasDimensions = (0, _bb.BB).fitInto(layerCanvas.width, layerCanvas.height, largeCanvasSize, largeCanvasSize, 1);
        largeCanvas.width = Math.round(canvasDimensions.width);
        largeCanvas.height = Math.round(canvasDimensions.height);
        largeCanvasCtx.save();
        if (largeCanvas.width > layerCanvas.width) largeCanvasCtx.imageSmoothingEnabled = false;
        else {
            largeCanvasCtx.imageSmoothingEnabled = true;
            largeCanvasCtx.imageSmoothingQuality = "high";
        }
        largeCanvasCtx.fillStyle = largeCanvasCheckerPattern;
        largeCanvasCtx.fillRect(0, 0, largeCanvas.width, largeCanvas.height);
        largeCanvasCtx.drawImage(layerCanvas, 0, 0, largeCanvas.width, largeCanvas.height);
        largeCanvasCtx.restore();
        const bounds = div.getBoundingClientRect();
        (0, _bb.BB).css(largeCanvasWrapper, {
            top: Math.max(10, bounds.top + height / 2 - largeCanvas.height / 2) + "px"
        });
    }
    function removeLargeCanvas() {
        try {
            p.klRootEl.removeChild(largeCanvasWrapper);
        } catch (e) {}
    }
    function showLargeCanvas(b) {
        if (largeCanvasIsVisible === b) return;
        clearTimeout(largeCanvasAnimationTimeout);
        largeCanvasIsVisible = b;
        if (b) largeCanvasAnimationTimeout = setTimeout(function() {
            drawLargeCanvas();
            largeCanvasWrapper.style.opacity = "0";
            p.klRootEl.appendChild(largeCanvasWrapper);
            setTimeout(function() {
                largeCanvasWrapper.style.opacity = "1";
            }, 20);
        }, 250);
        else {
            largeCanvasWrapper.style.opacity = "0";
            largeCanvasAnimationTimeout = setTimeout(removeLargeCanvas, largeCanvasAnimationDurationMs + 20);
        }
    }
    let pointerListener = new (0, _bb.BB).PointerListener({
        target: canvas,
        onEnterLeave: function(b) {
            showLargeCanvas(b);
        }
    });
    // --- interface ---
    this.getElement = function() {
        return div;
    };
    this.setIsVisible = function(b) {
        if (isVisible === b) return;
        isVisible = b;
        contentWrapperEl.style.display = isVisible ? "flex" : "none";
        div.style.marginBottom = isVisible ? "" : "10px";
        let currentState = (0, _klHistory.klHistory).getState();
        if (b && lastDrawnState !== currentState) update();
    };
    //when the layer might have changed
    this.setLayer = function(klCanvasLayerObj) {
        layerObj = klCanvasLayerObj;
        update();
    };
    this.setUiState = function(stateStr) {
        uiState = "" + stateStr;
        if (uiState === "left") (0, _bb.BB).css(largeCanvasWrapper, {
            left: "280px",
            right: ""
        });
        else (0, _bb.BB).css(largeCanvasWrapper, {
            left: "",
            right: "280px"
        });
    };
}

},{"../../../bb/bb":"dcQKo","../../history/kl-history":"klzEn","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aDRkt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * fits image into a size
 * params: {
 *    image: image,
 *    width: int,
 *    height: int
 * }
 *
 * methods:
 * getDiv()
 *
 * @param params
 * @constructor
 */ parcelHelpers.export(exports, "FittedImage", ()=>FittedImage);
var _bb = require("../../../bb/bb");
function FittedImage(params) {
    let fit = (0, _bb.BB).fitInto(params.image.width, params.image.height, params.width, params.height, 1);
    let w = parseInt("" + fit.width);
    let h = parseInt("" + fit.height);
    let canvas = (0, _bb.BB).canvas(w, h);
    canvas.getContext("2d").drawImage(params.image, 0, 0, w, h);
    (0, _bb.BB).css(canvas, {
        display: "block",
        boxShadow: "0 0 0 1px #aaa"
    });
    this.getElement = function() {
        return canvas;
    };
}

},{"../../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aDt10":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "showImportAsLayerDialog", ()=>showImportAsLayerDialog);
var _bb = require("../../../bb/bb");
var _freeTransformCanvas = require("../components/free-transform-canvas");
var _popup = require("./popup");
var _language = require("../../../language/language");
function showImportAsLayerDialog(params) {
    let div = document.createElement("div");
    (0, _bb.BB).appendTextDiv(div, (0, _language.LANG)("import-as-layer-description"));
    if (params.klCanvas.isLayerLimitReached()) {
        let noteEl = (0, _bb.BB).el({
            content: (0, _language.LANG)("import-as-layer-limit-reached"),
            css: {
                background: "#ff0",
                padding: "10px",
                marginTop: "5px",
                marginBottom: "5px",
                border: "1px solid #e7d321",
                borderRadius: "5px"
            }
        });
        div.appendChild(noteEl);
    }
    let isSmall = window.innerWidth < 550;
    let buttonRowEl = (0, _bb.BB).el({
        css: {
            display: "flex"
        }
    });
    let originalSizeBtn = (0, _bb.BB).el({
        tagName: "button",
        content: "1:1",
        css: {
            marginRight: "10px"
        },
        onClick: function() {
            freeTransformCanvas.reset();
        }
    });
    let fitSizeBtn = (0, _bb.BB).el({
        tagName: "button",
        content: (0, _language.LANG)("import-as-layer-fit"),
        css: {
            marginRight: "10px"
        },
        onClick: function() {
            freeTransformCanvas.setTransformFit();
        }
    });
    let centerBtn = (0, _bb.BB).el({
        tagName: "button",
        content: (0, _language.LANG)("center"),
        css: {
            marginRight: "10px"
        },
        onClick: function() {
            freeTransformCanvas.setTransformCenter();
        }
    });
    buttonRowEl.appendChild(originalSizeBtn);
    buttonRowEl.appendChild(fitSizeBtn);
    buttonRowEl.appendChild(centerBtn);
    div.appendChild(buttonRowEl);
    let layers = [];
    {
        let klCanvasLayerArr = params.klCanvas.getLayers();
        for(let i = 0; i < klCanvasLayerArr.length; i++)layers.push({
            image: klCanvasLayerArr[i].context.canvas,
            opacity: klCanvasLayerArr[i].opacity,
            mixModeStr: klCanvasLayerArr[i].mixModeStr
        });
    }
    layers.push({
        image: params.importImage,
        opacity: 1,
        mixModeStr: "source-over"
    });
    let freeTransformCanvas = new (0, _freeTransformCanvas.FreeTransformCanvas)({
        elementWidth: isSmall ? 340 : 540,
        elementHeight: isSmall ? 280 : 350,
        imageWidth: params.klCanvas.getLayerContext(0).canvas.width,
        imageHeight: params.klCanvas.getLayerContext(0).canvas.height,
        layers: layers,
        transformIndex: layers.length - 1
    });
    (0, _bb.BB).css(freeTransformCanvas.getElement(), {
        marginTop: "10px",
        marginLeft: "-20px"
    });
    div.appendChild(freeTransformCanvas.getElement());
    function move(x, y) {
        freeTransformCanvas.move(x, y);
    }
    let keyListener = new (0, _bb.BB).KeyListener({
        onDown: function(keyStr) {
            if (keyStr === "left") move(-1, 0);
            if (keyStr === "right") move(1, 0);
            if (keyStr === "up") move(0, -1);
            if (keyStr === "down") move(0, 1);
        }
    });
    (0, _popup.popup)({
        target: params.target,
        message: `<b>${(0, _language.LANG)("import-as-layer-title")}</b>`,
        div: div,
        style: isSmall ? null : {
            width: "500px"
        },
        buttons: [
            "Ok",
            "Cancel"
        ],
        clickOnEnter: "Ok",
        callback: function(buttonStr) {
            keyListener.destroy();
            freeTransformCanvas.destroy();
            (0, _bb.BB).destroyEl(originalSizeBtn);
            (0, _bb.BB).destroyEl(fitSizeBtn);
            (0, _bb.BB).destroyEl(centerBtn);
            if (buttonStr === "Ok") params.callback(freeTransformCanvas.getTransformation(), freeTransformCanvas.getIsPixelated());
            else params.callback();
        }
    });
}

},{"../../../bb/bb":"dcQKo","../components/free-transform-canvas":"3quPq","./popup":"4Ltiz","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9RVJV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Not really generalized. UI when you drag/drop an image into window.
 * The moment you create it, it will listen.
 *
 * @param p object {onDrop: func(files, optionStr), target: DOM Element, enabledTest: func -> bool} - optionStr: 'default'|'layer'|'image'
 * @constructor
 */ parcelHelpers.export(exports, "KlImageDropper", ()=>KlImageDropper);
var _bb = require("../../../bb/bb");
function KlImageDropper(p) {
    //set up DOM
    let rootEl = (0, _bb.BB).el({
        content: "Drop to import",
        css: {
            paddingTop: "100px",
            position: "fixed",
            left: "0",
            top: "0",
            width: "100%",
            height: "100%",
            background: "rgba(50, 50, 50, 0.7)",
            color: "#fff",
            textShadow: "2px 2px #000",
            textAlign: "center",
            fontSize: "25px"
        }
    });
    let wrapperEl = (0, _bb.BB).el({
        css: {
            "marginTop": "50px",
            "display": "flex",
            "justifyContent": "center"
        }
    });
    let optionStyle = {
        width: "200px",
        padding: "50px",
        margin: "10px",
        //opacity: 0.5,
        borderRadius: "20px",
        border: "1px dashed #fff",
        background: "#00aefe",
        fontWeight: "bold"
    };
    let optionLayerEl = (0, _bb.BB).el({
        content: "As Layer",
        css: optionStyle
    });
    let optionImageEl = (0, _bb.BB).el({
        content: "As New Image",
        css: optionStyle
    });
    rootEl.appendChild(wrapperEl);
    wrapperEl.appendChild(optionLayerEl);
    wrapperEl.appendChild(optionImageEl);
    let rootCounter = 0;
    let optionLayerCounter = 0;
    let optionImageCounter = 0;
    function destroy() {
        rootCounter = 0;
        optionLayerCounter = 0;
        optionImageCounter = 0;
        try {
            p.target.removeChild(rootEl);
        } catch (e) {}
    }
    function testAcceptType(event) {
        try {
            return !event.dataTransfer.types.includes("text/plain");
        } catch (e) {}
        return false;
    }
    function updateOptions() {
        let boxShadow = "0 0 20px 4px #fff";
        if (optionLayerCounter > 0) {
            optionLayerEl.style.boxShadow = boxShadow;
            optionImageEl.style.boxShadow = "";
        } else if (optionImageCounter > 0) {
            optionLayerEl.style.boxShadow = "";
            optionImageEl.style.boxShadow = boxShadow;
        } else {
            optionLayerEl.style.boxShadow = "";
            optionImageEl.style.boxShadow = "";
        }
    }
    (0, _bb.BB).addEventListener(optionLayerEl, "dragenter", function() {
        optionLayerCounter++;
        updateOptions();
    });
    (0, _bb.BB).addEventListener(optionLayerEl, "dragleave", function() {
        optionLayerCounter--;
        updateOptions();
    });
    (0, _bb.BB).addEventListener(optionImageEl, "dragenter", function() {
        optionImageCounter++;
        updateOptions();
    });
    (0, _bb.BB).addEventListener(optionImageEl, "dragleave", function() {
        optionImageCounter--;
        updateOptions();
    });
    function rootDragOver(event) {
        if (!testAcceptType(event)) return;
        event.stopPropagation();
        event.preventDefault();
    }
    function rootDragEnter(event) {
        if (!p.enabledTest() || !testAcceptType(event)) return;
        if (rootCounter === 0) p.target.appendChild(rootEl);
        rootCounter++;
    }
    function rootDragLeave(event) {
        if (!testAcceptType(event) || rootCounter === 0) return;
        rootCounter = Math.max(0, rootCounter - 1);
        if (rootCounter === 0) p.target.removeChild(rootEl);
    }
    function rootDrop(event) {
        if (!testAcceptType(event) || event.dataTransfer.files.length === 0) {
            destroy();
            return;
        }
        event.stopPropagation();
        event.preventDefault();
        let optionStr = "default";
        if (optionLayerCounter > 0) optionStr = "layer";
        else if (optionImageCounter > 0) optionStr = "image";
        p.onDrop(event.dataTransfer.files, optionStr);
        if (rootCounter > 0) p.target.removeChild(rootEl);
        rootCounter = 0;
        optionLayerCounter = 0;
        optionImageCounter = 0;
        updateOptions();
    }
    (0, _bb.BB).addEventListener(window, "dragover", rootDragOver, false);
    (0, _bb.BB).addEventListener(window, "dragenter", rootDragEnter, false);
    (0, _bb.BB).addEventListener(window, "dragleave", rootDragLeave, false);
    (0, _bb.BB).addEventListener(window, "drop", rootDrop, false);
    // if something goes wrong and you're stuck with overlay
    (0, _bb.BB).addEventListener(rootEl, "pointerdown", function() {
        destroy();
    });
    let keyListener = new (0, _bb.BB).KeyListener({
        onDown: function(keyStr) {
            if (rootCounter > 0 && keyStr === "esc") destroy();
        }
    });
}

},{"../../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hWy6k":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Compressed HUD toolspace. When you hold ctrl+alt.
 * small color picker, brush settings
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "OverlayToolspace", ()=>OverlayToolspace);
var _bb = require("../../../bb/bb");
var _klColorSliderSmall = require("../base-components/kl-color-slider-small");
var _klSlider = require("../base-components/kl-slider");
var _language = require("../../../language/language");
function OverlayToolspace(p) {
    const sizeObj = {
        width: 150,
        svHeight: 90,
        hHeight: 20,
        sliderHeight: 25
    };
    let isVisible = false;
    const div = (0, _bb.BB).el({
        css: {
            position: "absolute",
            left: "500px",
            top: "500px",
            background: "rgb(221, 221, 221)",
            display: "none",
            border: "1px solid #fff",
            boxShadow: "0 0 10px rgba(0,0,0,0.5)",
            colorScheme: "only light"
        }
    });
    const queuedObj = {
        color: null,
        size: null,
        opacity: null
    };
    // --- inputs ---
    //color selection
    const colorSlider = new (0, _klColorSliderSmall.KlSmallColorSlider)({
        width: sizeObj.width,
        heightSV: sizeObj.svHeight,
        heightH: sizeObj.hHeight,
        color: p.brushSettingService.getColor(),
        callback: function(rgbObj) {
            selectedColorEl.style.backgroundColor = "rgb(" + rgbObj.r + "," + rgbObj.g + "," + rgbObj.b + ")";
            p.brushSettingService.setColor(rgbObj, subscriptionFunc);
        }
    });
    const selectedColorEl = (0, _bb.BB).el({
        css: {
            width: sizeObj.width + "px",
            height: sizeObj.hHeight + "px",
            pointerEvents: "none"
        }
    });
    {
        const initialColor = p.brushSettingService.getColor();
        selectedColorEl.style.backgroundColor = "rgb(" + initialColor.r + "," + initialColor.g + "," + initialColor.b + ")";
    }
    div.appendChild(selectedColorEl);
    div.appendChild(colorSlider.getElement());
    function updateColor(rgbObj) {
        colorSlider.setColor(rgbObj);
        selectedColorEl.style.backgroundColor = "rgb(" + rgbObj.r + "," + rgbObj.g + "," + rgbObj.b + ")";
    }
    //brushsize slider
    const sizeSlider = new (0, _klSlider.KlSlider)({
        label: (0, _language.LANG)("brush-size"),
        width: sizeObj.width,
        height: sizeObj.sliderHeight,
        min: 0,
        max: 500,
        value: 50,
        resolution: 225,
        eventResMs: 1000 / 30,
        toDisplayValue: (val)=>val * 2,
        toValue: (displayValue)=>displayValue / 2,
        onChange: function(v) {
            p.brushSettingService.setSize(v);
        },
        formatFunc: (displayValue)=>{
            if (displayValue < 10) return (0, _bb.BB).round(displayValue, 1);
            else return Math.round(displayValue);
        }
    });
    (0, _bb.BB).css(sizeSlider.getElement(), {
        marginTop: "2px"
    });
    div.appendChild(sizeSlider.getElement());
    const opacitySlider = new (0, _klSlider.KlSlider)({
        label: (0, _language.LANG)("opacity"),
        width: sizeObj.width,
        height: sizeObj.sliderHeight,
        min: 0,
        max: 1,
        value: 1,
        resolution: 225,
        eventResMs: 1000 / 30,
        toDisplayValue: (val)=>val * 100,
        toValue: (displayValue)=>displayValue / 100,
        onChange: function(v) {
            p.brushSettingService.setOpacity(v);
        }
    });
    (0, _bb.BB).css(opacitySlider.getElement(), {
        margin: "2px 0"
    });
    div.appendChild(opacitySlider.getElement());
    // --- general setup ---
    const subscriptionFunc = function(event) {
        if (event.type === "color") {
            if (!isVisible) queuedObj.color = event.value;
            else updateColor(event.value);
        }
        if (event.type === "size") {
            if (!isVisible) queuedObj.size = event.value;
            else sizeSlider.setValue(event.value);
        }
        if (event.type === "opacity") {
            if (!isVisible) queuedObj.opacity = event.value;
            else opacitySlider.setValue(event.value);
        }
        if (event.type === "sliderConfig") {
            sizeSlider.update(event.value.sizeSlider);
            opacitySlider.update(event.value.opacitySlider);
        }
    };
    p.brushSettingService.subscribe(subscriptionFunc);
    {
        const sliderConfig = p.brushSettingService.getSliderConfig();
        sizeSlider.update(sliderConfig.sizeSlider);
        opacitySlider.update(sliderConfig.opacitySlider);
        sizeSlider.setValue(p.brushSettingService.getSize());
        opacitySlider.setValue(p.brushSettingService.getOpacity());
    }
    function updateUI() {
        // unfocus manual slider input
        (0, _bb.BB).unfocusAnyInput();
        div.style.display = isVisible ? "block" : "none";
        if (isVisible && mousePos) {
            div.style.left = mousePos.x - Math.round(sizeObj.width / 2) + "px";
            div.style.top = mousePos.y - Math.round(sizeObj.svHeight + sizeObj.hHeight * 3 / 2) + "px";
        }
    }
    let mousePos = null;
    (0, _bb.BB).addEventListener(document, "pointermove", function(event) {
        mousePos = {
            x: event.pageX,
            y: event.pageY
        };
    });
    const keyListener = new (0, _bb.BB).KeyListener({
        onDown: function(keyStr, event, comboStr, isRepeat) {
            if (isRepeat) return;
            if (isVisible) {
                isVisible = false;
                updateUI();
                return;
            }
            if (!p.enabledTest() || !mousePos) return;
            if ([
                "ctrl+alt",
                "cmd+alt",
                "alt+ctrl",
                "alt+cmd"
            ].includes(comboStr)) {
                event.preventDefault();
                isVisible = true;
                if (queuedObj.color !== null) {
                    updateColor(queuedObj.color);
                    queuedObj.color = null;
                }
                if (queuedObj.size !== null) {
                    sizeSlider.setValue(queuedObj.size);
                    queuedObj.size = null;
                }
                if (queuedObj.opacity !== null) {
                    opacitySlider.setValue(queuedObj.opacity);
                    queuedObj.opacity = null;
                }
                updateUI();
            }
        },
        onUp: function(keyStr, event, oldComboStr) {
            if ([
                "ctrl+alt",
                "cmd+alt",
                "alt+ctrl",
                "alt+cmd"
            ].includes(oldComboStr) && isVisible) {
                isVisible = false;
                colorSlider.end();
                updateUI();
            }
        },
        onBlur: function() {
            if (isVisible) {
                isVisible = false;
                colorSlider.end();
                updateUI();
            }
        }
    });
    // --- interface ---
    this.getElement = function() {
        return div;
    };
}

},{"../../../bb/bb":"dcQKo","../base-components/kl-color-slider-small":"gZ9fi","../base-components/kl-slider":"6YGce","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fltn0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Topmost row of buttons in toolspace (with the app logo)
 *
 * p = { // button click callbacks
 *      logoImg: img,
 *     onLogo: function(),
 *     onNew: function(),
 *     onImport: function(),
 *     onSave: function(),
 *     onShare: function(),
 *     onHelp: function()
 * }
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "ToolspaceTopRow", ()=>ToolspaceTopRow);
var _bb = require("../../../bb/bb");
// @ts-ignore
var _klecksLogoPng = require("url:~/src/app/img/klecks-logo.png");
var _klecksLogoPngDefault = parcelHelpers.interopDefault(_klecksLogoPng);
// @ts-ignore
var _newImageSvg = require("url:~/src/app/img/ui/new-image.svg");
var _newImageSvgDefault = parcelHelpers.interopDefault(_newImageSvg);
// @ts-ignore
var _importSvg = require("url:~/src/app/img/ui/import.svg");
var _importSvgDefault = parcelHelpers.interopDefault(_importSvg);
// @ts-ignore
var _exportSvg = require("url:~/src/app/img/ui/export.svg");
var _exportSvgDefault = parcelHelpers.interopDefault(_exportSvg);
// @ts-ignore
var _shareSvg = require("url:~/src/app/img/ui/share.svg");
var _shareSvgDefault = parcelHelpers.interopDefault(_shareSvg);
// @ts-ignore
var _helpSvg = require("url:~/src/app/img/ui/help.svg");
var _helpSvgDefault = parcelHelpers.interopDefault(_helpSvg);
var _language = require("../../../language/language");
function ToolspaceTopRow(p) {
    let div = document.createElement("div");
    (0, _bb.BB).css(div, {
        height: "36px",
        //background: '#f00',
        display: "flex",
        backgroundImage: "linear-gradient(to top, rgba(255, 255, 255, 0) 20%, rgba(255, 255, 255, 0.6) 100%)"
    });
    function createButton(p) {
        let padding = 6 + (p.extraPadding ? p.extraPadding : 0);
        let result = (0, _bb.BB).el({
            className: "toolspace-row-button nohighlight",
            title: p.title,
            onClick: p.onClick,
            css: {
                padding: p.contain ? padding + "px 0" : ""
            }
        });
        let im = (0, _bb.BB).el({
            css: {
                backgroundImage: "url('" + p.image + "')",
                backgroundRepeat: "no-repeat",
                backgroundPosition: "center",
                backgroundSize: p.contain ? "contain" : "",
                //filter: 'grayscale(1)',
                height: "100%"
            }
        });
        im.style.pointerEvents = "none";
        result.appendChild(im);
        result.pointerListener = new (0, _bb.BB).PointerListener({
            target: result,
            onEnterLeave: function(isOver) {
                result.classList.toggle("toolspace-row-button-hover", isOver);
            }
        });
        return result;
    }
    let logoButton = createButton({
        onClick: p.onLogo,
        title: (0, _language.LANG)("home"),
        image: p.logoImg ? p.logoImg : (0, _klecksLogoPngDefault.default),
        contain: true
    });
    logoButton.style.width = "45px";
    logoButton.style.borderRight = "1px solid rgb(212, 212, 212)";
    let newButton = createButton({
        onClick: p.onNew,
        title: (0, _language.LANG)("file-new"),
        image: (0, _newImageSvgDefault.default),
        extraPadding: 1,
        contain: true
    });
    let importButton = createButton({
        onClick: p.onImport,
        title: (0, _language.LANG)("file-import"),
        image: (0, _importSvgDefault.default),
        extraPadding: 1,
        contain: true
    });
    let saveButton = createButton({
        onClick: p.onSave,
        title: (0, _language.LANG)("file-save"),
        image: (0, _exportSvgDefault.default),
        extraPadding: 1,
        contain: true
    });
    let shareButton = null;
    if ((0, _bb.BB).canShareFiles()) shareButton = createButton({
        onClick: p.onShare,
        title: (0, _language.LANG)("file-share"),
        image: (0, _shareSvgDefault.default),
        contain: true
    });
    let helpButton = createButton({
        onClick: p.onHelp,
        title: (0, _language.LANG)("help"),
        image: (0, _helpSvgDefault.default),
        contain: true
    });
    div.appendChild(logoButton);
    div.appendChild(newButton);
    div.appendChild(importButton);
    div.appendChild(saveButton);
    if (shareButton) div.appendChild(shareButton);
    div.appendChild(helpButton);
    // --- interface ---
    this.getElement = function() {
        return div;
    };
}

},{"../../../bb/bb":"dcQKo","url:~/src/app/img/klecks-logo.png":"5kpJy","url:~/src/app/img/ui/new-image.svg":"gt6Bq","url:~/src/app/img/ui/import.svg":"6FpPK","url:~/src/app/img/ui/export.svg":"cLBbh","url:~/src/app/img/ui/share.svg":"kDtoI","url:~/src/app/img/ui/help.svg":"c0SPg","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5kpJy":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "klecks-logo.50dcc3be.png" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"gt6Bq":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "new-image.0e74b5b6.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"6FpPK":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "import.2faf5a14.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"cLBbh":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "export.822eaf7b.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"kDtoI":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "share.dd2df5e4.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"c0SPg":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "help.661530ce.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"3fI3r":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Toolrow Dropdown. The button where you select: brush, fill, select, transform, etc.
 *
 * p = {
 *     onChange: func(activeStr)
 * }
 *
 * activeStr = 'draw' | 'fill' | 'text' | 'shape' | 'gradient'
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "ToolDropdown", ()=>ToolDropdown);
var _bb = require("../../../bb/bb");
var _modalCount = require("../modals/modal-count");
// @ts-ignore
var _toolPaintSvg = require("url:~/src/app/img/ui/tool-paint.svg");
var _toolPaintSvgDefault = parcelHelpers.interopDefault(_toolPaintSvg);
// @ts-ignore
var _toolFillSvg = require("url:~/src/app/img/ui/tool-fill.svg");
var _toolFillSvgDefault = parcelHelpers.interopDefault(_toolFillSvg);
// @ts-ignore
var _toolGradientSvg = require("url:~/src/app/img/ui/tool-gradient.svg");
var _toolGradientSvgDefault = parcelHelpers.interopDefault(_toolGradientSvg);
// @ts-ignore
var _toolTextSvg = require("url:~/src/app/img/ui/tool-text.svg");
var _toolTextSvgDefault = parcelHelpers.interopDefault(_toolTextSvg);
// @ts-ignore
var _toolShapeSvg = require("url:~/src/app/img/ui/tool-shape.svg");
var _toolShapeSvgDefault = parcelHelpers.interopDefault(_toolShapeSvg);
// @ts-ignore
var _caretDownSvg = require("url:~/src/app/img/ui/caret-down.svg");
var _caretDownSvgDefault = parcelHelpers.interopDefault(_caretDownSvg);
var _language = require("../../../language/language");
function ToolDropdown(p) {
    let optionArr = [
        "draw",
        "fill",
        "gradient",
        "text",
        "shape"
    ];
    let imArr = [
        (0, _toolPaintSvgDefault.default),
        (0, _toolFillSvgDefault.default),
        (0, _toolGradientSvgDefault.default),
        (0, _toolTextSvgDefault.default),
        (0, _toolShapeSvgDefault.default)
    ];
    let titleArr = [
        `${(0, _language.LANG)("tool-brush")} [B]`,
        `${(0, _language.LANG)("tool-paint-bucket")} [G]`,
        `${(0, _language.LANG)("tool-gradient")} [G]`,
        `${(0, _language.LANG)("tool-text")} [T]`,
        `${(0, _language.LANG)("tool-shape")} [U]`, 
    ];
    let currentActiveIndex = 0;
    let isActive = true;
    let isOpen = false;
    //preload images
    setTimeout(function() {
        for(let i = 1; i < imArr.length; i++){
            let im = new Image();
            im.src = imArr[i];
        }
    }, 100);
    let smallMargin = "6px 0";
    let div = (0, _bb.BB).el({
        css: {
            position: "relative",
            flexGrow: "1"
        }
    });
    let openTimeout;
    let isDragging = false;
    let startX, startY;
    let pointerListener;
    if ((0, _bb.BB).hasPointerEvents) pointerListener = new (0, _bb.BB).PointerListener({
        target: div,
        maxPointers: 1,
        onPointer: function(event) {
            if (event.type === "pointerdown") {
                if (isOpen) return;
                openTimeout = setTimeout(function() {
                    showDropdown();
                }, 400);
                isDragging = true;
                startX = event.pageX;
                startY = event.pageY;
            } else if (event.type === "pointermove") {
                if (isDragging && !isOpen && (0, _bb.BB).dist(startX, startY, event.pageX, event.pageY) > 5) {
                    clearTimeout(openTimeout);
                    showDropdown();
                }
            } else if (event.type === "pointerup") {
                clearTimeout(openTimeout);
                if (isOpen && isDragging) {
                    let target = document.elementFromPoint(event.pageX, event.pageY);
                    for(let i = 0; i < dropdownBtnArr.length; i++)if (target === dropdownBtnArr[i].wrapper) {
                        closeDropdown();
                        isActive = true;
                        currentActiveIndex = i;
                        updateButton();
                        p.onChange(optionArr[currentActiveIndex]);
                        break;
                    }
                }
                isDragging = false;
            }
        }
    });
    let activeButton = (0, _bb.BB).el({
        parent: div,
        className: "toolspace-row-button nohighlight toolspace-row-button-activated",
        title: titleArr[currentActiveIndex],
        onClick: function(e) {
            if (isActive && !isOpen) {
                e.preventDefault();
                e.stopPropagation();
                showDropdown();
                return;
            }
            isActive = true;
            p.onChange(optionArr[currentActiveIndex]);
            if (isOpen) closeDropdown();
        },
        css: {
            padding: "10px 0",
            pointerEvents: "auto",
            height: "100%",
            boxSizing: "border-box"
        }
    });
    let activeButtonIm = (0, _bb.BB).el({
        parent: activeButton,
        css: {
            backgroundRepeat: "no-repeat",
            backgroundPosition: "center",
            backgroundSize: "contain",
            width: "calc(100% - 7px)",
            height: "100%",
            pointerEvents: "none",
            opacity: "0.75"
        }
    });
    let arrowButton = (0, _bb.BB).el({
        parent: activeButton,
        css: {
            position: "absolute",
            right: "1px",
            bottom: "1px",
            width: "18px",
            height: "18px",
            //background: '#aaa',
            //borderRadius: '2px',
            cursor: "pointer",
            backgroundImage: "url('" + (0, _caretDownSvgDefault.default) + "')",
            backgroundRepeat: "no-repeat",
            backgroundPosition: "center",
            backgroundSize: "60%"
        },
        title: "More Tools",
        onClick: function(e) {
            e.preventDefault();
            e.stopPropagation();
            showDropdown();
        }
    });
    let overlay = (0, _bb.BB).el({
        css: {
            position: "absolute",
            //background: 'rgba(255,0,0,0.5)',
            left: "0",
            top: "0",
            right: "0",
            bottom: "0"
        }
    });
    let overlayPointerListener = new (0, _bb.BB).PointerListener({
        target: overlay,
        pointers: 1,
        onPointer: function(e) {
            if (e.type === "pointerdown") {
                e.eventPreventDefault();
                closeDropdown();
            }
        }
    });
    let dropdownWrapper = (0, _bb.BB).el({
        className: "tool-dropdown-wrapper",
        css: {
            position: "absolute",
            width: "100%",
            height: 100 * (optionArr.length - 1) + "%",
            top: "100%",
            left: "0",
            zIndex: "1",
            boxSizing: "border-box",
            cursor: "pointer",
            transition: "height 0.1s ease-in-out, opacity 0.1s ease-in-out",
            borderBottomLeftRadius: "5px",
            borderBottomRightRadius: "5px",
            overflow: "hidden"
        }
    });
    let dropdownBtnArr = [];
    function createDropdownButton(p) {
        let result = {};
        let wrapper = (0, _bb.BB).el({
            parent: dropdownWrapper,
            className: "tool-dropdown-button",
            title: p.title,
            css: {
                padding: "10px 0",
                height: 100 / (optionArr.length - 1) + "%",
                boxSizing: "border-box"
            },
            onClick: function(e) {
                e.preventDefault();
                e.stopPropagation();
                p.onClick(p.index, p.id);
            }
        });
        result.wrapper = wrapper;
        let im = (0, _bb.BB).el({
            parent: wrapper,
            css: {
                backgroundImage: "url('" + p.image + "')",
                backgroundRepeat: "no-repeat",
                backgroundPosition: "center",
                backgroundSize: "contain",
                height: "100%",
                pointerEvents: "none",
                opacity: "0.75"
            }
        });
        // --- interface ---
        result.show = function(b) {
            wrapper.style.display = b ? "block" : "none";
        };
        result.setIsSmall = function(b) {
            wrapper.style.padding = b ? smallMargin : "10px 0";
        };
        return result;
    }
    function onClickDropdownBtn(index, id) {
        closeDropdown();
        isActive = true;
        currentActiveIndex = index;
        updateButton();
        p.onChange(optionArr[currentActiveIndex]);
    }
    for(let i = 0; i < optionArr.length; i++)dropdownBtnArr.push(createDropdownButton({
        index: i,
        id: optionArr[i],
        image: imArr[i],
        title: titleArr[i],
        onClick: onClickDropdownBtn
    }));
    function showDropdown() {
        (0, _modalCount.dialogCounter).increase(0.5);
        isOpen = true;
        for(let i = 0; i < optionArr.length; i++)dropdownBtnArr[i].show(currentActiveIndex !== i);
        arrowButton.style.display = "none";
        div.style.zIndex = "1";
        document.body.appendChild(overlay);
        div.appendChild(dropdownWrapper);
    }
    function closeDropdown() {
        (0, _modalCount.dialogCounter).decrease(0.5);
        isOpen = false;
        arrowButton.style.removeProperty("display");
        div.style.removeProperty("z-index");
        document.body.removeChild(overlay);
        div.removeChild(dropdownWrapper);
    }
    function updateButton() {
        activeButton.title = titleArr[currentActiveIndex];
        activeButtonIm.style.backgroundImage = "url('" + imArr[currentActiveIndex] + "')";
    }
    updateButton();
    // --- interface ---
    this.setIsSmall = function(b) {
        activeButton.style.padding = b ? smallMargin : "10px 0";
        for(let i = 0; i < optionArr.length; i++)dropdownBtnArr[i].setIsSmall(b);
        if (b) {
            arrowButton.style.width = "14px";
            arrowButton.style.height = "14px";
        } else {
            arrowButton.style.width = "18px";
            arrowButton.style.height = "18px";
        }
    };
    this.setActive = function(activeStr) {
        if (optionArr.includes(activeStr)) {
            isActive = true;
            for(let i = 0; i < optionArr.length; i++)if (optionArr[i] === activeStr) {
                currentActiveIndex = i;
                break;
            }
            activeButton.classList.add("toolspace-row-button-activated");
            updateButton();
        } else {
            isActive = false;
            activeButton.classList.remove("toolspace-row-button-activated");
        }
    };
    this.getActive = function() {
        return optionArr[currentActiveIndex];
    };
    this.getElement = function() {
        return div;
    };
}

},{"../../../bb/bb":"dcQKo","../modals/modal-count":"lsSVM","url:~/src/app/img/ui/tool-paint.svg":"kLkxS","url:~/src/app/img/ui/tool-fill.svg":"dcadi","url:~/src/app/img/ui/tool-gradient.svg":"4GC9I","url:~/src/app/img/ui/tool-text.svg":"cQlT4","url:~/src/app/img/ui/tool-shape.svg":"4ddc9","url:~/src/app/img/ui/caret-down.svg":"hBki2","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kLkxS":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "tool-paint.491ea800.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"dcadi":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "tool-fill.78dd7c84.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"4GC9I":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "tool-gradient.21f1022a.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"cQlT4":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "tool-text.75eca96c.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"4ddc9":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "tool-shape.ed4e0ce8.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"hBki2":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "caret-down.52fe4690.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"eTege":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Row of buttons in toolspace. image-operations (draw, hand), zoom, undo/redo
 * Need to do syncing. So tool is correct, and zoom/undo/redo buttons are properly enabled/disabled
 * heights: 54px tall, 36px small -> via setIsSmall
 *
 * p = {
 *     onActivate: function(activeStr), // clicking on tool button - activating it
 *     onZoomIn: function(),
 *     onZoomOut: function(),
 *     onUndo: function(),
 *     onRedo: function(),
 * }
 *
 * activeStr = 'draw' | 'hand' | 'fill' | 'text'
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "ToolspaceToolRow", ()=>ToolspaceToolRow);
var _bb = require("../../../bb/bb");
var _toolDropdown = require("./tool-dropdown");
// @ts-ignore
var _toolHandSvg = require("url:~/src/app/img/ui/tool-hand.svg");
var _toolHandSvgDefault = parcelHelpers.interopDefault(_toolHandSvg);
// @ts-ignore
var _toolZoomInSvg = require("url:~/src/app/img/ui/tool-zoom-in.svg");
var _toolZoomInSvgDefault = parcelHelpers.interopDefault(_toolZoomInSvg);
// @ts-ignore
var _toolZoomOutSvg = require("url:~/src/app/img/ui/tool-zoom-out.svg");
var _toolZoomOutSvgDefault = parcelHelpers.interopDefault(_toolZoomOutSvg);
// @ts-ignore
var _toolUndoSvg = require("url:~/src/app/img/ui/tool-undo.svg");
var _toolUndoSvgDefault = parcelHelpers.interopDefault(_toolUndoSvg);
var _language = require("../../../language/language");
function ToolspaceToolRow(p) {
    let div = document.createElement("div");
    (0, _bb.BB).css(div, {
        height: "54px",
        //height: '36px',
        display: "flex",
        backgroundImage: "linear-gradient(to top, rgba(255, 255, 255, 0) 20%, rgba(255, 255, 255, 0.6) 100%)"
    });
    let currentActiveStr = "draw"; // 'draw' | 'hand' | 'fill'
    function setActive(activeStr, doEmit) {
        if (currentActiveStr === activeStr) return;
        currentActiveStr = activeStr;
        toolDropdown.setActive(currentActiveStr);
        handButton.classList.toggle("toolspace-row-button-activated", currentActiveStr === "hand");
        if (doEmit) p.onActivate(currentActiveStr);
    }
    function createButton(p) {
        let smallMargin = p.doLighten ? "6px 0" : "8px 0";
        let result = (0, _bb.BB).el({
            className: "toolspace-row-button nohighlight",
            //title: p.title,
            onClick: p.onClick,
            css: {
                padding: p.contain ? "10px 0" : ""
            }
        });
        let im = (0, _bb.BB).el({
            css: {
                backgroundImage: "url('" + p.image + "')",
                backgroundRepeat: "no-repeat",
                backgroundPosition: "center",
                backgroundSize: p.contain ? "contain" : "",
                //filter: 'grayscale(1)',
                height: "100%",
                transform: p.doMirror ? "scale(-1, 1)" : "",
                pointerEvents: "none",
                opacity: p.doLighten ? "0.75" : "1"
            }
        });
        result.appendChild(im);
        result.pointerListener = new (0, _bb.BB).PointerListener({
            target: result,
            onEnterLeave: function(isOver) {
                result.classList.toggle("toolspace-row-button-hover", isOver);
            }
        });
        result.setIsSmall = function(b) {
            result.style.padding = p.contain ? b ? smallMargin : "10px 0" : "";
        };
        return result;
    }
    function createTriangleButton(p) {
        let result = document.createElement("div");
        (0, _bb.BB).css(result, {
            flexGrow: "1",
            position: "relative"
        });
        let svg = (0, _bb.BB).createSvg({
            elementType: "svg",
            width: "67px",
            height: "54px",
            viewBox: "0 0 100 100",
            preserveAspectRatio: "none"
        });
        (0, _bb.BB).css(svg, {
            position: "absolute",
            left: "0",
            top: "0"
        });
        let blurRadius = 10;
        let blurOffsetX = 2;
        let blurOffsetY = 2;
        let defs = (0, _bb.BB).createSvg({
            elementType: "defs",
            childrenArr: [
                {
                    elementType: "filter",
                    id: "innershadow",
                    x0: "-50%",
                    y0: "-50%",
                    width: "200%",
                    height: "200%",
                    childrenArr: [
                        {
                            elementType: "feGaussianBlur",
                            in: "SourceAlpha",
                            stdDeviation: "" + blurRadius,
                            result: "blur"
                        },
                        {
                            elementType: "feOffset",
                            dx: "" + blurOffsetX,
                            dy: "" + blurOffsetY
                        },
                        {
                            elementType: "feComposite",
                            in2: "SourceAlpha",
                            operator: "arithmetic",
                            k2: "-1",
                            k3: "1",
                            result: "shadowDiff"
                        },
                        {
                            elementType: "feFlood",
                            "flood-color": "#000",
                            "flood-opacity": "0.2"
                        },
                        {
                            elementType: "feComposite",
                            in2: "shadowDiff",
                            operator: "in"
                        },
                        {
                            elementType: "feComposite",
                            in2: "SourceGraphic",
                            operator: "over",
                            result: "firstfilter"
                        },
                        {
                            elementType: "feGaussianBlur",
                            in: "firstfilter",
                            stdDeviation: "" + blurRadius,
                            result: "blur2"
                        },
                        {
                            elementType: "feOffset",
                            dx: "" + blurOffsetX,
                            dy: "" + blurOffsetY
                        },
                        {
                            elementType: "feComposite",
                            in2: "firstfilter",
                            operator: "arithmetic",
                            k2: "-1",
                            k3: "1",
                            result: "shadowDiff"
                        },
                        {
                            elementType: "feFlood",
                            "flood-color": "#000",
                            "flood-opacity": "0.2"
                        },
                        {
                            elementType: "feComposite",
                            in2: "shadowDiff",
                            operator: "in"
                        },
                        {
                            elementType: "feComposite",
                            in2: "firstfilter",
                            operator: "over"
                        }
                    ]
                }
            ]
        });
        let svgTriangleLeft = (0, _bb.BB).createSvg({
            elementType: "path",
            "vector-effect": "non-scaling-stroke",
            d: "M0,0 L 100,0 0,100 z",
            fill: "rgba(0,0,0,0)",
            class: "toolspace-svg-triangle-button"
        });
        svgTriangleLeft.onclick = function() {
            p.onLeft();
            svgTriangleLeft.classList.remove("toolspace-svg-triangle-button-hover");
        };
        let svgTriangleRight = (0, _bb.BB).createSvg({
            elementType: "path",
            "vector-effect": "non-scaling-stroke",
            d: "M100,100 L 100,0 0,100 z",
            fill: "rgba(0,0,0,0)",
            class: "toolspace-svg-triangle-button"
        });
        svgTriangleRight.onclick = function() {
            p.onRight();
            svgTriangleRight.classList.remove("toolspace-svg-triangle-button-hover");
        };
        // because :hover causes problems w touch
        result.leftPointerListener = new (0, _bb.BB).PointerListener({
            target: svgTriangleLeft,
            onEnterLeave: function(isOver) {
                svgTriangleLeft.classList.toggle("toolspace-svg-triangle-button-hover", isOver);
            }
        });
        result.rightPointerListener = new (0, _bb.BB).PointerListener({
            target: svgTriangleRight,
            onEnterLeave: function(isOver) {
                svgTriangleRight.classList.toggle("toolspace-svg-triangle-button-hover", isOver);
            }
        });
        svg.appendChild(defs);
        svg.appendChild(svgTriangleLeft);
        svg.appendChild(svgTriangleRight);
        result.appendChild(svg);
        let leftIm = (0, _bb.BB).el({
            css: {
                backgroundImage: "url('" + p.leftImage + "')",
                backgroundRepeat: "no-repeat",
                backgroundSize: "contain",
                width: "20px",
                height: "20px",
                position: "absolute",
                left: "10px",
                top: "8px",
                //transform: p.doMirror ? 'scale(-1, 1)' : '',
                pointerEvents: "none"
            }
        });
        result.appendChild(leftIm);
        let rightIm = (0, _bb.BB).el({
            css: {
                backgroundImage: "url('" + (p.rightImage ? p.rightImage : p.leftImage) + "')",
                backgroundRepeat: "no-repeat",
                backgroundSize: "contain",
                width: "20px",
                height: "20px",
                position: "absolute",
                right: "10px",
                bottom: "8px",
                transform: p.rightImage ? "" : "scale(-1, 1)",
                pointerEvents: "none"
            }
        });
        result.appendChild(rightIm);
        result.setIsEnabledLeft = function(b) {
            svgTriangleLeft.classList.toggle("toolspace-row-button-disabled", !b);
            leftIm.classList.toggle("toolspace-row-button-disabled", !b);
        };
        result.setIsEnabledRight = function(b) {
            svgTriangleRight.classList.toggle("toolspace-row-button-disabled", !b);
            rightIm.classList.toggle("toolspace-row-button-disabled", !b);
        };
        return result;
    }
    function createTriangleButtonViaClipPath(p) {
        let result = document.createElement("div");
        (0, _bb.BB).css(result, {
            flexGrow: "1",
            position: "relative"
        });
        let leftButton = (0, _bb.BB).el({
            className: "toolspace-triangle-button",
            onClick: p.onLeft,
            css: {
                clipPath: "polygon(0% 0%, 100% 0%, 100% 0%, 0% 100%)"
            }
        });
        let leftIm = (0, _bb.BB).el({
            css: {
                backgroundImage: "url('" + p.leftImage + "')",
                backgroundRepeat: "no-repeat",
                backgroundSize: "contain",
                width: "20px",
                height: "20px",
                position: "absolute",
                left: "10px",
                top: "8px",
                //transform: p.doMirror ? 'scale(-1, 1)' : '',
                pointerEvents: "none"
            }
        });
        leftButton.appendChild(leftIm);
        let rightButton = (0, _bb.BB).el({
            className: "toolspace-triangle-button",
            onClick: p.onRight,
            css: {
                clipPath: "polygon(0% 100%, 100% 0%, 100% 100%, 0% 100%)"
            }
        });
        let rightIm = (0, _bb.BB).el({
            css: {
                backgroundImage: "url('" + (p.rightImage ? p.rightImage : p.leftImage) + "')",
                backgroundRepeat: "no-repeat",
                backgroundSize: "contain",
                width: "20px",
                height: "20px",
                position: "absolute",
                right: "10px",
                bottom: "8px",
                transform: p.rightImage ? "" : "scale(-1, 1)",
                pointerEvents: "none"
            }
        });
        rightButton.appendChild(rightIm);
        result.appendChild(leftButton);
        result.appendChild(rightButton);
        // because :hover causes problems w touch
        result.leftPointerListener = new (0, _bb.BB).PointerListener({
            target: leftButton,
            onEnterLeave: function(isOver) {
                leftButton.classList.toggle("toolspace-row-button-hover", isOver);
            }
        });
        result.rightPointerListener = new (0, _bb.BB).PointerListener({
            target: rightButton,
            onEnterLeave: function(isOver) {
                rightButton.classList.toggle("toolspace-row-button-hover", isOver);
            }
        });
        result.setIsEnabledLeft = function(b) {
            leftButton.classList.toggle("toolspace-row-button-disabled", !b);
        };
        result.setIsEnabledRight = function(b) {
            rightButton.classList.toggle("toolspace-row-button-disabled", !b);
        };
        return result;
    }
    let toolDropdown = new (0, _toolDropdown.ToolDropdown)({
        onChange: function(activeStr) {
            setActive(activeStr, true);
        }
    });
    div.appendChild(toolDropdown.getElement());
    let handButton = createButton({
        onClick: function() {
            setActive("hand", true);
        },
        image: (0, _toolHandSvgDefault.default),
        contain: true,
        doLighten: true
    });
    handButton.style.borderRight = "1px solid rgb(212, 212, 212)";
    handButton.title = (0, _language.LANG)("tool-hand");
    div.appendChild(handButton);
    let zoomInNOutButton = createTriangleButton({
        onLeft: p.onZoomIn,
        onRight: p.onZoomOut,
        leftImage: (0, _toolZoomInSvgDefault.default),
        rightImage: (0, _toolZoomOutSvgDefault.default)
    });
    zoomInNOutButton.title = (0, _language.LANG)("tool-zoom");
    div.appendChild(zoomInNOutButton);
    let zoomInButton = createButton({
        onClick: p.onZoomIn,
        image: (0, _toolZoomInSvgDefault.default),
        contain: true
    });
    zoomInButton.title = (0, _language.LANG)("zoom-in");
    div.appendChild(zoomInButton);
    let zoomOutButton = createButton({
        onClick: p.onZoomOut,
        image: (0, _toolZoomOutSvgDefault.default),
        contain: true
    });
    zoomOutButton.title = (0, _language.LANG)("zoom-out");
    div.appendChild(zoomOutButton);
    let undoNRedoButton = createTriangleButton({
        onLeft: p.onUndo,
        onRight: p.onRedo,
        leftImage: (0, _toolUndoSvgDefault.default),
        rightImage: null
    });
    undoNRedoButton.title = (0, _language.LANG)("tool-undo-redo");
    undoNRedoButton.setIsEnabledLeft(false);
    undoNRedoButton.setIsEnabledRight(false);
    div.appendChild(undoNRedoButton);
    let undoButton = createButton({
        onClick: p.onUndo,
        image: (0, _toolUndoSvgDefault.default),
        contain: true
    });
    undoButton.title = (0, _language.LANG)("undo");
    undoButton.classList.add("toolspace-row-button-disabled");
    div.appendChild(undoButton);
    let redoButton = createButton({
        onClick: p.onRedo,
        image: (0, _toolUndoSvgDefault.default),
        contain: true,
        doMirror: true
    });
    redoButton.title = (0, _language.LANG)("redo");
    redoButton.classList.add("toolspace-row-button-disabled");
    div.appendChild(redoButton);
    zoomInButton.style.display = "none";
    zoomOutButton.style.display = "none";
    undoButton.style.display = "none";
    redoButton.style.display = "none";
    // --- interface ---
    this.getElement = function() {
        return div;
    };
    this.setIsSmall = function(b) {
        (0, _bb.BB).css(div, {
            height: b ? "36px" : "54px"
        });
        toolDropdown.setIsSmall(b);
        handButton.setIsSmall(b);
        zoomInButton.setIsSmall(b);
        zoomOutButton.setIsSmall(b);
        undoButton.setIsSmall(b);
        redoButton.setIsSmall(b);
        if (b) {
            zoomInNOutButton.style.display = "none";
            undoNRedoButton.style.display = "none";
            zoomInButton.style.display = "block";
            zoomOutButton.style.display = "block";
            undoButton.style.display = "block";
            redoButton.style.display = "block";
        } else {
            zoomInNOutButton.style.display = "block";
            undoNRedoButton.style.display = "block";
            zoomInButton.style.display = "none";
            zoomOutButton.style.display = "none";
            undoButton.style.display = "none";
            redoButton.style.display = "none";
        }
    };
    this.setEnableZoomIn = function(b) {
        zoomInButton.classList.toggle("toolspace-row-button-disabled", !b);
        zoomInNOutButton.setIsEnabledLeft(b);
    };
    this.setEnableZoomOut = function(b) {
        zoomOutButton.classList.toggle("toolspace-row-button-disabled", !b);
        zoomInNOutButton.setIsEnabledRight(b);
    };
    this.setEnableUndo = function(b) {
        undoButton.classList.toggle("toolspace-row-button-disabled", !b);
        undoNRedoButton.setIsEnabledLeft(b);
    };
    this.setEnableRedo = function(b) {
        redoButton.classList.toggle("toolspace-row-button-disabled", !b);
        undoNRedoButton.setIsEnabledRight(b);
    };
    this.setActive = function(activeStr) {
        setActive(activeStr);
    };
    this.getActive = function() {
        return currentActiveStr;
    };
}

},{"../../../bb/bb":"dcQKo","./tool-dropdown":"3fI3r","url:~/src/app/img/ui/tool-hand.svg":"gqsT0","url:~/src/app/img/ui/tool-zoom-in.svg":"bPttw","url:~/src/app/img/ui/tool-zoom-out.svg":"4NGgM","url:~/src/app/img/ui/tool-undo.svg":"db6Fa","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gqsT0":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "tool-hand.5d28f3c5.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"bPttw":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "tool-zoom-in.08f48a21.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"4NGgM":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "tool-zoom-out.16f7d078.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"db6Fa":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "tool-undo.f047eac2.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"84zrw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Ui to select stabilizer level. 4 options. returned as 0-3
 *
 * p = {
 *     smoothing: number, // initial level 0-3
 *     onSelect: function(level number) // 0-3, when level changes
 * }
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "ToolspaceStabilizerRow", ()=>ToolspaceStabilizerRow);
var _bb = require("../../../bb/bb");
var _select = require("../base-components/select");
var _language = require("../../../language/language");
function ToolspaceStabilizerRow(p) {
    let div = (0, _bb.BB).el({
        tagName: "label",
        content: (0, _language.LANG)("stabilizer") + "&nbsp;",
        title: (0, _language.LANG)("stabilizer-title"),
        css: {
            display: "flex",
            alignItems: "center",
            fontSize: "13px",
            color: "rgba(0,0,0,0.6)"
        }
    });
    let strengthSelect = new (0, _select.Select)({
        optionArr: [
            [
                "0",
                "0"
            ],
            [
                "1",
                "1"
            ],
            [
                "2",
                "2"
            ],
            [
                "3",
                "3"
            ],
            [
                "4",
                "4"
            ],
            [
                "5",
                "5"
            ]
        ],
        initValue: p.smoothing,
        onChange: function(val) {
            p.onSelect(parseInt(val));
        }
    });
    div.appendChild(strengthSelect.getElement());
    let pointerListener = new (0, _bb.BB).PointerListener({
        target: div,
        onWheel: function(e) {
            strengthSelect.setDeltaValue(e.deltaY);
        }
    });
    // --- interface ---
    this.getElement = function() {
        return div;
    };
}

},{"../../../bb/bb":"dcQKo","../base-components/select":"7mzRU","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fLnal":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * row of tabs. uses css class .tabrow-tab
 *
 * p = {
 *     initialId: string, // e.g. 'draw'
 *     useAccent: boolean,
 *     tabArr: [
 *         {
 *             id: string, // e.g. 'draw',
 *             label: string, // optional
 *             image: string, // optional background image
 *             title: string, // optional
 *             isVisible: boolean, // optional - default is true
 *             onOpen: function(),
 *             onClose: function(),
 *             css: {...},
 *         }
 *     ]
 * }
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "TabRow", ()=>TabRow);
var _bb = require("../../../bb/bb");
// @ts-ignore
var _invertedBorderSvg = require("url:~/src/app/img/ui/inverted-border.svg");
var _invertedBorderSvgDefault = parcelHelpers.interopDefault(_invertedBorderSvg);
function TabRow(p) {
    let _this = this;
    let height = 35;
    let div = (0, _bb.BB).el({
        className: "tabrow",
        css: {
            height: height + "px"
        }
    });
    let tabArr = []; //creates its own internal arr
    let openedTabObj = null;
    const roundSize = 10;
    const roundRight = (0, _bb.BB).el({
        css: {
            width: roundSize + "px",
            height: roundSize + "px",
            backgroundImage: `url('${(0, _invertedBorderSvgDefault.default)}')`,
            backgroundSize: "cover",
            position: "absolute",
            right: -roundSize + "px",
            bottom: "0",
            pointerEvents: "none"
        }
    });
    const roundLeft = (0, _bb.BB).el({
        css: {
            width: roundSize + "px",
            height: roundSize + "px",
            backgroundImage: `url('${(0, _invertedBorderSvgDefault.default)}')`,
            backgroundSize: "cover",
            position: "absolute",
            left: -roundSize + "px",
            bottom: "0",
            transform: "scale(-1,1)",
            pointerEvents: "none"
        }
    });
    function createTab(pTabObj, initialId, useAccent) {
        let result = {
            id: pTabObj.id,
            isVisible: "isVisible" in pTabObj ? pTabObj.isVisible : true,
            onOpen: pTabObj.onOpen,
            onClose: pTabObj.onClose,
            update: function(openedTabObj) {
                tabDiv.className = openedTabObj === result ? useAccent ? "tabrow-tab tabrow-tab-opened-accented" : "tabrow-tab tabrow-tab-opened" : "tabrow-tab";
                tabDiv.style.display = result.isVisible ? "block" : "none";
            }
        };
        let tabDiv = (0, _bb.BB).el({
            content: "label" in pTabObj ? pTabObj.label : "",
            title: "title" in pTabObj ? pTabObj.title : undefined,
            className: initialId === result.id ? useAccent ? "tabrow-tab tabrow-tab-opened-accented" : "tabrow-tab tabrow-tab-opened" : "tabrow-tab",
            css: {
                lineHeight: height + "px",
                display: result.isVisible ? "block" : "none",
                zIndex: "0"
            },
            onClick: function() {
                if (openedTabObj === result) return;
                _this.open(result.id);
            }
        });
        result.div = tabDiv;
        if ("image" in pTabObj) (0, _bb.BB).css(tabDiv, {
            backgroundImage: "url('" + pTabObj.image + "')",
            backgroundSize: height - 7 + "px"
        });
        if ("css" in pTabObj) (0, _bb.BB).css(tabDiv, pTabObj.css);
        div.appendChild(tabDiv);
        let pointerListener = new (0, _bb.BB).PointerListener({
            target: tabDiv,
            onEnterLeave: function(isOver) {
                tabDiv.classList.toggle("tabrow-tab-hover", isOver);
            }
        });
        if (initialId === result.id) {
            result.onOpen();
            result.div.appendChild(roundRight);
            result.div.appendChild(roundLeft);
        } else result.onClose();
        return result;
    }
    for(let i = 0; i < p.tabArr.length; i++)tabArr.push(createTab(p.tabArr[i], p.initialId, p.useAccent));
    for(let i1 = 0; i1 < tabArr.length; i1++)if (tabArr[i1].id === p.initialId) openedTabObj = tabArr[i1];
    if (openedTabObj === null) throw "invalid initialId";
    function update() {
        for(let i = 0; i < tabArr.length; i++)tabArr[i].update(openedTabObj);
    }
    // --- interface ---
    this.getElement = function() {
        return div;
    };
    this.open = function(tabId) {
        for(let i = 0; i < tabArr.length; i++)if (tabArr[i].id === tabId) {
            if (openedTabObj === tabArr[i]) return;
            openedTabObj.onClose();
            openedTabObj = tabArr[i];
            openedTabObj.onOpen();
            openedTabObj.div.appendChild(roundRight);
            openedTabObj.div.appendChild(roundLeft);
            update();
            return;
        }
        throw "TabRow.open - invalid tabId";
    };
    this.getOpenedTabId = function() {
        return "" + openedTabObj.id;
    };
    this.setIsVisible = function(tabId, isVisible) {
        for(let i = 0; i < tabArr.length; i++)if (tabArr[i].id === tabId) {
            tabArr[i].isVisible = !!isVisible;
            update();
            return;
        }
        throw "TabRow.setIsVisible - invalid tabId";
    };
}

},{"../../../bb/bb":"dcQKo","url:~/src/app/img/ui/inverted-border.svg":"dCUft","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dCUft":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "inverted-border.635f92fd.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"brsBa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Ui, when hand tool tab is open.
 *
 * p = {
 *     scale: number, // initial value
 *     angleDeg: number, // initial value
 *     onReset: function(),
 *     onFit: function(),
 *     onAngleChange: function(angleDeg number, isRelative number)
 * }
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "HandUi", ()=>HandUi);
var _bb = require("../../../bb/bb");
// @ts-ignore
var _angleSvg = require("url:~/src/app/img/ui/angle.svg");
var _angleSvgDefault = parcelHelpers.interopDefault(_angleSvg);
// @ts-ignore
var _editRotateSvg = require("url:~/src/app/img/ui/edit-rotate.svg");
var _editRotateSvgDefault = parcelHelpers.interopDefault(_editRotateSvg);
var _language = require("../../../language/language");
function HandUi(p) {
    let div = (0, _bb.BB).el({
        css: {
            margin: "10px"
        }
    });
    let isVisible = true;
    let scale = p.scale;
    let angleDeg = p.angleDeg;
    let row1 = (0, _bb.BB).el({
        css: {
            marginBottom: "10px",
            display: "flex"
        }
    });
    let row2 = (0, _bb.BB).el({
        css: {
            display: "flex",
            marginBottom: "10px"
        }
    });
    let row3 = (0, _bb.BB).el({
        css: {
            display: "flex"
        }
    });
    div.append(row1, row2, row3);
    let scaleEl = (0, _bb.BB).el({
        css: {
            width: "55px",
            userSelect: "none"
        }
    });
    row1.appendChild(scaleEl);
    let angleIm = new Image();
    angleIm.src = (0, _angleSvgDefault.default);
    (0, _bb.BB).css(angleIm, {
        verticalAlign: "bottom",
        width: "20px",
        height: "20px",
        marginRight: "5px",
        borderRadius: "10px",
        background: "rgba(0,0,0,0.2)",
        userSelect: "none"
    });
    row1.appendChild(angleIm);
    let angleEl = (0, _bb.BB).el({
        css: {
            userSelect: "none"
        }
    });
    row1.appendChild(angleEl);
    function update() {
        scaleEl.innerHTML = Math.round(scale * 100) + "%";
        angleEl.innerHTML = Math.round(angleDeg) + "\xb0";
        angleIm.style.transform = "rotate(" + angleDeg + "deg)";
        if (angleDeg % 90 === 0) angleIm.style.boxShadow = "inset 0 0 0 1px rgba(255,255,255, 1), 0 0 0 1px rgba(0, 0, 0, 0.3)";
        else angleIm.style.boxShadow = "";
    }
    update();
    let resetButton = (0, _bb.BB).el({
        tagName: "button",
        content: (0, _language.LANG)("hand-reset"),
        onClick: p.onReset
    });
    (0, _bb.BB).makeUnfocusable(resetButton);
    let fitButton = (0, _bb.BB).el({
        tagName: "button",
        content: (0, _language.LANG)("hand-fit"),
        css: {
            marginLeft: "10px"
        },
        onClick: p.onFit
    });
    (0, _bb.BB).makeUnfocusable(fitButton);
    row2.append(resetButton, fitButton);
    let leftRotateButton = (0, _bb.BB).el({
        tagName: "button",
        content: '<img height="20" src="' + (0, _editRotateSvgDefault.default) + '" alt="Rotate" style="transform: scale(-1, 1)"/>',
        onClick: function() {
            p.onAngleChange(-15, true);
        }
    });
    (0, _bb.BB).makeUnfocusable(leftRotateButton);
    let resetAngleButton = (0, _bb.BB).el({
        tagName: "button",
        content: "0\xb0",
        css: {
            marginLeft: "10px"
        },
        onClick: function() {
            p.onAngleChange(0);
        }
    });
    (0, _bb.BB).makeUnfocusable(resetAngleButton);
    let rightRotateButton = (0, _bb.BB).el({
        tagName: "button",
        content: '<img height="20" src="' + (0, _editRotateSvgDefault.default) + '" alt="Rotate"/>',
        css: {
            marginLeft: "10px"
        },
        onClick: function() {
            p.onAngleChange(15, true);
        }
    });
    (0, _bb.BB).makeUnfocusable(rightRotateButton);
    row3.append(leftRotateButton, resetAngleButton, rightRotateButton);
    // --- interface ---
    this.getElement = function() {
        return div;
    };
    this.setIsVisible = function(pIsVisible) {
        isVisible = !!pIsVisible;
        div.style.display = isVisible ? "block" : "none";
        if (isVisible) update();
    };
    this.update = function(pScale, pAngleDeg) {
        scale = pScale;
        angleDeg = pAngleDeg;
        if (isVisible) update();
    };
}

},{"../../../bb/bb":"dcQKo","url:~/src/app/img/ui/angle.svg":"hgcfy","url:~/src/app/img/ui/edit-rotate.svg":"6TlrV","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6TlrV":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "edit-rotate.657da0c7.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"5n3hF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Paint Bucket tab contents (color slider, opacity slider, etc)
 *
 * p = {
 *     colorSlider: KlColorSlider// when opening tab, inserts it (snatches it from where else it was)
 * }
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "FillUi", ()=>FillUi);
var _bb = require("../../../bb/bb");
var _klSlider = require("../base-components/kl-slider");
var _select = require("../base-components/select");
var _checkbox = require("../base-components/checkbox");
var _language = require("../../../language/language");
function FillUi(p) {
    let div = (0, _bb.BB).el({
        css: {
            margin: "10px"
        }
    });
    let isVisible = true;
    let colorDiv = (0, _bb.BB).el({
        parent: div,
        css: {
            marginBottom: "10px"
        }
    });
    let opacitySlider = new (0, _klSlider.KlSlider)({
        label: (0, _language.LANG)("opacity"),
        width: 250,
        height: 30,
        min: 0.01,
        max: 1,
        value: 1,
        toValue: (displayValue)=>displayValue / 100,
        toDisplayValue: (value)=>value * 100
    });
    div.appendChild(opacitySlider.getElement());
    let toleranceSlider = new (0, _klSlider.KlSlider)({
        label: (0, _language.LANG)("bucket-tolerance"),
        width: 250,
        height: 30,
        min: 0,
        max: 255,
        value: 51,
        toValue: (displayValue)=>displayValue * 2.55,
        toDisplayValue: (value)=>value / 2.55
    });
    (0, _bb.BB).css(toleranceSlider.getElement(), {
        marginTop: "10px"
    });
    div.appendChild(toleranceSlider.getElement());
    let selectRow = (0, _bb.BB).el({
        parent: div,
        css: {
            display: "flex",
            marginTop: "10px"
        }
    });
    let modeWrapper;
    let modeSelect;
    modeWrapper = (0, _bb.BB).el({
        content: (0, _language.LANG)("bucket-sample") + "&nbsp;",
        title: (0, _language.LANG)("bucket-sample-title"),
        css: {
            fontSize: "15px"
        }
    });
    modeSelect = new (0, _select.Select)({
        optionArr: [
            [
                "all",
                (0, _language.LANG)("bucket-sample-all")
            ],
            [
                "current",
                (0, _language.LANG)("bucket-sample-active")
            ],
            [
                "above",
                (0, _language.LANG)("bucket-sample-above")
            ]
        ],
        initValue: "all",
        onChange: function(val) {}
    });
    let modePointerListener = new (0, _bb.BB).PointerListener({
        target: modeSelect.getElement(),
        onWheel: function(e) {
            modeSelect.setDeltaValue(e.deltaY);
        }
    });
    modeWrapper.appendChild(modeSelect.getElement());
    selectRow.appendChild(modeWrapper);
    let growWrapper;
    let growSelect;
    growWrapper = (0, _bb.BB).el({
        content: (0, _language.LANG)("bucket-grow") + "&nbsp;",
        title: (0, _language.LANG)("bucket-grow-title"),
        css: {
            fontSize: "15px",
            marginLeft: "10px"
        }
    });
    growSelect = new (0, _select.Select)({
        optionArr: [
            [
                "0",
                "0"
            ],
            [
                "1",
                "1"
            ],
            [
                "2",
                "2"
            ],
            [
                "3",
                "3"
            ],
            [
                "4",
                "4"
            ],
            [
                "5",
                "5"
            ],
            [
                "6",
                "6"
            ],
            [
                "7",
                "7"
            ], 
        ],
        initValue: "0",
        onChange: function(val) {}
    });
    let growPointerListener = new (0, _bb.BB).PointerListener({
        target: growSelect.getElement(),
        onWheel: function(e) {
            growSelect.setDeltaValue(e.deltaY);
        }
    });
    growWrapper.appendChild(growSelect.getElement());
    selectRow.appendChild(growWrapper);
    let isContiguous = true;
    let contiguousToggle = new (0, _checkbox.Checkbox)({
        init: true,
        label: (0, _language.LANG)("bucket-contiguous"),
        title: (0, _language.LANG)("bucket-contiguous-title"),
        callback: function(b) {
            isContiguous = b;
        },
        css: {
            paddingRight: "5px",
            display: "inline-block",
            width: "50%"
        }
    });
    let eraserToggle = new (0, _checkbox.Checkbox)({
        init: false,
        label: (0, _language.LANG)("eraser"),
        callback: function(b) {},
        css: {
            paddingRight: "5px",
            display: "inline-block",
            width: "50%"
        }
    });
    div.append((0, _bb.BB).el({
        content: [
            contiguousToggle.getElement(),
            eraserToggle.getElement(), 
        ],
        css: {
            display: "flex",
            marginTop: "10px"
        }
    }));
    // --- interface ---
    this.getElement = function() {
        return div;
    };
    this.setIsVisible = function(pIsVisible) {
        isVisible = !!pIsVisible;
        div.style.display = isVisible ? "block" : "none";
        if (isVisible) {
            colorDiv.appendChild(p.colorSlider.getElement());
            colorDiv.appendChild(p.colorSlider.getOutputElement());
        }
    };
    this.getTolerance = function() {
        return toleranceSlider.getValue();
    };
    this.getOpacity = function() {
        return opacitySlider.getValue();
    };
    /**
     * returns string 'current' | 'all' | 'above'
     */ this.getSample = function() {
        return modeSelect.getValue();
    };
    this.getGrow = function() {
        return parseInt(growSelect.getValue(), 10);
    };
    this.getContiguous = ()=>isContiguous;
    this.getIsEraser = ()=>eraserToggle.getValue();
}

},{"../../../bb/bb":"dcQKo","../base-components/kl-slider":"6YGce","../base-components/select":"7mzRU","../base-components/checkbox":"kPAwM","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jaulB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Text Tool tab contents (color slider)
 *
 * p = {
 *     colorSlider: KlColorSlider// when opening tab, inserts it (snatches it from where else it was)
 * }
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "TextUi", ()=>TextUi);
var _bb = require("../../../bb/bb");
var _language = require("../../../language/language");
function TextUi(p) {
    let div = (0, _bb.BB).el({
        css: {
            margin: "10px"
        }
    });
    let isVisible = true;
    let colorDiv = (0, _bb.BB).el({
        parent: div,
        css: {
            marginBottom: "10px"
        }
    });
    let hint = (0, _bb.BB).el({
        parent: div,
        content: (0, _language.LANG)("text-instruction")
    });
    // --- interface ---
    this.getElement = function() {
        return div;
    };
    this.setIsVisible = function(pIsVisible) {
        isVisible = !!pIsVisible;
        div.style.display = isVisible ? "block" : "none";
        if (isVisible) {
            colorDiv.appendChild(p.colorSlider.getElement());
            colorDiv.appendChild(p.colorSlider.getOutputElement());
        //update();
        }
    };
}

},{"../../../bb/bb":"dcQKo","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7GG7G":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Shape Tool tab contents
 *
 * p = {
 *     colorSlider: KlColorSlider// when opening tab, inserts it (snatches it from where else it was)
 * }
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "ShapeUi", ()=>ShapeUi);
var _bb = require("../../../bb/bb");
var _options = require("../base-components/options");
var _checkbox = require("../base-components/checkbox");
var _klSlider = require("../base-components/kl-slider");
var _language = require("../../../language/language");
function ShapeUi(p) {
    let div = (0, _bb.BB).el({
        css: {
            margin: "10px"
        }
    });
    let isVisible = true;
    let colorDiv = (0, _bb.BB).el({
        parent: div,
        css: {
            marginBottom: "10px"
        }
    });
    let previewSize = 35;
    let previewPadding = 8;
    let shape; // 'rect'|'ellipse'|'line'
    let mode; // 'stroke'|'fill'
    let rectStrokeSvgRect = (0, _bb.BB).createSvg({
        elementType: "rect",
        x: "" + previewPadding,
        width: "" + (previewSize - previewPadding * 2)
    });
    let rectStrokeSvg = (0, _bb.BB).createSvg({
        elementType: "svg",
        width: "" + previewSize,
        height: "" + previewSize
    });
    rectStrokeSvg.appendChild(rectStrokeSvgRect);
    (0, _bb.BB).css(rectStrokeSvg, {
        display: "block"
    });
    let rectFilledSvgRect = (0, _bb.BB).createSvg({
        elementType: "rect",
        x: "" + previewPadding,
        width: "" + (previewSize - previewPadding * 2)
    });
    let rectFilledSvg = (0, _bb.BB).createSvg({
        elementType: "svg",
        width: "" + previewSize,
        height: "" + previewSize
    });
    rectFilledSvg.appendChild(rectFilledSvgRect);
    (0, _bb.BB).css(rectFilledSvg, {
        display: "block"
    });
    let ellipseStrokeSvgEllipse = (0, _bb.BB).createSvg({
        elementType: "ellipse",
        cx: "" + previewSize / 2,
        cy: "" + previewSize / 2,
        rx: "" + (previewSize / 2 - previewPadding)
    });
    let ellipseStrokeSvg = (0, _bb.BB).createSvg({
        elementType: "svg",
        width: "" + previewSize,
        height: "" + previewSize
    });
    ellipseStrokeSvg.appendChild(ellipseStrokeSvgEllipse);
    (0, _bb.BB).css(ellipseStrokeSvg, {
        display: "block"
    });
    let ellipseFilledSvgEllipse = (0, _bb.BB).createSvg({
        elementType: "ellipse",
        cx: "" + previewSize / 2,
        cy: "" + previewSize / 2,
        rx: "" + (previewSize / 2 - previewPadding)
    });
    let ellipseFilledSvg = (0, _bb.BB).createSvg({
        elementType: "svg",
        width: "" + previewSize,
        height: "" + previewSize
    });
    ellipseFilledSvg.appendChild(ellipseFilledSvgEllipse);
    (0, _bb.BB).css(ellipseFilledSvg, {
        display: "block"
    });
    let lineSvgLine = (0, _bb.BB).createSvg({
        elementType: "line",
        x1: "" + previewPadding,
        x2: "" + (previewSize - previewPadding)
    });
    let lineSvg = (0, _bb.BB).createSvg({
        elementType: "svg",
        width: "" + previewSize,
        height: "" + previewSize
    });
    lineSvg.appendChild(lineSvgLine);
    (0, _bb.BB).css(lineSvg, {
        display: "block"
    });
    function updatePreviews() {
        let strokeWidth = (0, _bb.BB).clamp(Math.round(lineWidthSlider.getValue() / 10), 1, 10) + "px";
        let squish = 1.35;
        (0, _bb.BB).css(rectStrokeSvgRect, {
            fill: "none",
            stroke: "black",
            strokeWidth: strokeWidth
        });
        (0, _bb.BB).css(rectFilledSvgRect, {
            fill: "black",
            stroke: "none"
        });
        (0, _bb.BB).css(ellipseStrokeSvgEllipse, {
            fill: "none",
            stroke: "black",
            strokeWidth: strokeWidth
        });
        (0, _bb.BB).css(ellipseFilledSvgEllipse, {
            fill: "black",
            stroke: "none"
        });
        (0, _bb.BB).css(lineSvgLine, {
            fill: "none",
            stroke: "black",
            strokeWidth: strokeWidth
        });
        if (fixedToggle.getValue()) {
            rectStrokeSvgRect.setAttribute("y", "" + previewPadding);
            rectStrokeSvgRect.setAttribute("height", "" + (previewSize - previewPadding * 2));
            rectFilledSvgRect.setAttribute("y", "" + previewPadding);
            rectFilledSvgRect.setAttribute("height", "" + (previewSize - previewPadding * 2));
            ellipseStrokeSvgEllipse.setAttribute("ry", "" + (previewSize / 2 - previewPadding));
            ellipseFilledSvgEllipse.setAttribute("ry", "" + (previewSize / 2 - previewPadding));
        } else {
            rectStrokeSvgRect.setAttribute("y", "" + previewPadding * squish);
            rectStrokeSvgRect.setAttribute("height", "" + (previewSize - previewPadding * squish * 2));
            rectFilledSvgRect.setAttribute("y", "" + previewPadding * squish);
            rectFilledSvgRect.setAttribute("height", "" + (previewSize - previewPadding * squish * 2));
            ellipseStrokeSvgEllipse.setAttribute("ry", "" + (previewSize / 2 - previewPadding * squish));
            ellipseFilledSvgEllipse.setAttribute("ry", "" + (previewSize / 2 - previewPadding * squish));
        }
        if (snapToggle.getValue()) {
            lineSvgLine.setAttribute("y1", "" + (previewSize - previewPadding));
            lineSvgLine.setAttribute("y2", "" + previewPadding);
        } else {
            lineSvgLine.setAttribute("y1", "" + (previewSize - previewPadding * squish));
            lineSvgLine.setAttribute("y2", "" + previewPadding * squish);
        }
    }
    let row1 = (0, _bb.BB).el({
        parent: div,
        css: {
            display: "flex",
            justifyContent: "space-between",
            alignItems: "start"
        }
    });
    let shapeOptions = new (0, _options.Options)({
        optionArr: [
            {
                id: "rect-stroke",
                label: rectStrokeSvg,
                title: (0, _language.LANG)("shape-rect") + " " + (0, _language.LANG)("shape-stroke")
            },
            {
                id: "ellipse-stroke",
                label: ellipseStrokeSvg,
                title: (0, _language.LANG)("shape-ellipse") + " " + (0, _language.LANG)("shape-stroke")
            },
            {
                id: "line",
                label: lineSvg,
                title: (0, _language.LANG)("shape-line")
            },
            {
                id: "rect-fill",
                label: rectFilledSvg,
                title: (0, _language.LANG)("shape-rect") + " " + (0, _language.LANG)("shape-fill")
            },
            {
                id: "ellipse-fill",
                label: ellipseFilledSvg,
                title: (0, _language.LANG)("shape-ellipse") + " " + (0, _language.LANG)("shape-fill")
            }, 
        ],
        initId: "rect",
        onChange: function(id) {
            let split = id.split("-");
            shape = split[0];
            mode = split[1];
            (0, _bb.BB).css(fixedToggle.getElement(), {
                display: shape === "line" ? "none" : null
            });
            (0, _bb.BB).css(snapToggle.getElement(), {
                display: shape === "line" ? null : "none"
            });
            (0, _bb.BB).css(lineWidthSlider.getElement(), {
                display: shape !== "line" && mode === "fill" ? "none" : null
            });
        },
        changeOnInit: true
    });
    shapeOptions.getElement().style.width = "120px";
    row1.appendChild(shapeOptions.getElement());
    const eraserToggle = new (0, _checkbox.Checkbox)({
        init: false,
        label: (0, _language.LANG)("eraser"),
        callback: function(b) {
            updatePreviews();
        }
    });
    const lockAlphaToggle = new (0, _checkbox.Checkbox)({
        init: false,
        label: (0, _language.LANG)("lock-alpha"),
        title: (0, _language.LANG)("lock-alpha-title"),
        callback: (b)=>{},
        doHighlight: true
    });
    lockAlphaToggle.getElement().style.marginTop = "10px";
    row1.append((0, _bb.BB).el({
        content: [
            eraserToggle.getElement(),
            lockAlphaToggle.getElement(), 
        ]
    }));
    let lineWidthSlider = new (0, _klSlider.KlSlider)({
        label: (0, _language.LANG)("shape-line-width"),
        width: 250,
        height: 30,
        min: 1,
        max: 200,
        value: 4,
        curve: "quadratic",
        onChange: (val)=>{
            updatePreviews();
        }
    });
    (0, _bb.BB).css(lineWidthSlider.getElement(), {
        marginTop: "10px"
    });
    div.appendChild(lineWidthSlider.getElement());
    let opacitySlider = new (0, _klSlider.KlSlider)({
        label: (0, _language.LANG)("opacity"),
        width: 250,
        height: 30,
        min: 0.01,
        max: 1,
        value: 1,
        toValue: (displayValue)=>displayValue / 100,
        toDisplayValue: (value)=>value * 100
    });
    (0, _bb.BB).css(opacitySlider.getElement(), {
        marginTop: "10px"
    });
    div.appendChild(opacitySlider.getElement());
    let row2 = (0, _bb.BB).el({
        parent: div,
        css: {
            display: "flex",
            alignItems: "center",
            marginTop: "10px"
        }
    });
    let outwardsToggle = new (0, _checkbox.Checkbox)({
        init: false,
        label: (0, _language.LANG)("shape-outwards"),
        callback: function(b) {},
        css: {
            width: "50%",
            marginRight: "10px"
        }
    });
    row2.appendChild(outwardsToggle.getElement());
    let fixedToggle = new (0, _checkbox.Checkbox)({
        init: false,
        label: (0, _language.LANG)("shape-fixed"),
        callback: function(b) {
            updatePreviews();
        },
        css: {
            flexGrow: "1"
        }
    });
    row2.appendChild(fixedToggle.getElement());
    let snapToggle = new (0, _checkbox.Checkbox)({
        init: false,
        label: (0, _language.LANG)("angle-snap"),
        title: (0, _language.LANG)("angle-snap-title"),
        callback: function(b) {
            updatePreviews();
        },
        css: {
            flexGrow: "1"
        }
    });
    row2.appendChild(snapToggle.getElement());
    updatePreviews();
    // --- interface ---
    this.getElement = function() {
        return div;
    };
    this.setIsVisible = function(pIsVisible) {
        isVisible = !!pIsVisible;
        div.style.display = isVisible ? "block" : "none";
        if (isVisible) {
            colorDiv.appendChild(p.colorSlider.getElement());
            colorDiv.appendChild(p.colorSlider.getOutputElement());
        //update();
        }
    };
    this.getShape = function() {
        return shape;
    };
    this.getMode = function() {
        return mode;
    };
    this.getIsEraser = function() {
        return eraserToggle.getValue();
    };
    this.getOpacity = function() {
        return opacitySlider.getValue();
    };
    this.getLineWidth = function() {
        return lineWidthSlider.getValue();
    };
    this.getIsOutwards = function() {
        return outwardsToggle.getValue();
    };
    this.getIsFixed = function() {
        return fixedToggle.getValue();
    };
    this.getIsSnap = function() {
        return snapToggle.getValue();
    };
    this.getDoLockAlpha = ()=>{
        return lockAlphaToggle.getValue();
    };
}

},{"../../../bb/bb":"dcQKo","../base-components/options":"huqRY","../base-components/checkbox":"kPAwM","../base-components/kl-slider":"6YGce","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5IVi4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * P = {
 *     currentColor: RGB, // current color
 *     secondaryColor: RGB,
 *     maxCanvasSize: number,
 *     canvasWidth: number, // current canvas size
 *     canvasHeight: number, // current canvas size
 *     workspaceWidth: number,
 *     workspaceHeight: number,
 *     onConfirm: function(width number, height number, color RGBA),
 *     onCancel: function()
 * }
 *
 * @param p
 */ parcelHelpers.export(exports, "newImageDialog", ()=>newImageDialog);
var _bb = require("../../../bb/bb");
var _select = require("../base-components/select");
var _colorOptions = require("../base-components/color-options");
var _popup = require("./popup");
var _language = require("../../../language/language");
function newImageDialog(p) {
    let currentColor = p.currentColor;
    let secondaryColor = p.secondaryColor;
    let maxCanvasSize = p.maxCanvasSize;
    let canvasWidth = p.canvasWidth;
    let canvasHeight = p.canvasHeight;
    let workspaceWidth = p.workspaceWidth;
    let workspaceHeight = p.workspaceHeight;
    let onConfirm = p.onConfirm;
    let onCancel = p.onCancel;
    function createRatioSize(ratioX, ratioY, width, height, padding) {
        return (0, _bb.BB).fitInto(ratioX, ratioY, Math.min(maxCanvasSize, width - padding), Math.min(maxCanvasSize, height - padding), 1);
    }
    let newImDiv = document.createElement("div");
    let widthWrapper = document.createElement("div");
    let heightWrapper = document.createElement("div");
    let widthInput = document.createElement("input");
    let widthUnit = document.createElement("div");
    let heightInput = document.createElement("input");
    let heightUnit = document.createElement("div");
    widthWrapper.style.position = "relative";
    widthWrapper.style.width = "145px";
    widthWrapper.style.height = "35px";
    widthWrapper.style.lineHeight = "30px";
    heightWrapper.style.width = "145px";
    heightWrapper.style.height = "35px";
    heightWrapper.style.lineHeight = "30px";
    widthUnit.innerText = (0, _language.LANG)("new-px");
    widthUnit.style.color = "#888";
    widthUnit.style.fontSize = "12px";
    widthUnit.style.marginLeft = "5px";
    widthUnit.style.cssFloat = "right";
    heightUnit.innerText = (0, _language.LANG)("new-px");
    heightUnit.style.color = "#888";
    heightUnit.style.fontSize = "12px";
    heightUnit.style.marginLeft = "5px";
    heightUnit.style.cssFloat = "right";
    widthInput.setAttribute("data-ignore-focus", "true");
    heightInput.setAttribute("data-ignore-focus", "true");
    widthInput.type = "number";
    widthInput.min = "1";
    widthInput.max = maxCanvasSize;
    widthInput.style.cssFloat = "right";
    widthInput.style.width = "70px";
    heightInput.type = "number";
    heightInput.min = "1";
    heightInput.max = maxCanvasSize;
    heightInput.style.cssFloat = "right";
    heightInput.style.width = "70px";
    widthInput.value = canvasWidth;
    heightInput.value = canvasHeight;
    widthInput.onclick = function() {
        this.focus();
        updateRatio();
    };
    heightInput.onclick = function() {
        this.focus();
        updateRatio();
    };
    widthWrapper.appendChild(widthUnit);
    widthWrapper.appendChild(widthInput);
    (0, _bb.BB).appendTextDiv(widthWrapper, (0, _language.LANG)("width") + ": ");
    heightWrapper.appendChild(heightUnit);
    heightWrapper.appendChild(heightInput);
    (0, _bb.BB).appendTextDiv(heightWrapper, (0, _language.LANG)("height") + ": ");
    let ratioWrapper = document.createElement("div");
    ratioWrapper.style.marginTop = "5px";
    ratioWrapper.style.color = "#888";
    let templateWrapper = document.createElement("div");
    //BB.appendTextDiv(templateWrapper, "Preset Resolutions: <br />");
    let presetFitBtn = document.createElement("button");
    templateWrapper.style.marginBottom = "10px";
    let presetCurrentBtn = document.createElement("button");
    let presetSquareBtn = document.createElement("button");
    let presetLandscapeBtn = document.createElement("button");
    let presetPortraitBtn = document.createElement("button");
    let presetOversizeBtn = document.createElement("button");
    presetCurrentBtn.textContent = (0, _language.LANG)("new-current");
    presetFitBtn.textContent = (0, _language.LANG)("new-fit");
    presetOversizeBtn.textContent = (0, _language.LANG)("new-oversize");
    presetLandscapeBtn.textContent = (0, _language.LANG)("new-landscape");
    presetPortraitBtn.textContent = (0, _language.LANG)("new-portrait");
    presetSquareBtn.textContent = (0, _language.LANG)("new-square");
    presetCurrentBtn.style.marginRight = "5px";
    presetFitBtn.style.marginRight = "5px";
    presetOversizeBtn.style.marginRight = "5px";
    presetLandscapeBtn.style.marginTop = "5px";
    presetLandscapeBtn.style.marginRight = "5px";
    presetPortraitBtn.style.marginTop = "5px";
    presetPortraitBtn.style.marginRight = "5px";
    templateWrapper.appendChild(presetCurrentBtn);
    templateWrapper.appendChild(presetFitBtn);
    templateWrapper.appendChild(presetOversizeBtn);
    templateWrapper.appendChild(presetSquareBtn);
    templateWrapper.appendChild(presetLandscapeBtn);
    templateWrapper.appendChild(presetPortraitBtn);
    let templatePadding = 0;
    presetCurrentBtn.onclick = function() {
        widthInput.value = canvasWidth;
        heightInput.value = canvasHeight;
        updateRatio();
    };
    presetFitBtn.onclick = function() {
        widthInput.value = workspaceWidth;
        heightInput.value = workspaceHeight;
        updateRatio();
    };
    presetOversizeBtn.onclick = function() {
        widthInput.value = workspaceWidth + 500;
        heightInput.value = workspaceHeight + 500;
        updateRatio();
    };
    presetSquareBtn.onclick = function() {
        let sizeObj = createRatioSize(1, 1, workspaceWidth, workspaceHeight, templatePadding);
        widthInput.value = "" + Math.round(sizeObj.width);
        heightInput.value = "" + Math.round(sizeObj.height);
        updateRatio();
    };
    presetLandscapeBtn.onclick = function() {
        let sizeObj = createRatioSize(4, 3, workspaceWidth, workspaceHeight, templatePadding);
        widthInput.value = "" + Math.round(sizeObj.width);
        heightInput.value = "" + Math.round(sizeObj.height);
        updateRatio();
    };
    presetPortraitBtn.onclick = function() {
        let sizeObj = createRatioSize(3, 4, workspaceWidth, workspaceHeight, templatePadding);
        widthInput.value = "" + Math.round(sizeObj.width);
        heightInput.value = "" + Math.round(sizeObj.height);
        updateRatio();
    };
    let select = new (0, _select.Select)({
        isFocusable: true,
        optionArr: [
            [
                "screen",
                (0, _language.LANG)("new-screen")
            ],
            [
                "16 9",
                (0, _language.LANG)("new-video") + " 16:9"
            ],
            [
                "3 2",
                "3:2"
            ],
            [
                "5 3",
                "5:3"
            ],
            [
                "2 1",
                "2:1"
            ],
            [
                "paper",
                (0, _language.LANG)("new-din-paper") + " ‚àö2:1"
            ],
            [
                "9 16",
                "9:16"
            ],
            [
                "2 3",
                "2:3"
            ],
            [
                "3 5",
                "3:5"
            ],
            [
                "1 2",
                "1:2"
            ],
            [
                "1 1.4142135623730951",
                "1:‚àö2"
            ]
        ],
        onChange: function(val) {
            if (val === "screen") {
                widthInput.value = "" + window.screen.width;
                heightInput.value = "" + window.screen.height;
            } else if (val === "paper") {
                let sizeObj = createRatioSize(Math.sqrt(2), 1, workspaceWidth, workspaceHeight, templatePadding);
                widthInput.value = "" + Math.round(sizeObj.width);
                heightInput.value = "" + Math.round(sizeObj.height);
            } else {
                let split = val.split(" ");
                let sizeObj1 = createRatioSize(parseFloat(split[0]), parseFloat(split[1]), workspaceWidth, workspaceHeight, templatePadding);
                widthInput.value = "" + Math.round(sizeObj1.width);
                heightInput.value = "" + Math.round(sizeObj1.height);
            }
            updateRatio();
            select.setValue(null);
        }
    });
    setTimeout(()=>{
        // safari: not empty without also setting it to null via timeout
        select.setValue(null);
    }, 0);
    (0, _bb.BB).css(select.getElement(), {
        width: "80px"
    });
    templateWrapper.appendChild(select.getElement());
    let backgroundRGBA = {
        r: 255,
        g: 255,
        b: 255,
        a: 1
    };
    let colorOptionsArr = [
        {
            r: 255,
            g: 255,
            b: 255,
            a: 1
        },
        {
            r: 0,
            g: 0,
            b: 0,
            a: 1
        },
        {
            r: 0,
            g: 0,
            b: 0,
            a: 0
        }
    ];
    colorOptionsArr.push({
        r: currentColor.r,
        g: currentColor.g,
        b: currentColor.b,
        a: 1
    });
    colorOptionsArr.push({
        r: secondaryColor.r,
        g: secondaryColor.g,
        b: secondaryColor.b,
        a: 1
    });
    let colorOptions = new (0, _colorOptions.ColorOptions)({
        colorArr: colorOptionsArr,
        onChange: function(rgbaObj) {
            backgroundRGBA = rgbaObj;
            preview.style.backgroundColor = "rgba(" + rgbaObj.r + "," + rgbaObj.g + "," + rgbaObj.b + ", " + rgbaObj.a + ")";
        }
    });
    let previewWrapper = document.createElement("div");
    (0, _bb.BB).css(previewWrapper, {
        boxSizing: "border-box",
        width: "340px",
        height: "140px",
        display: "table",
        backgroundColor: "#9e9e9e",
        padding: "10px",
        marginTop: "10px",
        boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
        marginLeft: "-20px",
        colorScheme: "only light"
    });
    let preview = document.createElement("div");
    (0, _bb.BB).css(preview, {
        width: "200px",
        height: "100px",
        backgroundColor: "#fff",
        marginLeft: "auto",
        marginRight: "auto",
        color: "#aaa",
        fontSize: "16px",
        fontWeight: "bold",
        textAlign: "center",
        verticalAlign: "center",
        display: "table",
        overflow: "hidden",
        boxShadow: "0px 0px 3px rgba(0,0,0,0.5)"
    });
    let previewcell = document.createElement("div");
    previewcell.style.display = "table-cell";
    previewcell.style.verticalAlign = "middle";
    previewcell.appendChild(preview);
    previewWrapper.appendChild(previewcell);
    let cell = (0, _bb.BB).appendTextDiv(preview, "");
    //let ratio = BB.appendTextDiv(cell, "1:2");
    cell.style.display = "table-cell";
    cell.style.verticalAlign = "middle";
    let prevW = parseInt(widthInput.value);
    let prevH = parseInt(heightInput.value);
    function updateRatio() {
        widthInput.value = "" + Math.min(maxCanvasSize, parseInt(widthInput.value));
        heightInput.value = "" + Math.min(maxCanvasSize, parseInt(heightInput.value));
        function HCF(u, v) {
            let U = u, V = v;
            while(true){
                if (!(U %= V)) return V;
                if (!(V %= U)) return U;
            }
        }
        let w = parseInt(widthInput.value);
        let h = parseInt(heightInput.value);
        if (w < 1 || w > maxCanvasSize || h < 1 || h > maxCanvasSize) {
            if (w > maxCanvasSize) w = maxCanvasSize;
            else if (h > maxCanvasSize) h = maxCanvasSize;
            widthInput.value = "" + w;
            heightInput.value = "" + h;
        }
        //generated canvas size doesn't always match ratio. so check if a common ratio is very close
        let commonRatios = [
            [
                1,
                2
            ],
            [
                2,
                1
            ],
            [
                2,
                3
            ],
            [
                3,
                2
            ],
            [
                3,
                4
            ],
            [
                4,
                3
            ],
            [
                4,
                5
            ],
            [
                5,
                4
            ],
            [
                16,
                9
            ],
            [
                9,
                16
            ],
            [
                3,
                2
            ],
            [
                2,
                3
            ],
            [
                5,
                3
            ],
            [
                3,
                5
            ],
            [
                2,
                1
            ],
            [
                1,
                2
            ],
            [
                1.414,
                1
            ],
            [
                1,
                1.414
            ], 
        ];
        let reducedArr = (0, _bb.BB).reduce(w, h);
        let closestRatio = null;
        let closestDistance = null;
        for(let i = 0; i < commonRatios.length; i++)if (i === 0 || Math.abs(commonRatios[i][0] / commonRatios[i][1] - reducedArr[0] / reducedArr[1]) < closestDistance) {
            closestRatio = commonRatios[i];
            closestDistance = Math.abs(commonRatios[i][0] / commonRatios[i][1] - reducedArr[0] / reducedArr[1]);
        }
        //display ratio
        if (closestDistance > 0 && closestDistance < 0.005) ratioWrapper.innerText = (0, _language.LANG)("new-ratio") + ": ~" + closestRatio[0] + ":" + closestRatio[1];
        else ratioWrapper.innerText = (0, _language.LANG)("new-ratio") + ": " + reducedArr[0] + ":" + reducedArr[1];
        prevW = w;
        prevH = h;
        let realw = w;
        let T = HCF(w, h);
        w /= T;
        h /= T;
        w *= 260;
        h *= 260;
        if (w > 260) {
            h = 260 / w * h;
            w = 260;
        }
        if (h > 100) {
            w = 100 / h * w;
            h = 100;
        }
        preview.style.width = w + "px";
        preview.style.height = h + "px";
        (0, _bb.BB).createCheckerDataUrl(parseInt("" + 30 * (w / realw)), function(url) {
            previewWrapper.style.background = "url(" + url + ")";
        });
    }
    widthInput.onchange = function() {
        if (widthInput.value === "" || parseInt(widthInput.value) < 0) widthInput.value = "1";
        updateRatio();
    };
    widthInput.onkeyup = function() {
        updateRatio();
    };
    heightInput.onchange = function() {
        if (heightInput.value === "" || parseFloat(heightInput.value) < 0) heightInput.value = "1";
        updateRatio();
    };
    heightInput.onkeyup = function() {
        updateRatio();
    };
    updateRatio();
    newImDiv.appendChild(templateWrapper);
    let secondRow = (0, _bb.BB).el({
        parent: newImDiv,
        css: {
            display: "flex",
            justifyContent: "space-between",
            alignItems: "flex-end"
        }
    });
    let secondRowLeft = (0, _bb.BB).el({
        parent: secondRow
    });
    secondRowLeft.appendChild(widthWrapper);
    secondRowLeft.appendChild(heightWrapper);
    secondRowLeft.appendChild(ratioWrapper);
    secondRow.appendChild(colorOptions.getElement());
    newImDiv.appendChild(previewWrapper);
    (0, _popup.popup)({
        target: document.body,
        message: `<b>${(0, _language.LANG)("new-title")}</b>`,
        div: newImDiv,
        buttons: [
            "Ok",
            "Cancel"
        ],
        callback: function(result) {
            widthInput.onclick = null;
            heightInput.onclick = null;
            presetCurrentBtn.onclick = null;
            presetFitBtn.onclick = null;
            presetOversizeBtn.onclick = null;
            presetSquareBtn.onclick = null;
            presetLandscapeBtn.onclick = null;
            presetPortraitBtn.onclick = null;
            widthInput.onchange = null;
            widthInput.onkeyup = null;
            heightInput.onchange = null;
            heightInput.onkeyup = null;
            select.destroy();
            colorOptions.destroy();
            if (result === "Cancel" || parseInt(widthInput.value) <= 0 || parseInt(heightInput.value) <= 0 || isNaN(parseInt(widthInput.value)) || isNaN(parseInt(heightInput.value))) {
                onCancel();
                return;
            }
            onConfirm(parseInt(widthInput.value), parseInt(heightInput.value), backgroundRGBA);
        },
        clickOnEnter: "Ok"
    });
}

},{"../../../bb/bb":"dcQKo","../base-components/select":"7mzRU","../base-components/color-options":"e85vi","./popup":"4Ltiz","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l6lvr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * button that allows to collapse toolspace (for mobile)
 *
 * p = {
 *     onChange: function()
 * }
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "ToolspaceCollapser", ()=>ToolspaceCollapser);
var _bb = require("../../../bb/bb");
// @ts-ignore
var _uiCollapseSvg = require("url:~/src/app/img/ui/ui-collapse.svg");
var _uiCollapseSvgDefault = parcelHelpers.interopDefault(_uiCollapseSvg);
var _language = require("../../../language/language");
function ToolspaceCollapser(p) {
    let isOpen = true;
    let directionStr = "right"; // 'left' | 'right'
    function update() {
        if (directionStr === "left") icon.style.transform = isOpen ? "rotate(180deg)" : "";
        else icon.style.transform = isOpen ? "" : "rotate(180deg)";
    }
    let div = (0, _bb.BB).el({
        css: {
            width: "36px",
            height: "36px",
            background: "rgba(100, 100, 100, 0.9)",
            color: "#fff",
            position: "absolute",
            top: "0",
            textAlign: "center",
            lineHeight: "36px",
            cursor: "pointer",
            userSelect: "none",
            padding: "6px",
            boxSizing: "border-box"
        },
        title: (0, _language.LANG)("toggle-show-tools"),
        onClick: function(e) {
            e.preventDefault();
            isOpen = !isOpen;
            update();
            p.onChange();
        }
    });
    let icon = (0, _bb.BB).el({
        parent: div,
        css: {
            backgroundImage: `url(${(0, _uiCollapseSvgDefault.default)})`,
            width: "100%",
            height: "100%",
            backgroundSize: "contain",
            backgroundRepeat: "no-repeat",
            backgroundPosition: "center",
            userSelect: "none"
        }
    });
    div.oncontextmenu = function() {
        return false;
    };
    // --- interface ---
    this.isOpen = function() {
        return isOpen;
    };
    /**
     *
     * @param dirStr
     */ this.setDirection = function(dirStr) {
        directionStr = dirStr;
        update();
    };
    this.getElement = function() {
        return div;
    };
}

},{"../../../bb/bb":"dcQKo","url:~/src/app/img/ui/ui-collapse.svg":"7goWY","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7goWY":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "ui-collapse.c5cddfda.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"cGhag":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Text Tool dialog
 *
 * confirmP = {
 *     x: number,
 *     y: number,
 *     textStr: string,
 *     align: 'left' | 'center' | 'right',
 *     isItalic: boolean,
 *     isBold: boolean,
 *     color: rgb,
 *     size: number, // px
 *     font: 'serif' | 'monospace' | 'sans-serif' | 'cursive' | 'fantasy',
 *     opacity: number, // 0 - 1
 * }
 *
 * @param p
 */ parcelHelpers.export(exports, "textToolDialog", ()=>textToolDialog);
var _bb = require("../../../bb/bb");
var _renderText = require("../../image-operations/render-text");
var _colorOptions = require("../base-components/color-options");
var _select = require("../base-components/select");
var _imageRadioList = require("../base-components/image-radio-list");
var _imageToggle = require("../base-components/image-toggle");
var _klSlider = require("../base-components/kl-slider");
var _popup = require("./popup");
// @ts-ignore
var _alignLeftSvg = require("url:~/src/app/img/ui/align-left.svg");
var _alignLeftSvgDefault = parcelHelpers.interopDefault(_alignLeftSvg);
// @ts-ignore
var _alignCenterSvg = require("url:~/src/app/img/ui/align-center.svg");
var _alignCenterSvgDefault = parcelHelpers.interopDefault(_alignCenterSvg);
// @ts-ignore
var _alignRightSvg = require("url:~/src/app/img/ui/align-right.svg");
var _alignRightSvgDefault = parcelHelpers.interopDefault(_alignRightSvg);
// @ts-ignore
var _typoItalicSvg = require("url:~/src/app/img/ui/typo-italic.svg");
var _typoItalicSvgDefault = parcelHelpers.interopDefault(_typoItalicSvg);
// @ts-ignore
var _typoBoldSvg = require("url:~/src/app/img/ui/typo-bold.svg");
var _typoBoldSvgDefault = parcelHelpers.interopDefault(_typoBoldSvg);
// @ts-ignore
var _toolZoomInSvg = require("url:~/src/app/img/ui/tool-zoom-in.svg");
var _toolZoomInSvgDefault = parcelHelpers.interopDefault(_toolZoomInSvg);
// @ts-ignore
var _toolZoomOutSvg = require("url:~/src/app/img/ui/tool-zoom-out.svg");
var _toolZoomOutSvgDefault = parcelHelpers.interopDefault(_toolZoomOutSvg);
var _language = require("../../../language/language");
function textToolDialog(p) {
    let div = (0, _bb.BB).el({});
    let isSmallWidth = window.innerWidth < 550;
    let isSmallHeight = window.innerHeight < 630;
    // --- preview ---
    // Text drawn on klCanvas-sized canvas: textCanvas
    // LayerArr[target].canvas & textCanvas then drawn on targetCanvas
    //      they are transformed. canvas size of final preview
    // All layers and targetCanvas drawn on layersCanvas. transformed and size of final preview
    // Checkerboard, layersCanvas, and outline then drawn on previewCanvas
    let width = isSmallWidth ? 340 : 540;
    let height = isSmallWidth ? isSmallHeight ? 210 : 260 : isSmallHeight ? 230 : 350;
    let scale = 1;
    let layerArr = p.klCanvas.getLayersFast();
    let textCanvas = (0, _bb.BB).canvas(p.klCanvas.getWidth(), p.klCanvas.getHeight());
    let textCtx = textCanvas.getContext("2d");
    let targetCanvas = (0, _bb.BB).canvas(width, height);
    let targetCtx = targetCanvas.getContext("2d");
    let layersCanvas = (0, _bb.BB).canvas(width, height);
    let layersCtx = layersCanvas.getContext("2d");
    let previewCanvas = (0, _bb.BB).canvas(width, height); // the one that is visible
    let previewCtx = previewCanvas.getContext("2d");
    (0, _bb.BB).css(previewCanvas, {
        display: "block"
    });
    let previewWrapper = (0, _bb.BB).el({
        parent: div,
        css: {
            position: "relative",
            width: width + "px",
            marginLeft: "-20px",
            cursor: "move",
            colorScheme: "only light",
            touchAction: "none"
        },
        onClick: function() {
            textInput.focus();
        }
    });
    (0, _bb.BB).el({
        parent: previewWrapper,
        css: {
            position: "absolute",
            left: "0",
            top: "0",
            right: "0",
            bottom: "0",
            boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
            pointerEvents: "none"
        }
    });
    previewWrapper.appendChild(previewCanvas);
    let checkerPattern = previewCtx.createPattern((0, _bb.BB).createCheckerCanvas(8), "repeat");
    let emptyCanvas = (0, _bb.BB).canvas(1, 1);
    {
        let ctx = emptyCanvas.getContext("2d");
        ctx.fillRect(0, 0, 1, 1);
    }
    function updatePreview() {
        // try to draw very much like klCanvasWorkspace
        // --- draw text ---
        textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);
        let colorRGBA = {
            ...p.color,
            a: opacitySlider.getValue()
        };
        let bounds = (0, _renderText.renderText)(textCanvas, {
            x: p.x,
            y: p.y,
            textStr: textInput.value,
            align: alignRadioList.getValue(),
            isItalic: italicToggle.getValue(),
            isBold: boldToggle.getValue(),
            size: parseFloat(sizeInput.value),
            font: fontSelect.getValue(),
            color: (0, _bb.BB).ColorConverter.toRgbaStr(colorRGBA),
            angleRad: p.angleRad
        });
        // --- determine transformation of viewport ---
        // text should always be visible
        bounds.width = Math.max(bounds.width, 1);
        bounds.height = Math.max(bounds.height, 1);
        let rotatedXY = (0, _bb.BB).rotate(bounds.x, bounds.y, -p.angleRad / Math.PI * 180);
        let rotatedWH = (0, _bb.BB).rotate(bounds.width, bounds.height, -p.angleRad / Math.PI * 180);
        let centerX = p.x + rotatedXY.x + rotatedWH.x / 2;
        let centerY = p.y + rotatedXY.y + rotatedWH.y / 2;
        let padding = 100;
        let fitBounds = (0, _bb.BB).fitInto(bounds.width, bounds.height, width - padding, height - padding);
        scale = Math.min(1, fitBounds.width / bounds.width);
        scale = Math.min(4, scale * Math.pow(2, zoomFac));
        // --- compose text and target layer ---
        targetCtx.save();
        if (scale >= 4) targetCtx.imageSmoothingEnabled = false;
        else {
            targetCtx.imageSmoothingEnabled = true;
            targetCtx.imageSmoothingQuality = scale >= 1 ? "low" : "medium";
        }
        targetCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
        targetCtx.translate(width / 2, height / 2);
        targetCtx.scale(scale, scale);
        targetCtx.rotate(p.angleRad);
        targetCtx.drawImage(layerArr[p.layerIndex].canvas, -centerX, -centerY);
        targetCtx.drawImage(textCanvas, -centerX, -centerY);
        targetCtx.restore();
        // --- layers ---
        layersCtx.save();
        layersCtx.fillStyle = "rgb(158,158,158)";
        layersCtx.fillRect(0, 0, width, height);
        {
            layersCtx.save();
            layersCtx.translate(width / 2, height / 2);
            layersCtx.scale(scale, scale);
            layersCtx.rotate(p.angleRad);
            layersCtx.imageSmoothingEnabled = false;
            //outline
            let borderSize = 1 / scale;
            layersCtx.globalAlpha = 0.2;
            layersCtx.drawImage(emptyCanvas, -centerX - borderSize, -centerY - borderSize, textCanvas.width + borderSize * 2, textCanvas.height + borderSize * 2);
            layersCtx.globalAlpha = 1;
            //erase
            layersCtx.globalCompositeOperation = "destination-out";
            layersCtx.drawImage(emptyCanvas, -centerX, -centerY, textCanvas.width, textCanvas.height);
            layersCtx.restore();
        }
        if (scale >= 4) layersCtx.imageSmoothingEnabled = false;
        else {
            layersCtx.imageSmoothingEnabled = true;
            layersCtx.imageSmoothingQuality = scale >= 1 ? "low" : "medium";
        }
        // layers below
        layersCtx.save();
        layersCtx.translate(width / 2, height / 2);
        layersCtx.scale(scale, scale);
        layersCtx.rotate(p.angleRad);
        for(var i = 0; i < p.layerIndex; i++)if (layerArr[i].opacity > 0) {
            layersCtx.globalAlpha = layerArr[i].opacity;
            layersCtx.globalCompositeOperation = layerArr[i].mixModeStr;
            layersCtx.drawImage(layerArr[i].canvas, -centerX, -centerY);
        }
        layersCtx.restore();
        // target layer
        layersCtx.globalAlpha = layerArr[p.layerIndex].opacity;
        layersCtx.globalCompositeOperation = layerArr[p.layerIndex].mixModeStr;
        layersCtx.drawImage(targetCanvas, 0, 0);
        // layers above
        layersCtx.save();
        layersCtx.translate(width / 2, height / 2);
        layersCtx.scale(scale, scale);
        layersCtx.rotate(p.angleRad);
        for(let i1 = p.layerIndex + 1; i1 < layerArr.length; i1++)if (layerArr[i1].opacity > 0) {
            layersCtx.globalAlpha = layerArr[i1].opacity;
            layersCtx.globalCompositeOperation = layerArr[i1].mixModeStr;
            layersCtx.drawImage(layerArr[i1].canvas, -centerX, -centerY);
        }
        layersCtx.restore();
        layersCtx.restore();
        // --- final composite ---
        previewCtx.save();
        previewCtx.fillStyle = checkerPattern;
        previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
        previewCtx.drawImage(layersCanvas, 0, 0);
        previewCtx.restore();
        // bounds
        previewCtx.save();
        previewCtx.globalCompositeOperation = "difference";
        previewCtx.strokeStyle = "#fff";
        previewCtx.lineWidth = 1;
        // centerX = p.x + bounds.x + bounds.width / 2;
        // centerY = p.y + bounds.y + bounds.height / 2;
        previewCtx.strokeRect(Math.round(width / 2 - bounds.width / 2 * scale), Math.round(height / 2 - bounds.height / 2 * scale), Math.round(bounds.width * scale), Math.round(bounds.height * scale));
        previewCtx.restore();
    }
    function move(x, y) {
        let rotated = (0, _bb.BB).rotate(x, y, -p.angleRad / Math.PI * 180);
        p.x += rotated.x / scale;
        p.y += rotated.y / scale;
        updatePreview();
    }
    let previewPointerListener = new (0, _bb.BB).PointerListener({
        target: previewCanvas,
        pointers: 1,
        onPointer: function(e) {
            if (e.type === "pointermove" && e.button) {
                e.eventPreventDefault();
                move(-e.dX, -e.dY);
            }
        },
        onWheel: function(e) {
            changeZoomFac(-e.deltaY);
        }
    });
    const wheelPrevent = (event)=>{
        event.preventDefault();
    };
    (0, _bb.BB).addEventListener(previewCanvas, "wheel", wheelPrevent);
    let row1 = (0, _bb.BB).el({
        parent: div,
        css: {
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            marginTop: "10px"
        }
    });
    let row2n3Wrapper = (0, _bb.BB).el({
        parent: div,
        css: isSmallWidth ? {} : {
            display: "flex",
            alignItems: "center",
            justifyContent: "space-between"
        }
    });
    let row2 = (0, _bb.BB).el({
        parent: row2n3Wrapper,
        css: {
            display: "flex",
            alignItems: "center",
            marginTop: "5px"
        }
    });
    let row3 = (0, _bb.BB).el({
        parent: row2n3Wrapper,
        css: {
            display: "flex",
            alignItems: "center",
            justifyContent: "space-between",
            marginTop: "5px",
            width: isSmallWidth ? "" : "300px"
        }
    });
    // --- row 1 ---
    // color
    let selectedRgbaObj = {
        r: 0,
        g: 0,
        b: 0,
        a: 1
    };
    let colorOptionsArr = [
        {
            r: 0,
            g: 0,
            b: 0,
            a: 1
        },
        {
            r: 255,
            g: 255,
            b: 255,
            a: 1
        }
    ];
    colorOptionsArr.unshift({
        r: p.secondaryColor.r,
        g: p.secondaryColor.g,
        b: p.secondaryColor.b,
        a: 1
    });
    colorOptionsArr.unshift({
        r: p.color.r,
        g: p.color.g,
        b: p.color.b,
        a: 1
    });
    let colorOptions = new (0, _colorOptions.ColorOptions)({
        colorArr: colorOptionsArr,
        initialIndex: 0,
        onChange: function(rgbaObj) {
            p.color = rgbaObj;
            updatePreview();
        }
    });
    colorOptions.getElement().title = (0, _language.LANG)("text-color");
    colorOptions.getElement().style.marginLeft = "-5px";
    row1.appendChild(colorOptions.getElement());
    let zoomFac = 0;
    function changeZoomFac(d) {
        zoomFac = Math.min(2, Math.max(-2, zoomFac + d));
        updatePreview();
        zoomInBtn.disabled = !canZoom(1);
        zoomOutBtn.disabled = !canZoom(-1);
    }
    function canZoom(d) {
        return zoomFac !== Math.min(2, Math.max(-2, zoomFac + d));
    }
    let zoomWrapper = (0, _bb.BB).el({
        parent: row1,
        css: {}
    });
    let zoomInBtn = (0, _bb.BB).el({
        parent: zoomWrapper,
        content: `<img height="20" src="${(0, _toolZoomInSvgDefault.default)}">`,
        title: (0, _language.LANG)("zoom-in"),
        tagName: "button",
        onClick: function() {
            changeZoomFac(1);
        },
        css: {
            fontWeight: "bold"
        }
    });
    let zoomOutBtn = (0, _bb.BB).el({
        parent: zoomWrapper,
        content: `<img height="20" src="${(0, _toolZoomOutSvgDefault.default)}">`,
        title: (0, _language.LANG)("zoom-out"),
        tagName: "button",
        onClick: function() {
            changeZoomFac(-1);
        },
        css: {
            fontWeight: "bold",
            marginLeft: "5px"
        }
    });
    // --- row 2 ---
    let sizeInput = (0, _bb.BB).el({
        parent: row2,
        tagName: "input",
        title: (0, _language.LANG)("text-size"),
        custom: {
            type: "number",
            min: 1,
            max: 10000,
            value: p.size
        },
        css: {
            width: "60px"
        },
        onChange: function() {
            sizeInput.value = "" + Math.max(1, Math.min(10000, parseInt(sizeInput.value)));
            updatePreview();
        }
    });
    let sizePointerListener = new (0, _bb.BB).PointerListener({
        target: sizeInput,
        onWheel: function(e) {
            sizeInput.value = "" + Math.max(1, Math.min(1000, parseInt(sizeInput.value) - e.deltaY));
            updatePreview();
        }
    });
    let modeWrapper;
    let fontSelect;
    let fontPointerListener;
    modeWrapper = (0, _bb.BB).el({
        css: {
            fontSize: "15px",
            marginLeft: "10px"
        }
    });
    fontSelect = new (0, _select.Select)({
        isFocusable: true,
        optionArr: [
            [
                "sans-serif",
                "Sans-serif"
            ],
            [
                "serif",
                "Serif"
            ],
            [
                "monospace",
                "Monospace"
            ],
            [
                "cursive",
                "Cursive"
            ],
            [
                "fantasy",
                "Fantasy"
            ], 
        ],
        initValue: p.font,
        onChange: function(val) {
            updatePreview();
        }
    });
    modeWrapper.appendChild(fontSelect.getElement());
    row2.appendChild(modeWrapper);
    fontPointerListener = new (0, _bb.BB).PointerListener({
        target: fontSelect.getElement(),
        onWheel: function(e) {
            fontSelect.setDeltaValue(e.deltaY);
        }
    });
    // --- row 3 ---
    let alignRadioList = new (0, _imageRadioList.ImageRadioList)({
        optionArr: [
            {
                id: "left",
                title: (0, _language.LANG)("text-left"),
                image: (0, _alignLeftSvgDefault.default)
            },
            {
                id: "center",
                title: (0, _language.LANG)("text-center"),
                image: (0, _alignCenterSvgDefault.default)
            },
            {
                id: "right",
                title: (0, _language.LANG)("text-right"),
                image: (0, _alignRightSvgDefault.default)
            }
        ],
        initId: p.align,
        onChange: function(id) {
            updatePreview();
        }
    });
    row3.appendChild(alignRadioList.getElement());
    let italicToggle = new (0, _imageToggle.ImageToggle)({
        image: (0, _typoItalicSvgDefault.default),
        title: (0, _language.LANG)("text-italic"),
        initValue: p.isItalic,
        onChange: function(b) {
            updatePreview();
        }
    });
    row3.appendChild(italicToggle.getElement());
    let boldToggle = new (0, _imageToggle.ImageToggle)({
        image: (0, _typoBoldSvgDefault.default),
        title: (0, _language.LANG)("text-bold"),
        initValue: p.isBold,
        onChange: function(b) {
            updatePreview();
        }
    });
    row3.appendChild(boldToggle.getElement());
    let opacitySlider = new (0, _klSlider.KlSlider)({
        label: (0, _language.LANG)("opacity"),
        width: 150,
        height: 30,
        min: 0.01,
        max: 1,
        value: p.opacity,
        resolution: 225,
        eventResMs: 1000 / 30,
        toValue: (displayValue)=>displayValue / 100,
        toDisplayValue: (value)=>value * 100,
        onChange: function(v) {
            updatePreview();
        }
    });
    row3.appendChild(opacitySlider.getElement());
    let textInput = (0, _bb.BB).el({
        parent: div,
        tagName: "textarea",
        custom: {
            placeholder: (0, _language.LANG)("text-placeholder"),
            "data-ignore-focus": "true"
        },
        css: {
            whiteSpace: "pre",
            overflow: "auto",
            width: "100%",
            height: "70px",
            resize: "vertical",
            marginTop: "10px"
        },
        onChange: function() {
            updatePreview();
        }
    });
    textInput.addEventListener("input", updatePreview);
    setTimeout(function() {
        textInput.focus();
        textInput.select();
    });
    let closefunc;
    let keyListener = new (0, _bb.BB).KeyListener({
        onDown: function(keyStr, e, comboStr) {
            if ((0, _bb.BB).isInputFocused(true)) return;
            if (keyStr === "left") move(-1, 0);
            if (keyStr === "right") move(1, 0);
            if (keyStr === "up") move(0, -1);
            if (keyStr === "down") move(0, 1);
        }
    });
    // prevent mobile keyboards scrolling page
    function onScroll() {
        window.scrollTo(0, 0);
    }
    window.addEventListener("scroll", onScroll);
    (0, _popup.popup)({
        target: document.body,
        message: `<b>${(0, _language.LANG)("text-title")}</b>`,
        div: div,
        buttons: [
            "Ok",
            "Cancel"
        ],
        style: isSmallWidth ? {} : {
            width: "500px"
        },
        callback: function(val) {
            let result = {
                x: p.x,
                y: p.y,
                textStr: textInput.value,
                align: alignRadioList.getValue(),
                isItalic: italicToggle.getValue(),
                isBold: boldToggle.getValue(),
                color: p.color,
                size: sizeInput.value,
                font: fontSelect.getValue(),
                opacity: opacitySlider.getValue()
            };
            window.removeEventListener("scroll", onScroll);
            textInput.removeEventListener("input", updatePreview);
            (0, _bb.BB).destroyEl(textInput);
            previewPointerListener.destroy();
            sizePointerListener.destroy();
            fontPointerListener.destroy();
            (0, _bb.BB).removeEventListener(previewCanvas, "wheel", wheelPrevent);
            (0, _bb.BB).destroyEl(previewWrapper);
            (0, _bb.BB).destroyEl(zoomInBtn);
            (0, _bb.BB).destroyEl(zoomOutBtn);
            (0, _bb.BB).destroyEl(sizeInput);
            colorOptions.destroy();
            fontSelect.destroy();
            keyListener.destroy();
            alignRadioList.destroy();
            italicToggle.destroy();
            boldToggle.destroy();
            opacitySlider.destroy();
            if (val === "Ok") p.onConfirm(result);
        },
        autoFocus: false,
        clickOnEnter: "Ok",
        ignoreBackground: true,
        closefunc: function(func) {
            closefunc = func;
        }
    });
    updatePreview();
}

},{"../../../bb/bb":"dcQKo","../../image-operations/render-text":"fEvNY","../base-components/color-options":"e85vi","../base-components/select":"7mzRU","../base-components/image-radio-list":"enKw8","../base-components/image-toggle":"5vi2a","../base-components/kl-slider":"6YGce","./popup":"4Ltiz","url:~/src/app/img/ui/align-left.svg":"Py9AR","url:~/src/app/img/ui/align-center.svg":"btOkE","url:~/src/app/img/ui/align-right.svg":"7ZAGJ","url:~/src/app/img/ui/typo-italic.svg":"boUW5","url:~/src/app/img/ui/typo-bold.svg":"d66tx","url:~/src/app/img/ui/tool-zoom-in.svg":"bPttw","url:~/src/app/img/ui/tool-zoom-out.svg":"4NGgM","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"Py9AR":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "align-left.777c0e89.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"btOkE":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "align-center.788b2715.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"7ZAGJ":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "align-right.f7b7f5c4.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"boUW5":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "typo-italic.6740f6e7.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"d66tx":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "typo-bold.0bd83bef.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"8CgvP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 *
 * p = {
 *     image: convertedPsd | {type: 'image', width: number, height: number, canvas: image | canvas},
 *     maxSize: number,
 *     target: htmlElement,
 *     callback: func(
 *         {
 *             type: 'as-image',
 *             image: image | canvas,
 *         } | {
 *             type: 'as-image-psd',
 *             image: convertedPsd,
 *             cropObj: {x: number, y: number, width: number, height: number}
 *         } | {
 *             type: 'as-layer',
 *             image: image | canvas,
 *         } | {
 *             type: 'cancel',
 *         }
 *     )
 * }
 *
 * @param p {}
 */ parcelHelpers.export(exports, "showImportImageDialog", ()=>showImportImageDialog);
var _bb = require("../../../bb/bb");
var _cropCopy = require("../components/crop-copy");
var _checkbox = require("../base-components/checkbox");
var _popup = require("./popup");
var _language = require("../../../language/language");
function showImportImageDialog(p) {
    const div = (0, _bb.BB).el({});
    const isSmall = window.innerWidth < 550 || window.innerHeight < 550;
    const style = isSmall ? {} : {
        width: "500px"
    };
    let resolutionEl;
    const cropCopy = new (0, _cropCopy.CropCopy)({
        width: isSmall ? 340 : 540,
        height: isSmall ? 300 : 400,
        canvas: p.image.canvas,
        isNotCopy: true,
        onChange: function(width, height) {
            if (!resolutionEl) return;
            updateResolution(width, height);
        }
    });
    (0, _bb.BB).css(cropCopy.getEl(), {
        marginLeft: "-20px",
        borderTop: "1px solid #bbb",
        borderBottom: "1px solid #bbb"
    });
    cropCopy.getEl().title = (0, _language.LANG)("crop-drag-to-crop");
    div.appendChild(cropCopy.getEl());
    resolutionEl = (0, _bb.BB).el({
        parent: div,
        css: {
            marginTop: "10px",
            textAlign: "center",
            color: "#888",
            lineHeight: "20px"
        }
    });
    function updateResolution(w, h) {
        const fit = (0, _bb.BB).fitInto(w, h, p.maxSize, p.maxSize);
        if (fit.width < w) {
            resolutionEl.innerHTML = `<span style="color:#f00">${w} X ${h}</span> ‚ü∂ ${Math.round(fit.width)} X ${Math.round(fit.height)}`;
            resolutionEl.title = (0, _language.LANG)("import-too-large");
        } else {
            resolutionEl.innerHTML = `${w} X ${h}`;
            resolutionEl.title = "";
        }
    }
    updateResolution(p.image.width, p.image.height);
    let doFlatten = false;
    function showWarnings(psdWarningArr) {
        let contentArr = [];
        let warningMap = {
            "mask": "Masks not supported. Mask was applied.",
            "clipping": "Clipping not supported. Clipping layers were merged.",
            "group": "Groups not supported. Layers were ungrouped.",
            "adjustment": "Adjustment layers not supported.",
            "layer-effect": "Layer effects not supported.",
            "smart-object": "Smart objects not supported.",
            "blend-mode": "Unsupported layer blend mode.",
            "bits-per-channel": "Unsupported color depth. Only 8bit per channel supported."
        };
        for(let i = 0; i < psdWarningArr.length; i++)contentArr.push("- " + warningMap[psdWarningArr[i]]);
        alert(contentArr.join("\n"));
    }
    let flattenCheckbox;
    if (p.image.type === "psd") {
        const noteStyle = {
            background: "rgba(255,255,0,0.5)",
            padding: "10px",
            marginTop: "5px",
            marginBottom: "5px",
            border: "1px solid #e7d321",
            borderRadius: "5px"
        };
        if (p.image.layers) {
            flattenCheckbox = new (0, _checkbox.Checkbox)({
                init: doFlatten,
                label: (0, _language.LANG)("import-flatten"),
                callback: function(b) {
                    doFlatten = b;
                }
            });
            div.appendChild(flattenCheckbox.getElement());
            if (p.image.warningArr) {
                const noteEl = (0, _bb.BB).el({
                    content: (0, _language.LANG)("import-psd-limited-support"),
                    css: noteStyle
                });
                noteEl.appendChild((0, _bb.BB).el({
                    tagName: "a",
                    content: "Details",
                    onClick: function() {
                        showWarnings(p.image.warningArr);
                    }
                }));
                div.appendChild(noteEl);
            }
        } else {
            const noteEl1 = (0, _bb.BB).el({
                content: (0, _language.LANG)("import-psd-unsupported"),
                css: noteStyle
            });
            div.appendChild(noteEl1);
        }
    }
    function callback(result) {
        const croppedImage = cropCopy.getCroppedImage();
        const cropRect = cropCopy.getRect();
        const isCropped = p.image.width !== cropRect.width && p.image.height !== cropRect.height;
        cropCopy.destroy();
        if (flattenCheckbox) flattenCheckbox.destroy();
        if (result === (0, _language.LANG)("import-btn-as-layer")) p.callback({
            type: "as-layer",
            image: isCropped ? croppedImage : p.image.canvas
        });
        else if (result === (0, _language.LANG)("import-btn-as-image")) {
            if (p.image.type === "psd") {
                if (doFlatten) p.image.layers = null;
                p.callback({
                    type: "as-image-psd",
                    image: p.image,
                    cropObj: cropRect
                });
            } else if (p.image.type === "image") p.callback({
                type: "as-image",
                image: croppedImage
            });
        } else p.callback({
            type: "cancel"
        });
    }
    (0, _popup.popup)({
        target: p.target,
        message: `<b>${(0, _language.LANG)("import-title")}</b>`,
        div: div,
        style,
        buttons: [
            (0, _language.LANG)("import-btn-as-layer"),
            (0, _language.LANG)("import-btn-as-image"),
            "Cancel"
        ],
        primaries: [
            (0, _language.LANG)("import-btn-as-layer"),
            (0, _language.LANG)("import-btn-as-image")
        ],
        callback: callback,
        autoFocus: "As Image"
    });
}

},{"../../../bb/bb":"dcQKo","../components/crop-copy":"aTBXS","../base-components/checkbox":"kPAwM","./popup":"4Ltiz","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"Q3aBW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "blendPsdToKl", ()=>blendPsdToKl);
parcelHelpers.export(exports, "blendKlToPsd", ()=>blendKlToPsd);
/**
 * Converts ag-psd object into something that KlCanvas can represent
 * @param psdObj
 */ parcelHelpers.export(exports, "readPsd", ()=>readPsd);
parcelHelpers.export(exports, "klPsdToKlProject", ()=>klPsdToKlProject);
var _createCanvas = require("../../bb/base/create-canvas");
var _language = require("../../language/language");
var _klCanvas = require("../canvas/kl-canvas");
let kl2PsdMap;
let psd2KlMap;
function init() {
    if (kl2PsdMap) return;
    kl2PsdMap = {
        "source-over": "normal",
        "darken": "darken",
        "multiply": "multiply",
        "color-burn": "color burn",
        "lighten": "lighten",
        "screen": "screen",
        "color-dodge": "color dodge",
        "overlay": "overlay",
        "soft-light": "soft light",
        "hard-light": "hard light",
        "difference": "difference",
        "exclusion": "exclusion",
        "hue": "hue",
        "saturation": "saturation",
        "color": "color",
        "luminosity": "luminosity"
    };
    psd2KlMap = {};
    let keys = Object.keys(kl2PsdMap);
    for(let i = 0; i < keys.length; i++)psd2KlMap[kl2PsdMap[keys[i]]] = keys[i];
}
function blendPsdToKl(str) {
    init();
    return psd2KlMap[str];
}
function blendKlToPsd(str) {
    init();
    return kl2PsdMap[str];
}
function readPsd(psdObj) {
    let result = {
        type: "psd",
        canvas: psdObj.canvas,
        width: psdObj.width,
        height: psdObj.height
    };
    function addWarning(warningStr) {
        if (!result.warningArr) result.warningArr = [];
        if (result.warningArr.includes(warningStr)) return;
        result.warningArr.push(warningStr);
    }
    function getMixModeStr(blendMode) {
        let mixModeStr = blendPsdToKl(blendMode);
        if (!mixModeStr) {
            addWarning("blend-mode");
            mixModeStr = "source-over";
        }
        return mixModeStr;
    }
    if (psdObj.bitsPerChannel !== 8) addWarning("bits-per-channel");
    if (!psdObj.children) {
        result.error = true;
        return result;
    }
    // count resulting layers
    let maxLayers = (0, _klCanvas.MAX_LAYERS);
    let layerCount = 0;
    function countWithinGroup(groupObj) {
        let result = 0;
        if (groupObj.blendMode) {
            let mixModeStr = blendPsdToKl(groupObj.blendMode);
            if (mixModeStr && mixModeStr !== "source-over") return 1;
        }
        for(let i = 0; i < groupObj.children.length; i++){
            let item = groupObj.children[i];
            if (item.clipping || item.adjustment) continue;
            if (item.children) {
                addWarning("group");
                result += countWithinGroup(item);
            } else result++;
        }
        return result;
    }
    layerCount += countWithinGroup(psdObj);
    if (layerCount > maxLayers) {
        result.error = true;
        return result;
    }
    result.layers = [];
    function prepareMask(maskCanvas, defaultColor) {
        const groupMaskCtx = maskCanvas.getContext("2d");
        let imData = groupMaskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
        if (defaultColor === 0) for(let i = 0; i < imData.data.length; i += 4)imData.data[i + 3] = imData.data[i];
        else for(let i1 = 0; i1 < imData.data.length; i1 += 4)imData.data[i1 + 3] = 255 - imData.data[i1];
        groupMaskCtx.putImageData(imData, 0, 0);
    }
    function convertGroup(psdGroupObj) {
        let resultArr = [];
        let groupOpacity = psdGroupObj.hidden ? 0 : psdGroupObj.opacity;
        let groupMixModeStr = getMixModeStr(psdGroupObj.blendMode);
        let groupCanvas;
        let groupCtx;
        if (groupMixModeStr !== "source-over") {
            groupCanvas = (0, _createCanvas.createCanvas)(result.width, result.height);
            groupCtx = groupCanvas.getContext("2d");
        }
        // prepare group mask
        if (psdGroupObj.mask) {
            addWarning("mask");
            prepareMask(psdGroupObj.mask.canvas, psdGroupObj.mask.defaultColor);
        }
        for(let i = 0; i < psdGroupObj.children.length; i++){
            let item = psdGroupObj.children[i];
            if (item.clipping) continue;
            if (item.adjustment) {
                addWarning("adjustment");
                continue;
            }
            let hasClipping = (item.children || item.canvas) && psdGroupObj.children[i + 1] && psdGroupObj.children[i + 1].clipping;
            if (hasClipping) addWarning("clipping");
            if (item.children) {
                let innerArr = convertGroup(item);
                for(let e = 0; e < innerArr.length; e++){
                    let innerItem = innerArr[e];
                    let innerCtx = innerItem.image.getContext("2d");
                    // clipping
                    if (hasClipping) {
                        let clippingCanvas = (0, _createCanvas.createCanvas)(result.width, result.height);
                        let clippingCtx = clippingCanvas.getContext("2d");
                        clippingCtx.drawImage(innerItem.image, 0, 0);
                        for(let f = i + 1; f < psdGroupObj.children.length && psdGroupObj.children[f].clipping; f++){
                            let clippingItem = psdGroupObj.children[f];
                            if (clippingItem.opacity === 0 || clippingItem.hidden) continue;
                            clippingCtx.globalCompositeOperation = getMixModeStr(clippingItem.blendMode);
                            clippingCtx.globalAlpha = clippingItem.opacity;
                            clippingCtx.drawImage(clippingItem.canvas, clippingItem.left, clippingItem.top);
                        }
                        innerCtx.globalCompositeOperation = "source-atop";
                        innerCtx.drawImage(clippingCanvas, 0, 0);
                    }
                    // group mask
                    if (psdGroupObj.mask) {
                        innerCtx.globalCompositeOperation = psdGroupObj.mask.defaultColor === 0 ? "destination-in" : "destination-out";
                        innerCtx.drawImage(psdGroupObj.mask.canvas, psdGroupObj.mask.left, psdGroupObj.mask.top);
                    }
                    if (groupCanvas) {
                        groupCtx.globalCompositeOperation = innerItem.mixModeStr;
                        groupCtx.globalAlpha = innerItem.opacity;
                        groupCtx.drawImage(innerItem.image, 0, 0);
                    } else {
                        innerItem.opacity = innerItem.opacity * groupOpacity;
                        resultArr.push(innerItem);
                    }
                }
                continue;
            }
            let canvas = (0, _createCanvas.createCanvas)(result.width, result.height);
            let ctx = canvas.getContext("2d");
            if (item.canvas) ctx.drawImage(item.canvas, item.left, item.top);
            // effects
            if (item.effects) addWarning("layer-effect");
            // mask
            if (item.mask) {
                addWarning("mask");
                prepareMask(item.mask.canvas, item.mask.defaultColor);
                ctx.globalCompositeOperation = item.mask.defaultColor === 0 ? "destination-in" : "destination-out";
                ctx.drawImage(item.mask.canvas, item.mask.left, item.mask.top);
            }
            // clipping
            if (hasClipping) {
                let clippingCanvas1 = (0, _createCanvas.createCanvas)(item.right - item.left, item.bottom - item.top);
                let clippingCtx1 = clippingCanvas1.getContext("2d");
                clippingCtx1.drawImage(item.canvas, 0, 0);
                for(let e1 = i + 1; e1 < psdGroupObj.children.length && psdGroupObj.children[e1].clipping; e1++){
                    let clippingItem1 = psdGroupObj.children[e1];
                    if (clippingItem1.opacity === 0 || clippingItem1.hidden) continue;
                    clippingCtx1.globalCompositeOperation = getMixModeStr(clippingItem1.blendMode);
                    clippingCtx1.globalAlpha = clippingItem1.opacity;
                    clippingCtx1.drawImage(clippingItem1.canvas, clippingItem1.left - item.left, clippingItem1.top - item.top);
                }
                ctx.globalCompositeOperation = "source-atop";
                ctx.drawImage(clippingCanvas1, item.left, item.top);
            }
            // group mask
            if (psdGroupObj.mask) {
                ctx.globalCompositeOperation = psdGroupObj.mask.defaultColor === 0 ? "destination-in" : "destination-out";
                ctx.drawImage(psdGroupObj.mask.canvas, psdGroupObj.mask.left, psdGroupObj.mask.top);
            }
            if (groupCanvas) {
                if (groupOpacity > 0) {
                    groupCtx.globalCompositeOperation = getMixModeStr(item.blendMode);
                    groupCtx.globalAlpha = item.hidden ? 0 : item.opacity;
                    groupCtx.drawImage(canvas, 0, 0);
                }
            } else resultArr.push({
                name: item.name,
                opacity: (item.hidden ? 0 : item.opacity) * groupOpacity,
                mixModeStr: getMixModeStr(item.blendMode),
                image: canvas
            });
        }
        if (groupCanvas) resultArr = [
            {
                name: psdGroupObj.name,
                opacity: groupOpacity,
                mixModeStr: groupMixModeStr,
                image: groupCanvas
            }
        ];
        return resultArr;
    }
    result.layers = convertGroup({
        name: "root",
        opacity: 1,
        blendMode: "normal",
        children: psdObj.children
    });
    return result;
}
function klPsdToKlProject(klPsd) {
    // only share references to Canvas elements
    const result = {
        width: klPsd.width,
        height: klPsd.height,
        layers: []
    };
    if (klPsd.layers) result.layers = result.layers.concat(klPsd.layers.map((item)=>{
        return {
            name: item.name,
            opacity: item.opacity,
            mixModeStr: item.mixModeStr,
            image: item.image
        };
    }));
    else // flattened
    result.layers.push({
        name: (0, _language.LANG)("background"),
        opacity: 1,
        mixModeStr: "source-over",
        image: klPsd.canvas
    });
    return result;
}

},{"../../bb/base/create-canvas":"4BLUK","../../language/language":"iiYGN","../canvas/kl-canvas":"l78MY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eCGtt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setDbName", ()=>setDbName);
/**
 * getKlProjectObj {
 *     width: int,
 *     height: int,
 *     layers: {
 *        name: string,
 *        opacity: float (0 - 1),
 *        mixModeStr: string,
 *        image: image object                <--------- image already loaded!
 *     }[]
 * }
 *
 * @param successCallback function - called when succesfully queried. passes KlProjectObj
 * @param errorCallback - function(errorStr) - called when error during query
 */ parcelHelpers.export(exports, "getKlProjectObj", ()=>getKlProjectObj);
/**
 * stores a klProjectObj into id = 1 in database:dbNameStr > storage: storageNameStr
 *
 * KlProjectObj {
 *     width: int,
 *     height: int,
 *     layers: {
 *        name: string,
 *        opacity: float (0 - 1),
 *        mixModeStr: string,
 *        blob: blob object                 <--------- blob!
 *     }[]
 * }
 *
 * @param storageProject IKlStorageProject - project to be stored
 * @param successCallback function() - on successful transaction
 * @param errorCallback function(errorStr) - on error
 */ parcelHelpers.export(exports, "storeKlProjectObj", ()=>storeKlProjectObj);
/**
 * removes id = 1 from database:dbNameStr > storage: storageNameStr
 *
 * @param successCallback function() - on successful transaction
 * @param errorCallback function(error) - on error
 */ parcelHelpers.export(exports, "clear", ()=>clear);
const indexedDbIsSupported = !!window.indexedDB;
let dbNameStr = "Klecks";
const storageNameStr = "ProjectStore";
function setDbName(name) {
    dbNameStr = "" + name;
}
/**
 * connects to db dbNameStr, then executes transaction on storageNameStr storage
 * with index 'id'
 *
 * @param actionFunction function(storeObj) - what you want to execute during transaction
 * @param successCallback function() - on succesful transaction
 * @param errorCallback function(errorStr) - on error
 */ function execIndexedDBTransaction(actionFunction, successCallback, errorCallback) {
    let hasFinished = false;
    function onSuccess() {
        if (hasFinished) return;
        hasFinished = true;
        successCallback();
    }
    function onError(errorStr) {
        if (hasFinished) return;
        hasFinished = true;
        errorCallback(errorStr);
    }
    if (!indexedDbIsSupported) {
        setTimeout(function() {
            onError("no indexed db available");
        }, 0);
        return;
    }
    let requestObj;
    try {
        requestObj = window.indexedDB.open(dbNameStr, 1);
    } catch (e) {
        onError(e.message);
        return;
    }
    requestObj.onupgradeneeded = function(e) {
        try {
            let db = requestObj.result;
            let store = db.createObjectStore(storageNameStr, {
                keyPath: "id"
            });
            store.createIndex("id", "id", {
                unique: true
            });
        } catch (e1) {
            onError(e1.message);
        }
    };
    requestObj.onerror = function(e) {
        onError("indexedDB.open failed, " + requestObj.error);
    };
    requestObj.onsuccess = function(e) {
        let databaseObj;
        let transactionObj;
        let storeObj;
        try {
            databaseObj = requestObj.result;
            if (!databaseObj.objectStoreNames.contains(storageNameStr)) {
                //someone maybe messed with the db, or creation failed earlier
                //it's broken -> destroy
                window.indexedDB.deleteDatabase(dbNameStr);
                onError("object store " + storageNameStr + " missing. destroying db");
                return;
            }
            transactionObj = databaseObj.transaction(storageNameStr, "readwrite");
            storeObj = transactionObj.objectStore(storageNameStr);
            storeObj.index("id");
        } catch (e1) {
            onError(e1.message);
            return;
        }
        databaseObj.onerror = function(e) {
            onError("database error, " + databaseObj.error);
        };
        try {
            actionFunction(storeObj);
        } catch (e2) {
            onError(e2.message);
            return;
        }
        transactionObj.oncomplete = function() {
            onSuccess();
            databaseObj.close();
        };
        transactionObj.onerror = function() {
            onError("transaction error, " + transactionObj.error);
        };
    };
}
function getKlProjectObj(successCallback, errorCallback) {
    if (indexedDbIsSupported) {
        let query;
        execIndexedDBTransaction(function(storeObj) {
            query = storeObj.get(1);
        }, function() {
            successCallback(query.result);
        }, function(errorStr) {
            errorCallback("execIndexedDBTransaction error, " + errorStr);
        });
    } else successCallback(null);
}
function storeKlProjectObj(storageProject, successCallback, errorCallback) {
    execIndexedDBTransaction(function(storeObj) {
        storeObj.put(storageProject);
    }, function() {
        successCallback();
    }, function(errorStr) {
        errorCallback(errorStr);
    });
}
function clear(successCallback, errorCallback) {
    execIndexedDBTransaction(function(storeObj) {
        storeObj.delete(1);
    }, function() {
        successCallback();
    }, function(error) {
        errorCallback(error);
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lIjDv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterLibStatus", ()=>filterLibStatus);
parcelHelpers.export(exports, "filterLib", ()=>filterLib);
// @ts-ignore
var _editBrightnessContrastSvg = require("url:~/src/app/img/ui/edit-brightness-contrast.svg");
var _editBrightnessContrastSvgDefault = parcelHelpers.interopDefault(_editBrightnessContrastSvg);
// @ts-ignore
var _editCropSvg = require("url:~/src/app/img/ui/edit-crop.svg");
var _editCropSvgDefault = parcelHelpers.interopDefault(_editCropSvg);
// @ts-ignore
var _editCurvesSvg = require("url:~/src/app/img/ui/edit-curves.svg");
var _editCurvesSvgDefault = parcelHelpers.interopDefault(_editCurvesSvg);
// @ts-ignore
var _editFlipSvg = require("url:~/src/app/img/ui/edit-flip.svg");
var _editFlipSvgDefault = parcelHelpers.interopDefault(_editFlipSvg);
// @ts-ignore
var _editHueSaturationSvg = require("url:~/src/app/img/ui/edit-hue-saturation.svg");
var _editHueSaturationSvgDefault = parcelHelpers.interopDefault(_editHueSaturationSvg);
// @ts-ignore
var _editInvertPng = require("url:~/src/app/img/ui/edit-invert.png");
var _editInvertPngDefault = parcelHelpers.interopDefault(_editInvertPng);
// @ts-ignore
var _editPerspectiveSvg = require("url:~/src/app/img/ui/edit-perspective.svg");
var _editPerspectiveSvgDefault = parcelHelpers.interopDefault(_editPerspectiveSvg);
// @ts-ignore
var _editResizeSvg = require("url:~/src/app/img/ui/edit-resize.svg");
var _editResizeSvgDefault = parcelHelpers.interopDefault(_editResizeSvg);
// @ts-ignore
var _editRotateSvg = require("url:~/src/app/img/ui/edit-rotate.svg");
var _editRotateSvgDefault = parcelHelpers.interopDefault(_editRotateSvg);
// @ts-ignore
var _editTiltShiftPng = require("url:~/src/app/img/ui/edit-tilt-shift.png");
var _editTiltShiftPngDefault = parcelHelpers.interopDefault(_editTiltShiftPng);
// @ts-ignore
var _editToAlphaSvg = require("url:~/src/app/img/ui/edit-to-alpha.svg");
var _editToAlphaSvgDefault = parcelHelpers.interopDefault(_editToAlphaSvg);
// @ts-ignore
var _editTransformSvg = require("url:~/src/app/img/ui/edit-transform.svg");
var _editTransformSvgDefault = parcelHelpers.interopDefault(_editTransformSvg);
// @ts-ignore
var _editTriangleBlurPng = require("url:~/src/app/img/ui/edit-triangle-blur.png");
var _editTriangleBlurPngDefault = parcelHelpers.interopDefault(_editTriangleBlurPng);
// @ts-ignore
var _editUnsharpMaskPng = require("url:~/src/app/img/ui/edit-unsharp-mask.png");
var _editUnsharpMaskPngDefault = parcelHelpers.interopDefault(_editUnsharpMaskPng);
// @ts-ignore
var _editGridSvg = require("url:~/src/app/img/ui/edit-grid.svg");
var _editGridSvgDefault = parcelHelpers.interopDefault(_editGridSvg);
// @ts-ignore
var _editNoiseSvg = require("url:~/src/app/img/ui/edit-noise.svg");
var _editNoiseSvgDefault = parcelHelpers.interopDefault(_editNoiseSvg);
// @ts-ignore
var _editPatternSvg = require("url:~/src/app/img/ui/edit-pattern.svg");
var _editPatternSvgDefault = parcelHelpers.interopDefault(_editPatternSvg);
// @ts-ignore
var _editVanishPointSvg = require("url:~/src/app/img/ui/edit-vanish-point.svg");
var _editVanishPointSvgDefault = parcelHelpers.interopDefault(_editVanishPointSvg);
// @ts-ignore
var _editDistortSvg = require("url:~/src/app/img/ui/edit-distort.svg");
var _editDistortSvgDefault = parcelHelpers.interopDefault(_editDistortSvg);
const filterLibStatus = {
    isLoaded: false
};
const filterLib = {
    brightnessContrast: {
        lang: {
            name: "filter-bright-contrast-title",
            button: "filter-bright-contrast"
        },
        icon: (0, _editBrightnessContrastSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    cropExtend: {
        lang: {
            name: "filter-crop-title",
            button: "filter-crop-extend"
        },
        icon: (0, _editCropSvgDefault.default),
        updatePos: true,
        getDialog: null,
        apply: null,
        inEmbed: false
    },
    curves: {
        lang: {
            name: "filter-curves-title",
            button: "filter-curves"
        },
        icon: (0, _editCurvesSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    distort: {
        lang: {
            name: "filter-distort",
            button: "filter-distort"
        },
        icon: (0, _editDistortSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    flip: {
        lang: {
            name: "filter-flip-title",
            button: "filter-flip"
        },
        icon: (0, _editFlipSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    hueSaturation: {
        lang: {
            name: "filter-hue-sat-title",
            button: "filter-hue-sat"
        },
        icon: (0, _editHueSaturationSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    invert: {
        lang: {
            name: "filter-invert",
            button: "filter-invert"
        },
        icon: (0, _editInvertPngDefault.default),
        updatePos: false,
        isInstant: true,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    perspective: {
        lang: {
            name: "filter-perspective-title",
            button: "filter-perspective"
        },
        icon: (0, _editPerspectiveSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    resize: {
        lang: {
            name: "filter-resize-title",
            button: "filter-resize"
        },
        icon: (0, _editResizeSvgDefault.default),
        updatePos: true,
        getDialog: null,
        apply: null,
        inEmbed: false
    },
    rotate: {
        lang: {
            name: "filter-rotate-title",
            button: "filter-rotate"
        },
        icon: (0, _editRotateSvgDefault.default),
        updatePos: true,
        getDialog: null,
        apply: null,
        inEmbed: false
    },
    tiltShift: {
        lang: {
            name: "filter-tilt-shift-title",
            button: "filter-tilt-shift"
        },
        icon: (0, _editTiltShiftPngDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    toAlpha: {
        lang: {
            name: "filter-to-alpha-title",
            button: "filter-to-alpha"
        },
        icon: (0, _editToAlphaSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    transform: {
        lang: {
            name: "filter-transform-title",
            button: "filter-transform"
        },
        icon: (0, _editTransformSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    blur: {
        lang: {
            name: "filter-triangle-blur-title",
            button: "filter-triangle-blur"
        },
        icon: (0, _editTriangleBlurPngDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    unsharpMask: {
        lang: {
            name: "filter-unsharp-mask-title",
            button: "filter-unsharp-mask"
        },
        icon: (0, _editUnsharpMaskPngDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    grid: {
        lang: {
            name: "filter-grid",
            button: "filter-grid"
        },
        icon: (0, _editGridSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    noise: {
        lang: {
            name: "filter-noise",
            button: "filter-noise"
        },
        icon: (0, _editNoiseSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    pattern: {
        lang: {
            name: "filter-pattern",
            button: "filter-pattern"
        },
        icon: (0, _editPatternSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    vanishPoint: {
        lang: {
            name: "filter-vanish-point-title",
            button: "filter-vanish-point"
        },
        icon: (0, _editVanishPointSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    }
};

},{"url:~/src/app/img/ui/edit-brightness-contrast.svg":"bvNvP","url:~/src/app/img/ui/edit-crop.svg":"iOGma","url:~/src/app/img/ui/edit-curves.svg":"kKw00","url:~/src/app/img/ui/edit-flip.svg":"iErGy","url:~/src/app/img/ui/edit-hue-saturation.svg":"7PkLB","url:~/src/app/img/ui/edit-invert.png":"cLH7w","url:~/src/app/img/ui/edit-perspective.svg":"h1bvA","url:~/src/app/img/ui/edit-resize.svg":"e8sYn","url:~/src/app/img/ui/edit-rotate.svg":"6TlrV","url:~/src/app/img/ui/edit-tilt-shift.png":"1KDHJ","url:~/src/app/img/ui/edit-to-alpha.svg":"g6BuE","url:~/src/app/img/ui/edit-transform.svg":"5YaQ9","url:~/src/app/img/ui/edit-triangle-blur.png":"1CGUQ","url:~/src/app/img/ui/edit-unsharp-mask.png":"jMMln","url:~/src/app/img/ui/edit-grid.svg":"bmclf","url:~/src/app/img/ui/edit-noise.svg":"jd7h8","url:~/src/app/img/ui/edit-pattern.svg":"d8jME","url:~/src/app/img/ui/edit-vanish-point.svg":"8xVpx","url:~/src/app/img/ui/edit-distort.svg":"gnasO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bvNvP":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "edit-brightness-contrast.97f67b0b.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"iOGma":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "edit-crop.e23b74d5.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"kKw00":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "edit-curves.e1274581.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"iErGy":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "edit-flip.0d761af0.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"7PkLB":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "edit-hue-saturation.c73b0cbc.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"cLH7w":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "edit-invert.229522c0.png" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"h1bvA":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "edit-perspective.f6d27cc7.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"e8sYn":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "edit-resize.e45829a8.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"1KDHJ":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "edit-tilt-shift.5faf472d.png" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"g6BuE":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "edit-to-alpha.3021c221.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"5YaQ9":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "edit-transform.90ef80d8.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"1CGUQ":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "edit-triangle-blur.cd2d10f7.png" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"jMMln":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "edit-unsharp-mask.6d8ed0c4.png" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"bmclf":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "edit-grid.9bc86d29.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"jd7h8":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "edit-noise.82864290.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"d8jME":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "edit-pattern.24d4a17a.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"8xVpx":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "edit-vanish-point.b046f428.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"gnasO":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "edit-distort.32de6aab.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"8eOZC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "brushes", ()=>brushes);
var _penBrush = require("./pen-brush");
var _blendBrush = require("./blend-brush");
var _sketchyBrush = require("./sketchy-brush");
var _pixelBrush = require("./pixel-brush");
var _eraserBrush = require("./eraser-brush");
var _smudgeBrush = require("./smudge-brush");
var _chemyBrush = require("./chemy-brush");
const brushes = {
    PenBrush: (0, _penBrush.PenBrush),
    BlendBrush: (0, _blendBrush.BlendBrush),
    SketchyBrush: (0, _sketchyBrush.SketchyBrush),
    PixelBrush: (0, _pixelBrush.PixelBrush),
    ChemyBrush: (0, _chemyBrush.ChemyBrush),
    SmudgeBrush: (0, _smudgeBrush.SmudgeBrush),
    EraserBrush: (0, _eraserBrush.EraserBrush)
};

},{"./pen-brush":"1WbL7","./blend-brush":"1OcHF","./sketchy-brush":"goQ9y","./pixel-brush":"3s9Dy","./eraser-brush":"9XyVo","./smudge-brush":"8pk70","./chemy-brush":"3wxkc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1WbL7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PenBrush", ()=>PenBrush);
var _bb = require("../../bb/bb");
var _brushesCommon = require("./brushes-common");
var _kl = require("../kl");
function PenBrush() {
    let context;
    let history = new (0, _kl.KL).DecoyKlHistory();
    let historyEntry;
    let settingColor, settingSize = 2, settingSpacing = 0.8489, settingOpacity = 1;
    let settingColorStr;
    let settingHasSizePressure = true, settingHasOpacityPressure = false;
    let settingLockLayerAlpha = false;
    let ALPHA_CIRCLE = 0, ALPHA_CHALK = 1, ALPHA_CAL = 2, ALPHA_SQUARE = 3;
    let settingAlphaId = ALPHA_CIRCLE;
    let lineToolLastDot;
    let lastInput = {
        x: 0,
        y: 0,
        pressure: 0
    };
    let lastInput2 = {
        x: 0,
        y: 0,
        pressure: 0
    };
    let isDrawing = false;
    let alphaOpacityArr = [
        1,
        0.9,
        1,
        1
    ];
    //mipmapping
    let alphaCanvas128 = (0, _bb.BB).canvas(128, 128);
    let alphaCanvas64 = (0, _bb.BB).canvas(64, 64);
    let alphaCanvas32 = (0, _bb.BB).canvas(32, 32);
    let bezierLine = null;
    let twoPI = Math.PI * 2;
    let hasDrawnDot = false; // current stroke has drawn at least one dot
    let inputArr;
    // pressure: 0-1
    function calcOpacity(pressure) {
        return settingOpacity * (settingHasOpacityPressure ? pressure * pressure : 1);
    }
    function updateAlphaCanvas() {
        if (settingAlphaId === ALPHA_CIRCLE || settingAlphaId === ALPHA_SQUARE) return;
        let instructionArr = [
            [
                alphaCanvas128,
                128
            ],
            [
                alphaCanvas64,
                64
            ],
            [
                alphaCanvas32,
                32
            ]
        ];
        let ctx;
        for(let i = 0; i < instructionArr.length; i++){
            ctx = instructionArr[i][0].getContext("2d");
            ctx.save();
            ctx.clearRect(0, 0, instructionArr[i][1], instructionArr[i][1]);
            ctx.fillStyle = "rgba(" + settingColor.r + ", " + settingColor.g + ", " + settingColor.b + ", " + alphaOpacityArr[settingAlphaId] + ")";
            ctx.fillRect(0, 0, instructionArr[i][1], instructionArr[i][1]);
            ctx.globalCompositeOperation = "destination-in";
            ctx.imageSmoothingQuality = "high";
            ctx.drawImage((0, _brushesCommon.alphaImArr)[settingAlphaId], 0, 0, instructionArr[i][1], instructionArr[i][1]);
            ctx.restore();
        }
    }
    /**
     *
     *
     * @param x
     * @param y
     * @param size
     * @param opacity
     * @param angle
     * @param before - [x, y, size, opacity, angle] the drawDot call before
     */ function drawDot(x, y, size, opacity, angle, before) {
        if (size <= 0) return;
        if (settingLockLayerAlpha) context.globalCompositeOperation = "source-atop";
        if (!before || before[3] !== opacity) context.globalAlpha = opacity;
        if (!before && (settingAlphaId === ALPHA_CIRCLE || settingAlphaId === ALPHA_SQUARE)) context.fillStyle = settingColorStr;
        if (settingAlphaId === ALPHA_CIRCLE) {
            context.beginPath();
            context.arc(x, y, size, 0, twoPI);
            context.closePath();
            context.fill();
            hasDrawnDot = true;
        } else if (settingAlphaId === ALPHA_SQUARE) {
            if (angle !== undefined) {
                context.save();
                context.translate(x, y);
                context.rotate(angle / 180 * Math.PI);
                context.fillRect(-size, -size, size * 2, size * 2);
                context.restore();
                hasDrawnDot = true;
            }
        } else {
            context.save();
            context.translate(x, y);
            let targetMipmap = alphaCanvas128;
            if (size <= 32 && size > 16) targetMipmap = alphaCanvas64;
            else if (size <= 16) targetMipmap = alphaCanvas32;
            context.scale(size, size);
            if (settingAlphaId === ALPHA_CHALK) context.rotate((x + y) * 53123 % twoPI); // without mod it sometimes looks different
            context.drawImage(targetMipmap, -1, -1, 2, 2);
            context.restore();
            hasDrawnDot = true;
        }
    }
    function continueLine(x, y, size, pressure) {
        if (bezierLine === null) {
            bezierLine = new (0, _bb.BB).BezierLine();
            bezierLine.add(lastInput.x, lastInput.y, 0, function() {});
        }
        let drawArr = []; //draw instructions. will be all drawn at once
        function dotCallback(val) {
            let localPressure = (0, _bb.BB).mix(lastInput2.pressure, pressure, val.t);
            let localOpacity = calcOpacity(localPressure);
            let localSize = Math.max(0.1, settingSize * (settingHasSizePressure ? localPressure : 1));
            drawArr.push([
                val.x,
                val.y,
                localSize,
                localOpacity,
                val.angle
            ]);
        }
        let localSpacing = size * settingSpacing;
        if (x === null) bezierLine.addFinal(localSpacing, dotCallback);
        else bezierLine.add(x, y, localSpacing, dotCallback);
        // execute draw instructions
        context.save();
        let before;
        for(let i = 0; i < drawArr.length; i++){
            let item = drawArr[i];
            drawDot(item[0], item[1], item[2], item[3], item[4], before);
            before = item;
        }
        context.restore();
    }
    //------------------ interface ---------------------------------------------------
    this.startLine = function(x, y, p) {
        historyEntry = {
            tool: [
                "brush",
                "PenBrush"
            ],
            actions: []
        };
        historyEntry.actions.push({
            action: "opacityPressure",
            params: [
                settingHasOpacityPressure
            ]
        });
        historyEntry.actions.push({
            action: "sizePressure",
            params: [
                settingHasSizePressure
            ]
        });
        historyEntry.actions.push({
            action: "setSize",
            params: [
                settingSize
            ]
        });
        historyEntry.actions.push({
            action: "setSpacing",
            params: [
                settingSpacing
            ]
        });
        historyEntry.actions.push({
            action: "setOpacity",
            params: [
                settingOpacity
            ]
        });
        historyEntry.actions.push({
            action: "setColor",
            params: [
                settingColor
            ]
        });
        historyEntry.actions.push({
            action: "setAlpha",
            params: [
                settingAlphaId
            ]
        });
        historyEntry.actions.push({
            action: "setLockAlpha",
            params: [
                settingLockLayerAlpha
            ]
        });
        p = (0, _bb.BB).clamp(p, 0, 1);
        let localOpacity = calcOpacity(p);
        let localSize = settingHasSizePressure ? Math.max(0.1, p * settingSize) : Math.max(0.1, settingSize);
        hasDrawnDot = false;
        isDrawing = true;
        context.save();
        drawDot(x, y, localSize, localOpacity);
        context.restore();
        lineToolLastDot = localSize * settingSpacing;
        lastInput.x = x;
        lastInput.y = y;
        lastInput.pressure = p;
        lastInput2.pressure = p;
        inputArr = [
            {
                x,
                y,
                pressure: p
            }
        ];
        historyEntry.actions.push({
            action: "startLine",
            params: [
                x,
                y,
                p
            ]
        });
    };
    this.goLine = function(x, y, p) {
        if (!isDrawing) return;
        historyEntry.actions.push({
            action: "goLine",
            params: [
                x,
                y,
                p
            ]
        });
        let pressure = (0, _bb.BB).clamp(p, 0, 1);
        let localSize = settingHasSizePressure ? Math.max(0.1, lastInput.pressure * settingSize) : Math.max(0.1, settingSize);
        context.save();
        continueLine(x, y, localSize, lastInput.pressure);
        /*context.fillStyle = 'red';
        context.fillRect(Math.floor(x), Math.floor(y - 10), 1, 20);
        context.fillRect(Math.floor(x - 10), Math.floor(y), 20, 1);*/ context.restore();
        lastInput.x = x;
        lastInput.y = y;
        lastInput2.pressure = lastInput.pressure;
        lastInput.pressure = pressure;
        inputArr.push({
            x,
            y,
            pressure: p
        });
    };
    this.endLine = function(x, y) {
        let localSize = settingHasSizePressure ? Math.max(0.1, lastInput.pressure * settingSize) : Math.max(0.1, settingSize);
        context.save();
        continueLine(null, null, localSize, lastInput.pressure);
        context.restore();
        isDrawing = false;
        if (settingAlphaId === ALPHA_SQUARE && !hasDrawnDot) {
            // find max pressure input, use that one
            let maxInput = inputArr[0];
            inputArr.forEach((item)=>{
                if (item.pressure > maxInput.pressure) maxInput = item;
            });
            context.save();
            let p = (0, _bb.BB).clamp(maxInput.pressure, 0, 1);
            let localOpacity = calcOpacity(p);
            drawDot(maxInput.x, maxInput.y, localSize, localOpacity, 0);
            context.restore();
        }
        bezierLine = null;
        if (historyEntry) {
            historyEntry.actions.push({
                action: "endLine",
                params: [
                    x,
                    y
                ]
            });
            history.push(historyEntry);
            historyEntry = undefined;
        }
        hasDrawnDot = false;
        inputArr = [];
    };
    //cheap n' ugly
    this.drawLineSegment = function(x1, y1, x2, y2) {
        lastInput.x = x2;
        lastInput.y = y2;
        lastInput.pressure = 1;
        if (isDrawing || x1 === undefined) return;
        let angle = (0, _bb.BB).pointsToAngleDeg({
            x: x1,
            y: y1
        }, {
            x: x2,
            y: y2
        });
        let mouseDist = Math.sqrt(Math.pow(x2 - x1, 2.0) + Math.pow(y2 - y1, 2.0));
        let eX = (x2 - x1) / mouseDist;
        let eY = (y2 - y1) / mouseDist;
        let loopDist;
        let bdist = settingSize * settingSpacing;
        lineToolLastDot = settingSize * settingSpacing;
        context.save();
        for(loopDist = lineToolLastDot; loopDist <= mouseDist; loopDist += bdist)drawDot(x1 + eX * loopDist, y1 + eY * loopDist, settingSize, settingOpacity, angle);
        context.restore();
        let historyEntry = {
            tool: [
                "brush",
                "PenBrush"
            ],
            actions: []
        };
        historyEntry.actions.push({
            action: "opacityPressure",
            params: [
                settingHasOpacityPressure
            ]
        });
        historyEntry.actions.push({
            action: "sizePressure",
            params: [
                settingHasSizePressure
            ]
        });
        historyEntry.actions.push({
            action: "setSize",
            params: [
                settingSize
            ]
        });
        historyEntry.actions.push({
            action: "setSpacing",
            params: [
                settingSpacing
            ]
        });
        historyEntry.actions.push({
            action: "setOpacity",
            params: [
                settingOpacity
            ]
        });
        historyEntry.actions.push({
            action: "setColor",
            params: [
                settingColor
            ]
        });
        historyEntry.actions.push({
            action: "setAlpha",
            params: [
                settingAlphaId
            ]
        });
        historyEntry.actions.push({
            action: "setLockAlpha",
            params: [
                settingLockLayerAlpha
            ]
        });
        historyEntry.actions.push({
            action: "drawLineSegment",
            params: [
                x1,
                y1,
                x2,
                y2
            ]
        });
        history.push(historyEntry);
    };
    //IS
    this.isDrawing = function() {
        return isDrawing;
    };
    //SET
    this.setAlpha = function(a) {
        if (settingAlphaId === a) return;
        settingAlphaId = a;
        updateAlphaCanvas();
    };
    this.setColor = function(c) {
        if (settingColor === c) return;
        settingColor = {
            r: c.r,
            g: c.g,
            b: c.b
        };
        settingColorStr = "rgb(" + settingColor.r + "," + settingColor.g + "," + settingColor.b + ")";
        updateAlphaCanvas();
    };
    this.setContext = function(c) {
        context = c;
    };
    this.setHistory = function(l) {
        history = l;
    };
    this.setSize = function(s) {
        settingSize = s;
    };
    this.setOpacity = function(o) {
        settingOpacity = o;
    };
    this.setSpacing = function(s) {
        settingSpacing = s;
    };
    this.sizePressure = function(b) {
        settingHasSizePressure = b;
    };
    this.opacityPressure = function(b) {
        settingHasOpacityPressure = b;
    };
    this.setLockAlpha = function(b) {
        settingLockLayerAlpha = b;
    };
    //GET
    this.getSpacing = function() {
        return settingSpacing;
    };
    this.getSize = function() {
        return settingSize;
    };
    this.getOpacity = function() {
        return settingOpacity;
    };
    this.getLockAlpha = function(b) {
        return settingLockLayerAlpha;
    };
}

},{"../../bb/bb":"dcQKo","./brushes-common":"8A7GM","../kl":"8nmWp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8A7GM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "alphaImArr", ()=>alphaImArr);
var _brushAlphas = require("./alphas/brush-alphas");
const alphaImArr = []; //used by default brush
alphaImArr[1] = (0, _brushAlphas.genBrushAlpha01)(128);
alphaImArr[2] = (0, _brushAlphas.genBrushAlpha02)(128);

},{"./alphas/brush-alphas":"6o2bW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6o2bW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// chalk
parcelHelpers.export(exports, "genBrushAlpha01", ()=>genBrushAlpha01);
// calligraphy
parcelHelpers.export(exports, "genBrushAlpha02", ()=>genBrushAlpha02);
var _bb = require("../../../bb/bb");
var _perlin = require("../../../bb/math/perlin");
function genBrushAlpha01(w) {
    const scaleFac = w / 500;
    const h = w;
    const canvas = (0, _bb.BB).canvas(w, h);
    const ctx = canvas.getContext("2d");
    const imData = ctx.createImageData(w, h);
    for(let x = 0; x < w; x++)for(let y = 0; y < h; y++){
        let i = (y * w + x) * 4;
        // base noise
        const sFac2 = scaleFac + (0, _perlin.noise).simplex2(x / 50 / scaleFac, y / 50 / scaleFac) * 0.04;
        let noisePattern = 100 + ((0, _perlin.noise).simplex2(x / 50 / sFac2, y / 50 / sFac2) + 1) / 2 * 100;
        noisePattern -= ((0, _perlin.noise).simplex2(x / 10 / scaleFac, y / 10 / scaleFac) + 1) / 2 * 100;
        // fade out in circular shape
        const centerDist = (0, _bb.BB).dist(w / 2, h / 2, x, y);
        let falloff = (0, _bb.BB).clamp(1 - ((centerDist - w / 2.5) / (w / 14) + (0, _perlin.noise).simplex2(x / 22 / sFac2, y / 22 / sFac2)), 0, 1);
        noisePattern = noisePattern * falloff;
        // make the middle darker
        const falloff2 = (0, _bb.BB).clamp(1 - centerDist / w, 0, 1) * 2;
        noisePattern = noisePattern * falloff2;
        imData.data[i] = 0;
        imData.data[i + 1] = 0;
        imData.data[i + 2] = 0;
        imData.data[i + 3] = (0, _bb.BB).clamp(noisePattern, 0, 255);
    }
    ctx.putImageData(imData, 0, 0);
    return canvas;
}
// https://www.shadertoy.com/view/3tdSDj
function udSegment(p, a, b) {
    let ba = (0, _bb.BB).Vec2.sub(b, a);
    let pa = (0, _bb.BB).Vec2.sub(p, a);
    let h = (0, _bb.BB).clamp((0, _bb.BB).Vec2.dot(pa, ba) / (0, _bb.BB).Vec2.dot(ba, ba), 0.0, 1.0);
    return (0, _bb.BB).Vec2.len((0, _bb.BB).Vec2.sub(pa, (0, _bb.BB).Vec2.mul(ba, h)));
}
function genBrushAlpha02(w) {
    const pDist = 0.25;
    let centerSize = 2 / 3;
    let transitionSize = 1 / 3;
    centerSize *= pDist;
    transitionSize *= pDist;
    const p1 = {
        x: pDist * w,
        y: w - w * pDist
    };
    const p2 = {
        x: w - w * pDist,
        y: pDist * w
    };
    const h = w;
    const canvas = (0, _bb.BB).canvas(w, h);
    let ctx = canvas.getContext("2d");
    const imData = ctx.createImageData(w, h);
    for(let x = 0; x < w; x++)for(let y = 0; y < h; y++){
        const i = (y * w + x) * 4;
        let col = udSegment({
            x: x,
            y: y
        }, p1, p2);
        col = (0, _bb.BB).clamp(255 - (col - w * centerSize) / (w * transitionSize) * 255, 0, 255);
        imData.data[i] = 0;
        imData.data[i + 1] = 0;
        imData.data[i + 2] = 0;
        imData.data[i + 3] = col;
    }
    ctx.putImageData(imData, 0, 0);
    return canvas;
}

},{"../../../bb/bb":"dcQKo","../../../bb/math/perlin":"9Bu1q","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9Bu1q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "noise", ()=>noise);
/*
 * A speed-improved perlin and simplex noise algorithms for 2D.
 *
 * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
 * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
 * Better rank ordering method by Stefan Gustavson in 2012.
 * Converted to Javascript by Joseph Gentle.
 *
 * Version 2012-03-09
 *
 * This code was placed in the public domain by its original author,
 * Stefan Gustavson. You may use it as you see fit, but
 * attribution is appreciated.
 *
 */ const myModule = {};
function Grad(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
}
Grad.prototype.dot2 = function(x, y) {
    return this.x * x + this.y * y;
};
/*
Grad.prototype.dot3 = function(x, y, z) {
    return this.x*x + this.y*y + this.z*z;
};*/ let grad3 = [
    new Grad(1, 1, 0),
    new Grad(-1, 1, 0),
    new Grad(1, -1, 0),
    new Grad(-1, -1, 0),
    new Grad(1, 0, 1),
    new Grad(-1, 0, 1),
    new Grad(1, 0, -1),
    new Grad(-1, 0, -1),
    new Grad(0, 1, 1),
    new Grad(0, -1, 1),
    new Grad(0, 1, -1),
    new Grad(0, -1, -1)
];
let p = [
    151,
    160,
    137,
    91,
    90,
    15,
    131,
    13,
    201,
    95,
    96,
    53,
    194,
    233,
    7,
    225,
    140,
    36,
    103,
    30,
    69,
    142,
    8,
    99,
    37,
    240,
    21,
    10,
    23,
    190,
    6,
    148,
    247,
    120,
    234,
    75,
    0,
    26,
    197,
    62,
    94,
    252,
    219,
    203,
    117,
    35,
    11,
    32,
    57,
    177,
    33,
    88,
    237,
    149,
    56,
    87,
    174,
    20,
    125,
    136,
    171,
    168,
    68,
    175,
    74,
    165,
    71,
    134,
    139,
    48,
    27,
    166,
    77,
    146,
    158,
    231,
    83,
    111,
    229,
    122,
    60,
    211,
    133,
    230,
    220,
    105,
    92,
    41,
    55,
    46,
    245,
    40,
    244,
    102,
    143,
    54,
    65,
    25,
    63,
    161,
    1,
    216,
    80,
    73,
    209,
    76,
    132,
    187,
    208,
    89,
    18,
    169,
    200,
    196,
    135,
    130,
    116,
    188,
    159,
    86,
    164,
    100,
    109,
    198,
    173,
    186,
    3,
    64,
    52,
    217,
    226,
    250,
    124,
    123,
    5,
    202,
    38,
    147,
    118,
    126,
    255,
    82,
    85,
    212,
    207,
    206,
    59,
    227,
    47,
    16,
    58,
    17,
    182,
    189,
    28,
    42,
    223,
    183,
    170,
    213,
    119,
    248,
    152,
    2,
    44,
    154,
    163,
    70,
    221,
    153,
    101,
    155,
    167,
    43,
    172,
    9,
    129,
    22,
    39,
    253,
    19,
    98,
    108,
    110,
    79,
    113,
    224,
    232,
    178,
    185,
    112,
    104,
    218,
    246,
    97,
    228,
    251,
    34,
    242,
    193,
    238,
    210,
    144,
    12,
    191,
    179,
    162,
    241,
    81,
    51,
    145,
    235,
    249,
    14,
    239,
    107,
    49,
    192,
    214,
    31,
    181,
    199,
    106,
    157,
    184,
    84,
    204,
    176,
    115,
    121,
    50,
    45,
    127,
    4,
    150,
    254,
    138,
    236,
    205,
    93,
    222,
    114,
    67,
    29,
    24,
    72,
    243,
    141,
    128,
    195,
    78,
    66,
    215,
    61,
    156,
    180
];
// To remove the need for index wrapping, double the permutation table length
let perm = new Array(512);
let gradP = new Array(512);
// This isn't a very good seeding function, but it works ok. It supports 2^16
// different seed values. Write something better if you need more seeds.
myModule.seed = function(seed) {
    if (seed > 0 && seed < 1) // Scale the seed out
    seed *= 65536;
    seed = Math.floor(seed);
    if (seed < 256) seed |= seed << 8;
    for(let i = 0; i < 256; i++){
        let v;
        if (i & 1) v = p[i] ^ seed & 255;
        else v = p[i] ^ seed >> 8 & 255;
        perm[i] = perm[i + 256] = v;
        gradP[i] = gradP[i + 256] = grad3[v % 12];
    }
};
myModule.seed(0);
/*
for (let i=0; i<256; i++) {
  perm[i] = perm[i + 256] = p[i];
  gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];
}*/ // Skewing and unskewing factors for 2, 3, and 4 dimensions
let F2 = 0.5 * (Math.sqrt(3) - 1);
let G2 = (3 - Math.sqrt(3)) / 6;
/*let F3 = 1/3;
let G3 = 1/6;*/ // 2D simplex noise
myModule.simplex2 = function(xin, yin) {
    let n0, n1, n2; // Noise contributions from the three corners
    // Skew the input space to determine which simplex cell we're in
    let s = (xin + yin) * F2; // Hairy factor for 2D
    let i = Math.floor(xin + s);
    let j = Math.floor(yin + s);
    let t = (i + j) * G2;
    let x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.
    let y0 = yin - j + t;
    // For the 2D case, the simplex shape is an equilateral triangle.
    // Determine which simplex we are in.
    let i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
    if (x0 > y0) {
        i1 = 1;
        j1 = 0;
    } else {
        i1 = 0;
        j1 = 1;
    }
    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
    // c = (3-sqrt(3))/6
    let x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
    let y1 = y0 - j1 + G2;
    let x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords
    let y2 = y0 - 1 + 2 * G2;
    // Work out the hashed gradient indices of the three simplex corners
    i &= 255;
    j &= 255;
    let gi0 = gradP[i + perm[j]];
    let gi1 = gradP[i + i1 + perm[j + j1]];
    let gi2 = gradP[i + 1 + perm[j + 1]];
    // Calculate the contribution from the three corners
    let t0 = 0.5 - x0 * x0 - y0 * y0;
    if (t0 < 0) n0 = 0;
    else {
        t0 *= t0;
        n0 = t0 * t0 * gi0.dot2(x0, y0); // (x,y) of grad3 used for 2D gradient
    }
    let t1 = 0.5 - x1 * x1 - y1 * y1;
    if (t1 < 0) n1 = 0;
    else {
        t1 *= t1;
        n1 = t1 * t1 * gi1.dot2(x1, y1);
    }
    let t2 = 0.5 - x2 * x2 - y2 * y2;
    if (t2 < 0) n2 = 0;
    else {
        t2 *= t2;
        n2 = t2 * t2 * gi2.dot2(x2, y2);
    }
    // Add contributions from each corner to get the final noise value.
    // The result is scaled to return values in the interval [-1,1].
    return 70 * (n0 + n1 + n2);
};
const noise = myModule;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1OcHF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BlendBrush", ()=>BlendBrush);
var _bb = require("../../bb/bb");
const cellSize = 256;
// faster than using BB.clamp somehow (in chrome)
function clamp(num, min, max) {
    return num <= min ? min : num >= max ? max : num;
}
class BlendBrush {
    isTesting = false;
    size = 29;
    opacity = 0.6;
    blending = 0.65;
    settingLockLayerAlpha = false;
    settingSizePressure = true;
    settingOpacityPressure = false;
    blendCol = {
        r: 0,
        g: 0,
        b: 0,
        a: 1
    };
    blendMix = 0.45;
    isDrawing = false;
    lastInput = {
        x: 0,
        y: 0,
        pressure: 0
    };
    lastInput2 = {
        x: 0,
        y: 0,
        pressure: 0
    };
    updateRedrawBounds(bounds) {
        this.redrawBounds = (0, _bb.BB).updateBounds(this.redrawBounds, bounds);
    }
    getCellsWidth() {
        return Math.ceil(this.context.canvas.width / cellSize);
    }
    /**
     * draw changed cells (changed by brushstroke) onto context
     * @private
     */ drawChangedCells() {
        const cells = this.cells.map((item)=>null);
        const touchedCells = this.getTouchedCells(this.redrawBounds);
        touchedCells.forEach((isTouched, index)=>{
            if (isTouched) cells[index] = this.cells[index];
        });
        this.drawCells(cells);
        this.redrawBounds = null;
    }
    getTouchedCells(bounds) {
        const touchedCells = this.cells.map((item)=>false);
        const cellsW = this.getCellsWidth();
        bounds = {
            x1: Math.floor(bounds.x1 / cellSize),
            y1: Math.floor(bounds.y1 / cellSize),
            x2: Math.floor(bounds.x2 / cellSize),
            y2: Math.floor(bounds.y2 / cellSize)
        };
        for(let i = bounds.x1; i <= bounds.x2; i++)for(let e = bounds.y1; e <= bounds.y2; e++)touchedCells[e * cellsW + i] = true;
        return touchedCells;
    }
    /**
     * Slice up bounds accordings to cells
     * @param bounds
     * @private
     */ sliceBounds(bounds) {
        const cellsW = this.getCellsWidth();
        const result = [];
        const touchedCells = this.getTouchedCells(bounds);
        touchedCells.forEach((cell, i)=>{
            if (!cell) return;
            const cellOffsetX = i % cellsW * cellSize;
            const cellOffsetY = Math.floor(i / cellsW) * cellSize;
            const cellWidth = this.cells[i].width;
            const cellHeight = this.cells[i].height;
            const inCellBounds = {
                x1: Math.max(0, bounds.x1 - cellOffsetX),
                y1: Math.max(0, bounds.y1 - cellOffsetY),
                x2: Math.min(cellWidth - 1, bounds.x2 - cellOffsetX),
                y2: Math.min(cellHeight - 1, bounds.y2 - cellOffsetY)
            };
            if (inCellBounds.x1 > inCellBounds.x2 || inCellBounds.y1 > inCellBounds.y2) return;
            result.push({
                index: i,
                bounds: inCellBounds
            });
        });
        return result;
    }
    /**
     * update copyImageData. copy over new regions if needed
     */ copyFromCanvas(bounds) {
        if (!bounds) return;
        const touchedCells = this.getTouchedCells(bounds);
        const cellsW = this.getCellsWidth();
        touchedCells.forEach((item, i)=>{
            if (!item || this.cells[i]) // not touched, or already copied
            return;
            const x = i % cellsW;
            const y = Math.floor(i / cellsW);
            const w = (Math.min(x * cellSize + cellSize, this.context.canvas.width) - 1) % cellSize + 1;
            const h = (Math.min(y * cellSize + cellSize, this.context.canvas.height) - 1) % cellSize + 1;
            // temp canvas to prevent main canvas from getting slowed down in chrome
            const tmpCanvas = (0, _bb.BB).canvas(w, h);
            const tmpCtx = tmpCanvas.getContext("2d");
            tmpCtx.drawImage(this.context.canvas, -x * cellSize, -y * cellSize);
            this.cells[i] = tmpCtx.getImageData(0, 0, w, h);
        });
    }
    getAverage(x, y, size) {
        size = Math.max(0.5, size * 0.75);
        const x1 = Math.max(0, Math.floor(x - size));
        const y1 = Math.max(0, Math.floor(y - size));
        const x2 = Math.min(this.context.canvas.width - 1, Math.ceil(x + size));
        const y2 = Math.min(this.context.canvas.height - 1, Math.ceil(y + size));
        if (x1 > x2 || y1 > y2) return {
            r: 0,
            g: 0,
            b: 0,
            a: 0
        };
        let ar = 0, ag = 0, ab = 0, aa = 0, alpha;
        const slicedBounds = this.sliceBounds({
            x1,
            y1,
            x2,
            y2
        });
        slicedBounds.forEach((slice)=>{
            const width = this.cells[slice.index].width;
            const data = this.cells[slice.index].data;
            const bounds = slice.bounds;
            for(let i = bounds.y1; i <= bounds.y2; i += 4)for(let e = bounds.x1, e2 = i * width * 4 + bounds.x1 * 4; e <= bounds.x2; e += 4, e2 += 16){
                alpha = data[e2 + 3];
                ar += data[e2] * alpha;
                ag += data[e2 + 1] * alpha;
                ab += data[e2 + 2] * alpha;
                aa += alpha;
            }
        });
        if (aa !== 0) {
            ar /= aa;
            ag /= aa;
            ab /= aa;
            aa = Math.min(1, aa);
        }
        return {
            r: ar,
            g: ag,
            b: ab,
            a: aa
        };
    }
    prepDot(x, y, size) {
        size = Math.max(0.5, size);
        let x1 = Math.max(0, Math.floor(x - size));
        let y1 = Math.max(0, Math.floor(y - size));
        let x2 = Math.min(this.context.canvas.width - 1, Math.ceil(x + size));
        let y2 = Math.min(this.context.canvas.height - 1, Math.ceil(y + size));
        if (x1 > x2 || y1 > y2) return null;
        return {
            x1,
            y1,
            x2,
            y2
        };
    }
    drawDot(params) {
        // array with random numbers. faster than Math.random()
        let randI = 0;
        const randLen = params.size > 30 ? 1024 : 512; // lower lengths lead to noticeable patterns
        const randArr = [];
        for(let i = 0; i < randLen; i++)randArr[i] = (Math.random() - 0.5) / 1.001 + 0.5;
        // thin lines take more than just 1 sample
        const sampleArr = [
            8,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2
        ]; // <0.5, 0.5, 1, 1.5, etc.
        const samples = sampleArr[Math.floor(params.size * 2)];
        const samplesSquared = samples ? samples * samples : 0;
        const sampleOffsets = [];
        if (samples) {
            let i1 = 0;
            for(let n = 0; n < samples; n++)for(let m = 0; m < samples; m++, i1 += 2){
                sampleOffsets[i1] = (n + 1) / samples; // x offset
                sampleOffsets[i1 + 1] = (m + 1) / samples; // y offset
            }
        }
        const sharpness = Math.pow(params.opacity, 2) * 0.8;
        // to optimize calculations
        const invSharpness = 1 - sharpness;
        const sharpnessSubtrahend = sharpness / invSharpness;
        const sizeSquared = params.size * params.size;
        const distDivisor = sizeSquared * invSharpness / params.opacity;
        const alphaMinuend = (1 + sharpnessSubtrahend) * params.opacity;
        const slicedBounds = this.sliceBounds({
            x1: params.x1,
            y1: params.y1,
            x2: params.x2,
            y2: params.y2
        });
        const cellsW = this.getCellsWidth();
        slicedBounds.forEach((slice)=>{
            const cellOffsetX = slice.index % cellsW * cellSize;
            const cellOffsetY = Math.floor(slice.index / cellsW) * cellSize;
            const cellWidth = this.cells[slice.index].width;
            const data = this.cells[slice.index].data;
            // i - y index within cell
            // e - x index within cell
            // e2 - index in image data
            // ri - y index within image relative to dot-center
            // re - x index within image relative to dot-center
            for(let i = slice.bounds.y1, ri = i + cellOffsetY - params.y; i <= slice.bounds.y2; i++, ri++)for(let e = slice.bounds.x1, e2 = i * cellWidth * 4 + slice.bounds.x1 * 4, re = e + cellOffsetX - params.x; e <= slice.bounds.x2; e++, e2 += 4, re++){
                // O = over -> brush-dot
                // U = under -> image
                let alphaO = 0;
                if (samplesSquared) {
                    for(let f = 0; f < sampleOffsets.length; f += 2){
                        const dist = (0, _bb.BB).lenSquared(re + sampleOffsets[f], ri + sampleOffsets[f + 1]);
                        if (dist >= sizeSquared) continue;
                        alphaO += clamp(alphaMinuend - dist / distDivisor, 0, params.opacity);
                    }
                    if (!alphaO) continue;
                    alphaO /= samplesSquared;
                } else {
                    // technically needs + 0.5 offset, but not noticeable with large brush
                    const dist1 = Math.pow(re, 2) + Math.pow(ri, 2);
                    if (dist1 >= sizeSquared) continue;
                    alphaO = clamp(alphaMinuend - dist1 / distDivisor, 0, params.opacity);
                }
                const invAlphaO = 1 - alphaO;
                const alphaU = data[e2 + 3] / 255;
                if (this.settingLockLayerAlpha) {
                    const underR = params.r * alphaO + data[e2] * invAlphaO;
                    const underG = params.g * alphaO + data[e2 + 1] * invAlphaO;
                    const underB = params.b * alphaO + data[e2 + 2] * invAlphaO;
                    if (alphaU) {
                        data[e2] = Math.floor(underR + randArr[randI]);
                        data[e2 + 1] = Math.floor(underG + randArr[randI]);
                        data[e2 + 2] = Math.floor(underB + randArr[randI]);
                    }
                } else {
                    const underR1 = params.r * alphaO + data[e2] * alphaU * invAlphaO;
                    const underG1 = params.g * alphaO + data[e2 + 1] * alphaU * invAlphaO;
                    const underB1 = params.b * alphaO + data[e2 + 2] * alphaU * invAlphaO;
                    let newAlpha = 1 - invAlphaO * (1 - alphaU);
                    data[e2 + 3] = Math.floor(Math.min(255, newAlpha * 255) + 0.5);
                    if (newAlpha) {
                        data[e2] = Math.floor(underR1 / newAlpha + randArr[randI]);
                        data[e2 + 1] = Math.floor(underG1 / newAlpha + randArr[randI]);
                        data[e2 + 2] = Math.floor(underB1 / newAlpha + randArr[randI]);
                    }
                }
                randI = (randI + 1) % randLen;
            }
        });
    }
    calcSpacing(size) {
        return (0, _bb.BB).mix(size * 2 / 2, size * 2 / 9, (0, _bb.BB).clamp((size - 2.7) / 9.3, 0, 1));
    }
    continueLine(x, y, p, isCoalesced) {
        this.drawBuffer = [];
        let localPressure;
        let localOpacity;
        let localSize = this.settingSizePressure ? Math.max(1, p * this.size) : Math.max(1, this.size);
        let bdist = this.calcSpacing(localSize);
        let avgX = x;
        let avgY = y;
        if (x === null) {
            avgX = this.lastInput.x;
            avgY = this.lastInput.y;
        }
        let localColNew;
        if (this.blending === 0) {
            this.mixr = this.color.r;
            this.mixg = this.color.g;
            this.mixb = this.color.b;
        } else {
            let average;
            if (isCoalesced) average = {
                r: this.localColOld.r,
                g: this.localColOld.g,
                b: this.localColOld.b,
                a: 0
            };
            else {
                const avgParams = [
                    avgX,
                    avgY,
                    this.settingSizePressure ? Math.max(0.5, p * this.size) : Math.max(0.5, this.size)
                ];
                const bounds = this.prepDot(avgParams[0], avgParams[1], avgParams[2]);
                this.copyFromCanvas(bounds);
                average = this.getAverage(avgParams[0], avgParams[1], avgParams[2]);
            }
            localColNew = {
                r: 0,
                g: 0,
                b: 0,
                a: 0
            };
            if (average.a > 0 && this.blendCol.a === 0) {
                this.blendCol.r = average.r;
                this.blendCol.g = average.g;
                this.blendCol.b = average.b;
                this.blendCol.a = average.a;
                localColNew.r = this.blendCol.r;
                localColNew.g = this.blendCol.g;
                localColNew.b = this.blendCol.b;
                localColNew.a = this.blendCol.a;
            } else {
                if (average.a === 0) {
                    average.r = this.color.r;
                    average.g = this.color.g;
                    average.b = this.color.b;
                    average.a = 1 - this.blending;
                }
                this.blendCol.r = (0, _bb.BB).mix(this.blendCol.r, (0, _bb.BB).mix(this.blendCol.r, average.r, this.blendMix), average.a);
                this.blendCol.g = (0, _bb.BB).mix(this.blendCol.g, (0, _bb.BB).mix(this.blendCol.g, average.g, this.blendMix), average.a);
                this.blendCol.b = (0, _bb.BB).mix(this.blendCol.b, (0, _bb.BB).mix(this.blendCol.b, average.b, this.blendMix), average.a);
                this.blendCol.a = Math.min(1, this.blendCol.a + average.a);
                localColNew.r = this.blendCol.r;
                localColNew.g = this.blendCol.g;
                localColNew.b = this.blendCol.b;
                localColNew.a = this.blendCol.a;
            }
        }
        const bezierCallback = (val)=>{
            if (this.blending >= 1 && this.blendCol.a <= 0) return;
            let factor = val.t;
            localPressure = this.lastInput2.pressure * (1 - factor) + p * factor;
            localOpacity = this.settingOpacityPressure ? this.opacity * localPressure * localPressure : this.opacity;
            localSize = this.settingSizePressure ? Math.max(0.1, localPressure * this.size) : Math.max(0.1, this.size);
            if (this.blending != 0) {
                this.mixr = (0, _bb.BB).mix(this.localColOld.r, localColNew.r, factor);
                this.mixg = (0, _bb.BB).mix(this.localColOld.g, localColNew.g, factor);
                this.mixb = (0, _bb.BB).mix(this.localColOld.b, localColNew.b, factor);
            }
            if (this.blending === 1 && this.localColOld.a === 0) {
                this.mixr = localColNew.r;
                this.mixg = localColNew.g;
                this.mixb = localColNew.b;
            }
            const bounds = this.prepDot(val.x, val.y, localSize);
            if (bounds) {
                this.updateRedrawBounds(bounds);
                this.drawBuffer.push({
                    x: val.x,
                    y: val.y,
                    size: localSize,
                    opacity: localOpacity,
                    x1: bounds.x1,
                    y1: bounds.y1,
                    x2: bounds.x2,
                    y2: bounds.y2,
                    r: (0, _bb.BB).mix(this.color.r, this.mixr, this.blending),
                    g: (0, _bb.BB).mix(this.color.g, this.mixg, this.blending),
                    b: (0, _bb.BB).mix(this.color.b, this.mixb, this.blending)
                });
            }
        };
        if (x === null) this.bezierLine.addFinal(bdist, bezierCallback);
        else this.bezierLine.add(x, y, bdist, bezierCallback);
        this.copyFromCanvas(this.redrawBounds);
        this.drawBuffer.forEach((item)=>{
            this.drawDot(item);
        });
        this.drawBuffer = [];
        this.localColOld = localColNew;
    }
    // --- public ----
    constructor(){}
    setHistory(h) {
        this.history = h;
    }
    getSize() {
        return this.size;
    }
    setSize(s) {
        this.size = s;
    }
    getOpacity() {
        return this.opacity;
    }
    setOpacity(o) {
        this.opacity = o;
    }
    getBlending() {
        return this.blending;
    }
    setBlending(b) {
        this.blending = b;
    }
    setColor(c) {
        this.color = (0, _bb.BB).copyObj(c);
    }
    setContext(c) {
        this.context = c;
    }
    setSizePressure(b) {
        this.settingSizePressure = !!b;
    }
    setOpacityPressure(b) {
        this.settingOpacityPressure = !!b;
    }
    getLockAlpha() {
        return this.settingLockLayerAlpha;
    }
    setLockAlpha(b) {
        this.settingLockLayerAlpha = !!b;
    }
    getIsDrawing() {
        return this.isDrawing;
    }
    setIsTesting(b) {
        this.isTesting = !!b;
    }
    startLine(x, y, p) {
        this.historyEntry = {
            tool: [
                "brush",
                "BlendBrush"
            ],
            actions: []
        };
        const totalCells = Math.ceil(this.context.canvas.width / cellSize) * Math.ceil(this.context.canvas.height / cellSize);
        this.cells = "0".repeat(totalCells).split("").map((item)=>null);
        this.isDrawing = true;
        p = Math.max(0, Math.min(1, p));
        let localOpacity = this.settingOpacityPressure ? this.opacity * p * p : this.opacity;
        let localSize = this.settingSizePressure ? Math.max(0.1, p * this.size) : Math.max(0.1, this.size);
        if (this.blending === 0) {
            this.mixr = this.color.r;
            this.mixg = this.color.g;
            this.mixb = this.color.b;
        } else {
            this.copyFromCanvas(this.prepDot(x, y, localSize));
            let average = this.getAverage(x, y, this.settingSizePressure ? Math.max(0.1, p * this.size) : Math.max(0.1, this.size));
            if (average.a === 0) this.blendCol = {
                r: this.color.r,
                g: this.color.g,
                b: this.color.b,
                a: 1 - this.blending
            };
            else this.blendCol = {
                r: average.r,
                g: average.g,
                b: average.b,
                a: average.a
            };
            this.mixr = this.blendCol.r;
            this.mixg = this.blendCol.g;
            this.mixb = this.blendCol.b;
        }
        this.localColOld = {
            r: this.mixr,
            g: this.mixg,
            b: this.mixb,
            a: this.blendCol.a
        };
        this.redrawBounds = null;
        this.drawBuffer = [];
        if (this.blending < 1 || this.blendCol.a > 0) {
            const bounds = this.prepDot(x, y, localSize);
            if (bounds) {
                this.updateRedrawBounds(bounds);
                this.drawBuffer.push({
                    x: x,
                    y: y,
                    size: localSize,
                    opacity: localOpacity,
                    x1: bounds.x1,
                    y1: bounds.y1,
                    x2: bounds.x2,
                    y2: bounds.y2,
                    r: (0, _bb.BB).mix(this.color.r, this.mixr, this.blending),
                    g: (0, _bb.BB).mix(this.color.g, this.mixg, this.blending),
                    b: (0, _bb.BB).mix(this.color.b, this.mixb, this.blending)
                });
            }
        }
        this.copyFromCanvas(this.redrawBounds);
        this.drawBuffer.forEach((item)=>{
            this.drawDot(item);
        });
        this.drawBuffer = [];
        this.bezierLine = new (0, _bb.BB).BezierLine();
        this.bezierLine.add(x, y, 0, function() {});
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.lastInput.pressure = p;
        this.lastInput2 = (0, _bb.BB).copyObj(this.lastInput);
        if (this.redrawBounds && !this.isTesting) this.drawChangedCells();
    }
    goLine(x, y, p, isCoalesced) {
        if (!this.isDrawing) return;
        this.continueLine(x, y, this.lastInput.pressure, isCoalesced);
        this.lastInput2 = (0, _bb.BB).copyObj(this.lastInput);
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.lastInput.pressure = p;
        if (this.redrawBounds && !this.isTesting) this.drawChangedCells();
    }
    endLine() {
        if (this.bezierLine) this.continueLine(null, null, this.lastInput.pressure, false);
        this.isDrawing = false;
        this.bezierLine = null;
        if (this.redrawBounds) this.drawChangedCells();
        if (this.historyEntry && this.history && this.cells.find((item)=>!!item)) {
            this.historyEntry.actions.push({
                action: "drawCells",
                params: [
                    this.cells
                ]
            });
            this.history.push(this.historyEntry);
            this.historyEntry = null;
        }
        this.cells = null;
    }
    /**
     * draw cells onto context
     * @param cells
     */ drawCells(cells) {
        const cellsW = this.getCellsWidth();
        cells.forEach((imageData, index)=>{
            if (!imageData) return;
            const cellOffsetX = index % cellsW * cellSize;
            const cellOffsetY = Math.floor(index / cellsW) * cellSize;
            this.context.putImageData(imageData, cellOffsetX, cellOffsetY);
        });
    }
    drawLineSegment(x1, y1, x2, y2) {
        this.lastInput.x = x2;
        this.lastInput.y = y2;
        if (this.isDrawing || x1 === undefined) return;
        const totalCells = Math.ceil(this.context.canvas.width / cellSize) * Math.ceil(this.context.canvas.height / cellSize);
        this.cells = "0".repeat(totalCells).split("").map((item)=>null);
        this.redrawBounds = null;
        this.drawBuffer = [];
        this.copyFromCanvas(this.prepDot(x1, y1, Math.max(0.1, this.size)));
        let average = this.getAverage(x1, y1, Math.max(0.1, this.size));
        if (average.a === 0) this.blendCol = {
            r: this.color.r,
            g: this.color.g,
            b: this.color.b,
            a: 1 - this.blending
        };
        else this.blendCol = {
            r: average.r,
            g: average.g,
            b: average.b,
            a: average.a
        };
        this.mixr = this.color.r * (1 - this.blendCol.a) + (this.blending * this.blendCol.r + this.color.r * (1 - this.blending)) * this.blendCol.a;
        this.mixg = this.color.g * (1 - this.blendCol.a) + (this.blending * this.blendCol.g + this.color.g * (1 - this.blending)) * this.blendCol.a;
        this.mixb = this.color.b * (1 - this.blendCol.a) + (this.blending * this.blendCol.b + this.color.b * (1 - this.blending)) * this.blendCol.a;
        const p = 1;
        const localOpacity = this.settingOpacityPressure ? this.opacity * p * p : this.opacity;
        const localSize = this.settingSizePressure ? Math.max(0.1, p * this.size) : Math.max(0.1, this.size);
        const mouseDist = Math.sqrt(Math.pow(x2 - x1, 2.0) + Math.pow(y2 - y1, 2.0));
        const eX = (x2 - x1) / mouseDist;
        const eY = (y2 - y1) / mouseDist;
        const bdist = this.calcSpacing(localSize);
        for(let loopDist = 0; loopDist <= mouseDist; loopDist += bdist){
            const bounds = this.prepDot(x1 + eX * loopDist, y1 + eY * loopDist, localSize);
            if (bounds) {
                this.copyFromCanvas(bounds);
                this.drawBuffer.push({
                    x: x1 + eX * loopDist,
                    y: y1 + eY * loopDist,
                    size: localSize,
                    opacity: localOpacity,
                    x1: bounds.x1,
                    y1: bounds.y1,
                    x2: bounds.x2,
                    y2: bounds.y2,
                    r: (0, _bb.BB).mix(this.color.r, this.mixr, this.blending),
                    g: (0, _bb.BB).mix(this.color.g, this.mixg, this.blending),
                    b: (0, _bb.BB).mix(this.color.b, this.mixb, this.blending)
                });
            }
        }
        this.drawBuffer.forEach((item)=>{
            this.drawDot(item);
        });
        this.drawBuffer = [];
        if (this.history && this.cells.find((item)=>!!item)) {
            this.drawCells(this.cells);
            this.historyEntry = {
                tool: [
                    "brush",
                    "BlendBrush"
                ],
                actions: [
                    {
                        action: "drawCells",
                        params: [
                            this.cells
                        ]
                    }
                ]
            };
            this.history.push(this.historyEntry);
            this.historyEntry = null;
        }
        this.cells = null;
    }
}

},{"../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"goQ9y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SketchyBrush", ()=>SketchyBrush);
var _bb = require("../../bb/bb");
var _kl = require("../kl");
const sampleCanvas = (0, _bb.BB).canvas(32, 32);
const sampleCtx = sampleCanvas.getContext("2d");
function SketchyBrush() {
    let context;
    let settingColor;
    let settingSize = 1, settingOpacity = 0.2;
    let settingBlending = 0.5;
    let settingScale = 1;
    let lastX, lastY;
    let isDrawing = false;
    let lastInput = {
        x: 0,
        y: 0,
        pressure: 0
    };
    let history = new (0, _kl.KL).DecoyKlHistory();
    let historyEntry;
    let sketchySeed = 0;
    this.setHistory = function(l) {
        history = l;
    };
    this.setSeed = function(s) {
        sketchySeed = parseInt(s);
    };
    this.getSeed = function() {
        return parseInt("" + sketchySeed);
    };
    function rand() {
        sketchySeed++;
        return Math.sin(6324634.2345 * Math.cos(sketchySeed * 5342.3423)) * 0.5 + 0.5;
    }
    let points = [];
    let count = 0;
    let mixmode = [
        function(c1, c2) {
            return c1;
        },
        function(c1, c2) {
            let result = new (0, _bb.BB).RGB(c1.r, c1.g, c1.b);
            result.r *= c2.r / 255;
            result.g *= c2.g / 255;
            result.b *= c2.b / 255;
            return result;
        },
        function(c1, c2) {
            let result = new (0, _bb.BB).RGB(c1.r, c1.g, c1.b);
            result.r *= c2.r / 255;
            result.g *= c2.g / 255;
            result.b *= c2.b / 255;
            return result;
        }
    ];
    this.getSize = function() {
        return settingSize / 2;
    };
    this.setColor = function(c) {
        settingColor = c;
    };
    this.getOpacity = function() {
        return settingOpacity;
    };
    this.setOpacity = function(o) {
        settingOpacity = o;
    };
    this.getBlending = function() {
        return settingBlending;
    };
    this.setBlending = function(b) {
        settingBlending = b;
    };
    this.setSize = function(s) {
        settingSize = s * 2;
    };
    this.getScale = function() {
        return settingScale;
    };
    this.setScale = function(s) {
        settingScale = s;
    };
    this.setContext = function(c) {
        context = c;
    };
    this.startLine = function(x, y, pressure, shift) {
        if (shift && lastInput.x) {
            let lx = lastInput.x, ly = lastInput.y;
            isDrawing = true;
            //this.goLine(x,y,pressure);
            this.endLine();
        } else {
            isDrawing = true;
            lastX = x;
            lastY = y;
            lastInput.x = x;
            lastInput.y = y;
            historyEntry = {
                tool: [
                    "brush",
                    "SketchyBrush"
                ],
                actions: []
            };
            historyEntry.actions.push({
                action: "setScale",
                params: [
                    settingScale
                ]
            });
            historyEntry.actions.push({
                action: "setSize",
                params: [
                    settingSize / 2
                ]
            });
            historyEntry.actions.push({
                action: "setOpacity",
                params: [
                    settingOpacity
                ]
            });
            historyEntry.actions.push({
                action: "setColor",
                params: [
                    settingColor
                ]
            });
            historyEntry.actions.push({
                action: "setBlending",
                params: [
                    settingBlending
                ]
            });
            historyEntry.actions.push({
                action: "startLine",
                params: [
                    x,
                    y,
                    pressure
                ]
            });
        }
    };
    this.goLine = function(p_x, p_y, pressure, preMixedColor) {
        if (!isDrawing || p_x === lastInput.x && p_y === lastInput.y) return;
        let e, b, a, g;
        let x = parseInt(p_x);
        let y = parseInt(p_y);
        points.push([
            x,
            y
        ]);
        let mixr = settingColor.r;
        let mixg = settingColor.g;
        let mixb = settingColor.b;
        if (preMixedColor !== null) {
            mixr = preMixedColor.r;
            mixg = preMixedColor.g;
            mixb = preMixedColor.b;
        } else {
            if (settingBlending !== 0) {
                if (x + 5 >= 0 && y + 5 >= 0 && x - 5 < context.canvas.width - 1 && y - 5 < context.canvas.height - 1) {
                    mixr = 0;
                    mixg = 0;
                    mixb = 0;
                    let mixx = Math.min(context.canvas.width - 1, Math.max(0, x - 5));
                    let mixy = Math.min(context.canvas.height - 1, Math.max(0, y - 5));
                    let mixw = Math.min(context.canvas.width - 1, Math.max(0, x + 5));
                    let mixh = Math.min(context.canvas.height - 1, Math.max(0, y + 5));
                    mixw -= mixx;
                    mixh -= mixy;
                    if (mixw > 0 && mixh > 0) {
                        let imdat = context.getImageData(mixx, mixy, mixw, mixh);
                        let countmix = 0;
                        for(let i = 0; i < imdat.data.length; i += 4){
                            mixr += imdat.data[i + 0];
                            mixg += imdat.data[i + 1];
                            mixb += imdat.data[i + 2];
                            countmix++;
                        }
                        mixr /= countmix;
                        mixg /= countmix;
                        mixb /= countmix;
                    }
                    let mixed = mixmode[0](new (0, _bb.BB).RGB(mixr, mixg, mixb), settingColor);
                    mixr = parseInt("" + (0, _bb.BB).mix(settingColor.r, mixed.r, settingBlending));
                    mixg = parseInt("" + (0, _bb.BB).mix(settingColor.g, mixed.g, settingBlending));
                    mixb = parseInt("" + (0, _bb.BB).mix(settingColor.b, mixed.b, settingBlending));
                }
            }
        }
        context.save();
        context.strokeStyle = "rgba(" + mixr + ", " + mixg + ", " + mixb + ", " + settingOpacity + ")";
        context.lineWidth = settingSize;
        context.beginPath();
        context.moveTo(lastX, lastY);
        context.lineTo(x, y);
        for(e = 0; e < points.length; e++){
            b = points[e][0] - points[count][0];
            a = points[e][1] - points[count][1];
            g = b * b + a * a;
            if (g < 4000 * settingScale * settingScale && rand() > g / 2000 / settingScale / settingScale) {
                context.moveTo(points[count][0] + b * 0.3, points[count][1] + a * 0.3);
                context.lineTo(points[e][0] - b * 0.3, points[e][1] - a * 0.3);
            }
        }
        context.stroke();
        context.restore();
        count++;
        lastX = x;
        lastY = y;
        lastInput.x = x;
        lastInput.y = y;
        historyEntry.actions.push({
            action: "goLine",
            params: [
                p_x,
                p_y,
                pressure,
                {
                    r: mixr,
                    g: mixg,
                    b: mixb
                }
            ]
        });
    };
    this.endLine = function() {
        isDrawing = false;
        count = 0;
        points = [];
        if (historyEntry) {
            historyEntry.actions.push({
                action: "endLine",
                params: []
            });
            history.push(historyEntry);
            historyEntry = undefined;
        }
    };
    //cheap n' ugly
    this.drawLineSegment = function(x1, y1, x2, y2) {
        lastInput.x = x2;
        lastInput.y = y2;
        if (isDrawing || x1 === undefined) return;
        context.save();
        context.lineWidth = settingSize;
        let mixr = settingColor.r, mixg = settingColor.g, mixb = settingColor.b;
        if (x1 + 5 >= 0 && y1 + 5 >= 0 && x1 - 5 < context.canvas.width - 1 && y1 - 5 < context.canvas.height - 1) {
            mixr = 0;
            mixg = 0;
            mixb = 0;
            let mixx = Math.min(context.canvas.width - 1, Math.max(0, x1 - 5));
            let mixy = Math.min(context.canvas.height - 1, Math.max(0, y1 - 5));
            let mixw = Math.min(context.canvas.width - 1, Math.max(0, x1 + 5));
            let mixh = Math.min(context.canvas.height - 1, Math.max(0, y1 + 5));
            mixw -= mixx;
            mixh -= mixy;
            if (mixw > 0 && mixh > 0) {
                let w = Math.min(sampleCanvas.width, mixw);
                let h = Math.min(sampleCanvas.height, mixh);
                sampleCtx.save();
                sampleCtx.globalCompositeOperation = "copy";
                sampleCtx.drawImage(context.canvas, mixx, mixy, mixw, mixh, 0, 0, w, h);
                sampleCtx.restore();
                let imdat = sampleCtx.getImageData(mixx, mixy, mixw, mixh);
                let countmix = 0;
                for(let i = 0; i < imdat.data.length; i += 4){
                    mixr += imdat.data[i + 0];
                    mixg += imdat.data[i + 1];
                    mixb += imdat.data[i + 2];
                    countmix++;
                }
                mixr /= countmix;
                mixg /= countmix;
                mixb /= countmix;
            }
        }
        let mixed = mixmode[0](new (0, _bb.BB).RGB(mixr, mixg, mixb), settingColor);
        mixr = parseInt("" + (settingBlending * mixed.r + settingColor.r * (1 - settingBlending)));
        mixg = parseInt("" + (settingBlending * mixed.g + settingColor.g * (1 - settingBlending)));
        mixb = parseInt("" + (settingBlending * mixed.b + settingColor.b * (1 - settingBlending)));
        context.strokeStyle = "rgba(" + mixr + ", " + mixg + ", " + mixb + ", " + settingOpacity + ")";
        context.beginPath();
        context.moveTo(x1, y1);
        context.lineTo(x2, y2);
        context.stroke();
        context.strokeStyle = "rgba(" + mixr + ", " + mixg + ", " + mixb + ", " + settingOpacity + ")";
        context.restore();
        let historyEntry = {
            tool: [
                "brush",
                "SketchyBrush"
            ],
            actions: []
        };
        historyEntry.actions.push({
            action: "setScale",
            params: [
                settingScale
            ]
        });
        historyEntry.actions.push({
            action: "setSize",
            params: [
                settingSize / 2
            ]
        });
        historyEntry.actions.push({
            action: "setOpacity",
            params: [
                settingOpacity
            ]
        });
        historyEntry.actions.push({
            action: "setColor",
            params: [
                settingColor
            ]
        });
        historyEntry.actions.push({
            action: "setBlending",
            params: [
                settingBlending
            ]
        });
        historyEntry.actions.push({
            action: "drawLineSegment",
            params: [
                x1,
                y1,
                x2,
                y2
            ]
        });
        history.push(historyEntry);
    };
    this.isDrawing = function() {
        return isDrawing;
    };
}

},{"../../bb/bb":"dcQKo","../kl":"8nmWp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3s9Dy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PixelBrush", ()=>PixelBrush);
var _bb = require("../../bb/bb");
var _kl = require("../kl");
function PixelBrush() {
    let context;
    let history = new (0, _kl.KL).DecoyKlHistory();
    let historyEntry;
    let settingColor, settingSize = 0.5, settingSpacing = 0.9, settingOpacity = 1;
    let settingColorStr;
    let settingHasSizePressure = true, settingHasOpacityPressure = false;
    let settingLockLayerAlpha = false;
    let settingIsEraser = false;
    let settingUseDither = true;
    let lineToolLastDot;
    let lastInput = {
        x: 0,
        y: 0,
        pressure: 0
    };
    let lastInput2 = {
        x: 0,
        y: 0,
        pressure: 0
    };
    let isDrawing = false;
    let bezierLine = null;
    let twoPI = Math.PI * 2;
    let ditherCanvas = (0, _bb.BB).canvas(4, 4);
    let ditherCtx = ditherCanvas.getContext("2d");
    let ditherPattern;
    let ditherArr = [
        [
            3,
            2
        ],
        [
            1,
            0
        ],
        [
            3,
            0
        ],
        [
            1,
            2
        ],
        [
            2,
            1
        ],
        [
            0,
            3
        ],
        [
            0,
            1
        ],
        [
            2,
            3
        ],
        [
            2,
            0
        ],
        [
            0,
            2
        ],
        [
            0,
            0
        ],
        [
            2,
            2
        ],
        [
            1,
            1
        ],
        [
            3,
            3
        ],
        [
            3,
            1
        ],
        [
            1,
            3
        ]
    ];
    function updateDither() {
        ditherCtx.clearRect(0, 0, 4, 4);
        ditherCtx.fillStyle = settingIsEraser ? "#fff" : settingColorStr;
        for(let i = 0; i < Math.max(1, Math.round(settingOpacity * ditherArr.length)); i++)ditherCtx.fillRect(ditherArr[i][0], ditherArr[i][1], 1, 1);
        ditherPattern = context.createPattern(ditherCanvas, "repeat");
    }
    /**
     * Tests p1->p2 or p3->p4 deviate in their direction more than max, compared to p1->p4
     * @param p1
     * @param p2
     * @param p3
     * @param p4
     * @param maxAngleRad
     */ function cubicCurveOverThreshold(p1, p2, p3, p4, max) {
        let d = (0, _bb.BB).Vec2.nor({
            x: p4.x - p1.x,
            y: p4.y - p1.y
        });
        let d2 = (0, _bb.BB).Vec2.nor({
            x: p2.x - p1.x,
            y: p2.y - p1.y
        });
        let d3 = (0, _bb.BB).Vec2.nor({
            x: p4.x - p3.x,
            y: p4.y - p3.y
        });
        let a2 = Math.abs((0, _bb.BB).Vec2.angle(d, d2) % Math.PI) / Math.PI * 180;
        let a3 = Math.abs((0, _bb.BB).Vec2.angle(d, d3) % Math.PI) / Math.PI * 180;
        return Math.max((0, _bb.BB).Vec2.dist(d, d2), (0, _bb.BB).Vec2.dist(d, d3)) > max;
    }
    //bresenheim line drawing
    function plotLine(x0, y0, x1, y1, skipFirst) {
        context.save();
        if (settingIsEraser) {
            context.fillStyle = settingUseDither ? ditherPattern : "#fff";
            if (settingLockLayerAlpha) context.globalCompositeOperation = "source-atop";
            else context.globalCompositeOperation = "destination-out";
        } else {
            context.fillStyle = settingUseDither ? ditherPattern : settingColorStr;
            if (settingLockLayerAlpha) context.globalCompositeOperation = "source-atop";
        }
        context.globalAlpha = settingUseDither ? 1 : settingOpacity;
        x0 = Math.floor(x0);
        y0 = Math.floor(y0);
        x1 = Math.floor(x1);
        y1 = Math.floor(y1);
        let dX = Math.abs(x1 - x0);
        let sX = x0 < x1 ? 1 : -1;
        let dY = -Math.abs(y1 - y0);
        let sY = y0 < y1 ? 1 : -1;
        let err = dX + dY;
        while(true){
            if (skipFirst) skipFirst = false;
            else context.fillRect(x0, y0, 1, 1);
            if (x0 === x1 && y0 === y1) break;
            let e2 = 2 * err;
            if (e2 >= dY) {
                err += dY;
                x0 += sX;
            }
            if (e2 <= dX) {
                err += dX;
                y0 += sY;
            }
        }
        context.restore();
    }
    function plotCubicBezierLine(p1, p2, p3, p4) {
        let isOverThreshold = cubicCurveOverThreshold(p1, p2, p3, p4, 0.1);
        p1.x = Math.floor(p1.x);
        p1.y = Math.floor(p1.y);
        p4.x = Math.floor(p4.x);
        p4.y = Math.floor(p4.y);
        let dist = (0, _bb.BB).dist(p1.x, p1.y, p4.x, p4.y);
        if (!isOverThreshold || dist < 7) {
            plotLine(p1.x, p1.y, p4.x, p4.y, true);
            return;
        }
        let n = Math.max(2, Math.round(dist / 4));
        let pointArr = [];
        for(let i = 0; i <= n; i++){
            let t = i / n;
            let a = Math.pow(1 - t, 3);
            let b = 3 * t * Math.pow(1 - t, 2);
            let c = 3 * Math.pow(t, 2) * (1 - t);
            let d = Math.pow(t, 3);
            pointArr.push({
                x: a * p1.x + b * p2.x + c * p3.x + d * p4.x,
                y: a * p1.y + b * p2.y + c * p3.y + d * p4.y
            });
        }
        for(let i1 = 0; i1 < n; i1++)plotLine(Math.round(pointArr[i1].x), Math.round(pointArr[i1].y), Math.round(pointArr[i1 + 1].x), Math.round(pointArr[i1 + 1].y), true);
    }
    function drawDot(x, y, size, opacity, angle) {
        context.save();
        if (settingIsEraser) {
            context.fillStyle = settingUseDither ? ditherPattern : "#fff";
            if (settingLockLayerAlpha) context.globalCompositeOperation = "source-atop";
            else context.globalCompositeOperation = "destination-out";
        } else {
            context.fillStyle = settingUseDither ? ditherPattern : settingColorStr;
            if (settingLockLayerAlpha) context.globalCompositeOperation = "source-atop";
        }
        context.globalAlpha = settingUseDither ? 1 : opacity;
        context.fillRect(Math.round(x + -size), Math.round(y + -size), Math.round(size * 2), Math.round(size * 2));
        context.restore();
    }
    function continueLine(x, y, size, pressure) {
        if (bezierLine === null) {
            bezierLine = new (0, _bb.BB).BezierLine();
            bezierLine.add(lastInput.x, lastInput.y, 0, function() {});
        }
        context.save();
        function dotCallback(val) {
            let localPressure = (0, _bb.BB).mix(lastInput2.pressure, pressure, val.t);
            let localOpacity = settingOpacity * (settingHasOpacityPressure ? localPressure * localPressure : 1);
            let localSize = Math.max(0.5, settingSize * (settingHasSizePressure ? localPressure : 1));
            drawDot(val.x, val.y, localSize, localOpacity, val.angle);
        }
        function controlCallback(controlObj) {
            plotCubicBezierLine(controlObj.p1, controlObj.p2, controlObj.p3, controlObj.p4);
        }
        if (Math.round(settingSize * 2) === 1) {
            if (x === null) bezierLine.addFinal(4, null, controlCallback);
            else bezierLine.add(x, y, 4, null, controlCallback);
        } else {
            let localSpacing = size * settingSpacing;
            if (x === null) bezierLine.addFinal(localSpacing, dotCallback);
            else bezierLine.add(x, y, localSpacing, dotCallback);
        }
        context.restore();
    }
    //------------------ interface ---------------------------------------------------
    this.startLine = function(x, y, p) {
        historyEntry = {
            tool: [
                "brush",
                "PixelBrush"
            ],
            actions: []
        };
        historyEntry.actions.push({
            action: "sizePressure",
            params: [
                settingHasSizePressure
            ]
        });
        historyEntry.actions.push({
            action: "setSize",
            params: [
                settingSize
            ]
        });
        historyEntry.actions.push({
            action: "setSpacing",
            params: [
                settingSpacing
            ]
        });
        historyEntry.actions.push({
            action: "setOpacity",
            params: [
                settingOpacity
            ]
        });
        historyEntry.actions.push({
            action: "setColor",
            params: [
                settingColor
            ]
        });
        historyEntry.actions.push({
            action: "setLockAlpha",
            params: [
                settingLockLayerAlpha
            ]
        });
        historyEntry.actions.push({
            action: "setIsEraser",
            params: [
                settingIsEraser
            ]
        });
        historyEntry.actions.push({
            action: "setUseDither",
            params: [
                settingUseDither
            ]
        });
        if (settingUseDither) updateDither();
        p = Math.max(0, Math.min(1, p));
        let localOpacity = settingHasOpacityPressure ? settingOpacity * p * p : settingOpacity;
        let localSize = settingHasSizePressure ? Math.max(0.5, p * settingSize) : Math.max(0.5, settingSize);
        isDrawing = true;
        drawDot(x, y, localSize, localOpacity);
        lineToolLastDot = localSize * settingSpacing;
        lastInput.x = x;
        lastInput.y = y;
        lastInput.pressure = p;
        lastInput2 = (0, _bb.BB).copyObj(lastInput);
        historyEntry.actions.push({
            action: "startLine",
            params: [
                x,
                y,
                p
            ]
        });
    };
    this.goLine = function(x, y, p) {
        if (!isDrawing) return;
        historyEntry.actions.push({
            action: "goLine",
            params: [
                x,
                y,
                p
            ]
        });
        //debug
        //drawDot(x, y, 1, 0.5);
        let pressure = (0, _bb.BB).clamp(p, 0, 1);
        let localSize = settingHasSizePressure ? Math.max(0.1, lastInput.pressure * settingSize) : Math.max(0.1, settingSize);
        continueLine(x, y, localSize, lastInput.pressure);
        lastInput2 = (0, _bb.BB).copyObj(lastInput);
        lastInput.x = x;
        lastInput.y = y;
        lastInput.pressure = pressure;
    };
    this.endLine = function(x, y) {
        let localSize = settingHasSizePressure ? Math.max(0.1, lastInput.pressure * settingSize) : Math.max(0.1, settingSize);
        continueLine(null, null, localSize, lastInput.pressure);
        //debug
        //drawDot(lastInput.x, lastInput.y, 3, 1);
        //drawDot(x, y, 10, 0.1);
        isDrawing = false;
        bezierLine = null;
        if (historyEntry) {
            historyEntry.actions.push({
                action: "endLine",
                params: [
                    x,
                    y
                ]
            });
            history.push(historyEntry);
            historyEntry = undefined;
        }
    };
    //cheap n' ugly
    this.drawLineSegment = function(x1, y1, x2, y2) {
        lastInput.x = x2;
        lastInput.y = y2;
        lastInput.pressure = 1;
        if (isDrawing || x1 === undefined) return;
        if (settingUseDither) updateDither();
        if (Math.round(settingSize * 2) === 1) plotLine(x1, y1, x2, y2, true);
        else {
            let angle = (0, _bb.BB).pointsToAngleDeg({
                x: x1,
                y: y1
            }, {
                x: x2,
                y: y2
            });
            let mouseDist = Math.sqrt(Math.pow(x2 - x1, 2.0) + Math.pow(y2 - y1, 2.0));
            let eX = (x2 - x1) / mouseDist;
            let eY = (y2 - y1) / mouseDist;
            let loopDist;
            let bdist = settingSize * settingSpacing;
            lineToolLastDot = settingSize * settingSpacing;
            for(loopDist = lineToolLastDot; loopDist <= mouseDist; loopDist += bdist)drawDot(x1 + eX * loopDist, y1 + eY * loopDist, settingSize, settingOpacity, angle);
        }
        let historyEntry = {
            tool: [
                "brush",
                "PixelBrush"
            ],
            actions: []
        };
        historyEntry.actions.push({
            action: "sizePressure",
            params: [
                settingHasSizePressure
            ]
        });
        historyEntry.actions.push({
            action: "setSize",
            params: [
                settingSize
            ]
        });
        historyEntry.actions.push({
            action: "setSpacing",
            params: [
                settingSpacing
            ]
        });
        historyEntry.actions.push({
            action: "setOpacity",
            params: [
                settingOpacity
            ]
        });
        historyEntry.actions.push({
            action: "setColor",
            params: [
                settingColor
            ]
        });
        historyEntry.actions.push({
            action: "setLockAlpha",
            params: [
                settingLockLayerAlpha
            ]
        });
        historyEntry.actions.push({
            action: "setIsEraser",
            params: [
                settingIsEraser
            ]
        });
        historyEntry.actions.push({
            action: "setUseDither",
            params: [
                settingUseDither
            ]
        });
        historyEntry.actions.push({
            action: "drawLineSegment",
            params: [
                x1,
                y1,
                x2,
                y2
            ]
        });
        history.push(historyEntry);
    };
    //IS
    this.isDrawing = function() {
        return isDrawing;
    };
    //SET
    this.setColor = function(c) {
        if (settingColor === c) return;
        settingColor = c;
        settingColorStr = "rgb(" + settingColor.r + "," + settingColor.g + "," + settingColor.b + ")";
    };
    this.setContext = function(c) {
        context = c;
    };
    this.setHistory = function(l) {
        history = l;
    };
    this.setSize = function(s) {
        settingSize = Math.round(s * 2) / 2;
    };
    this.setOpacity = function(o) {
        settingOpacity = o;
    };
    this.setSpacing = function(s) {
        settingSpacing = s;
    };
    this.sizePressure = function(b) {
        settingHasSizePressure = b;
    };
    this.opacityPressure = function(b) {
        settingHasOpacityPressure = b;
    };
    this.setLockAlpha = function(b) {
        settingLockLayerAlpha = b;
    };
    this.setIsEraser = function(b) {
        settingIsEraser = !!b;
    };
    this.setUseDither = function(b) {
        settingUseDither = !!b;
    };
    //GET
    this.getSpacing = function() {
        return settingSpacing;
    };
    this.getSize = function() {
        return settingSize;
    };
    this.getOpacity = function() {
        return settingOpacity;
    };
    this.getLockAlpha = function() {
        return settingLockLayerAlpha;
    };
    this.getIsEraser = function() {
        return settingIsEraser;
    };
    this.getUseDither = function() {
        return settingUseDither;
    };
}

},{"../../bb/bb":"dcQKo","../kl":"8nmWp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9XyVo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EraserBrush", ()=>EraserBrush);
var _bb = require("../../bb/bb");
var _kl = require("../kl");
function EraserBrush() {
    let context;
    let history = new (0, _kl.KL).DecoyKlHistory();
    let historyEntry;
    let size = 30, spacing = 0.4, opacity = 1;
    let sizePressure = true, opacityPressure = false;
    let lastDot, lastInput = {
        x: 0,
        y: 0,
        pressure: 0
    };
    let lastInput2 = {
        x: 0,
        y: 0,
        pressure: 0
    };
    let started = false;
    let bezierLine;
    let isBaseLayer = false;
    let isTransparentBG = false;
    function drawDot(x, y, size, opacity) {
        context.save();
        if (isBaseLayer) {
            if (isTransparentBG) context.globalCompositeOperation = "destination-out";
            else context.globalCompositeOperation = "source-atop";
        } else context.globalCompositeOperation = "destination-out";
        let radgrad = context.createRadialGradient(size, size, 0, size, size, size);
        let sharpness = Math.pow(opacity, 2);
        sharpness = Math.max(0, Math.min((size - 1) / size, sharpness));
        let oFac = Math.max(0, Math.min(1, opacity));
        let localOpacity = 2 * oFac - oFac * oFac;
        radgrad.addColorStop(sharpness, "rgba(255, 255, 255, " + localOpacity + ")");
        radgrad.addColorStop(1, "rgba(255, 255, 255, 0)");
        context.fillStyle = radgrad;
        context.translate(x - size, y - size);
        context.fillRect(0, 0, size * 2, size * 2);
        context.restore();
    }
    function continueLine(x, y, p) {
        p = Math.max(0, Math.min(1, p));
        let localPressure;
        let localOpacity;
        let localSize = sizePressure ? Math.max(0.1, p * size) : Math.max(0.1, size);
        let bdist = Math.max(1, Math.max(0.5, 1 - opacity) * localSize * spacing);
        function bezierCallback(val) {
            let factor = val.t;
            localPressure = lastInput2.pressure * (1 - factor) + p * factor;
            localOpacity = opacityPressure ? opacity * localPressure * localPressure : opacity;
            localSize = sizePressure ? Math.max(0.1, localPressure * size) : Math.max(0.1, size);
            drawDot(val.x, val.y, localSize, localOpacity);
        }
        if (x === null) bezierLine.addFinal(bdist, bezierCallback);
        else bezierLine.add(x, y, bdist, bezierCallback);
    }
    this.startLine = function(x, y, p) {
        historyEntry = {
            tool: [
                "brush",
                "EraserBrush"
            ],
            actions: []
        };
        historyEntry.actions.push({
            action: "opacityPressure",
            params: [
                opacityPressure
            ]
        });
        historyEntry.actions.push({
            action: "sizePressure",
            params: [
                sizePressure
            ]
        });
        historyEntry.actions.push({
            action: "setSize",
            params: [
                size
            ]
        });
        historyEntry.actions.push({
            action: "setOpacity",
            params: [
                opacity
            ]
        });
        historyEntry.actions.push({
            action: "setTransparentBG",
            params: [
                isTransparentBG
            ]
        });
        isBaseLayer = 0 === context.canvas.index;
        p = Math.max(0, Math.min(1, p));
        let localOpacity = opacityPressure ? opacity * p * p : opacity;
        let localSize = sizePressure ? Math.max(0.1, p * size) : Math.max(0.1, size);
        started = true;
        if (localSize > 1) drawDot(x, y, localSize, localOpacity);
        lastDot = localSize * spacing;
        lastInput.x = x;
        lastInput.y = y;
        lastInput.pressure = p;
        lastInput2 = (0, _bb.BB).copyObj(lastInput);
        bezierLine = new (0, _bb.BB).BezierLine();
        bezierLine.add(x, y, 0, function() {});
        historyEntry.actions.push({
            action: "startLine",
            params: [
                x,
                y,
                p
            ]
        });
    };
    this.goLine = function(x, y, p) {
        if (!started) return;
        historyEntry.actions.push({
            action: "goLine",
            params: [
                x,
                y,
                p
            ]
        });
        continueLine(x, y, lastInput.pressure);
        lastInput2 = (0, _bb.BB).copyObj(lastInput);
        lastInput.x = x;
        lastInput.y = y;
        lastInput.pressure = p;
    };
    this.endLine = function() {
        if (bezierLine) continueLine(null, null, lastInput.pressure);
        started = false;
        bezierLine = undefined;
        if (historyEntry) {
            historyEntry.actions.push({
                action: "endLine",
                params: []
            });
            history.push(historyEntry);
            historyEntry = undefined;
        }
    };
    //cheap n' ugly
    this.drawLineSegment = function(x1, y1, x2, y2) {
        isBaseLayer = 0 === context.canvas.index;
        lastInput.x = x2;
        lastInput.y = y2;
        if (started || x1 === undefined) return;
        let mouseDist = Math.sqrt(Math.pow(x2 - x1, 2.0) + Math.pow(y2 - y1, 2.0));
        let eX = (x2 - x1) / mouseDist;
        let eY = (y2 - y1) / mouseDist;
        let loopDist;
        let bdist = Math.max(1, Math.max(0.5, 1 - opacity) * size * spacing);
        lastDot = 0;
        for(loopDist = lastDot; loopDist <= mouseDist; loopDist += bdist)drawDot(x1 + eX * loopDist, y1 + eY * loopDist, size, opacity);
        let historyEntry = {
            tool: [
                "brush",
                "EraserBrush"
            ],
            actions: []
        };
        historyEntry.actions.push({
            action: "opacityPressure",
            params: [
                opacityPressure
            ]
        });
        historyEntry.actions.push({
            action: "sizePressure",
            params: [
                sizePressure
            ]
        });
        historyEntry.actions.push({
            action: "setSize",
            params: [
                size
            ]
        });
        historyEntry.actions.push({
            action: "setOpacity",
            params: [
                opacity
            ]
        });
        historyEntry.actions.push({
            action: "setTransparentBG",
            params: [
                isTransparentBG
            ]
        });
        historyEntry.actions.push({
            action: "drawLineSegment",
            params: [
                x1,
                y1,
                x2,
                y2
            ]
        });
        history.push(historyEntry);
    };
    //IS
    this.isDrawing = function() {
        return started;
    };
    //SET
    /*this.setAlpha = function(a) {
        lastInput = {};
        alpha = a;
        updateAlphaCanvas();
    };*/ this.setContext = function(c) {
        context = c;
    };
    this.setHistory = function(l) {
        history = l;
    };
    this.setSize = function(s) {
        size = s;
    };
    this.setOpacity = function(o) {
        opacity = o;
    };
    this.sizePressure = function(b) {
        sizePressure = b;
    };
    this.opacityPressure = function(b) {
        opacityPressure = b;
    };
    this.setTransparentBG = function(b) {
        isTransparentBG = b == true;
    };
    //GET
    this.getSize = function() {
        return size;
    };
    this.getOpacity = function() {
        return opacity;
    };
}

},{"../../bb/bb":"dcQKo","../kl":"8nmWp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8pk70":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SmudgeBrush", ()=>SmudgeBrush);
var _bb = require("../../bb/bb");
var _kl = require("../kl");
// let statCount = 1;
// let statAcc = 0;
// stats on win10, chrome, size 100, opacity 80, smudge()
// unoptimized: 1 ms
// minimal: 0.09 ms
// minimal + circle: 0.5ms
// minimal + circle + ix, iy: 0.23ms
// unoptimized + ix, iy: 0.64 ms
// unoptimized + ix, iy + sans rounding: 0.61 ms
// ix, iy + sans rounding + sans random: 0.32ms
// ix, iy + sans rounding + fast random: 0.46 ms
// ix, iy + sans rounding + fast random + offset const: 0.48 ms
const CELL_SIZE = 256;
/**
 * determine bounds of smudge
 * @param imWidth
 * @param imHeight
 * @param aP
 * @param bP
 * @param size
 */ function prepSmudge(imWidth, imHeight, aP, bP, size) {
    if (aP.x === bP.x && aP.y === bP.y) return null;
    aP = (0, _bb.BB).copyObj(aP);
    bP = (0, _bb.BB).copyObj(bP);
    size = (0, _bb.BB).copyObj(size);
    // corner behavior
    // cut down rectangles, if a or b go outside
    // i.e. if user drags partially or fully outside the canvas
    {
        let top = 0;
        let right = 0;
        let bottom = 0;
        let left = 0;
        if (aP.x < 0) left = -aP.x;
        if (aP.y < 0) top = -aP.y;
        if (bP.x < 0) left = Math.max(left, -bP.x);
        if (bP.y < 0) top = Math.max(top, -bP.y);
        if (aP.x + size.w > imWidth) right = aP.x + size.w - imWidth;
        if (aP.y + size.h > imHeight) bottom = aP.y + size.h - imHeight;
        if (bP.x + size.w > imWidth) right = Math.max(right, bP.x + size.w - imWidth);
        if (bP.y + size.h > imHeight) bottom = Math.max(bottom, bP.y + size.h - imHeight);
        aP.x += left;
        bP.x += left;
        aP.y += top;
        bP.y += top;
        size.w = size.w - left - right;
        size.h = size.h - top - bottom;
        if (size.w <= 0 || size.h <= 0) return null;
    }
    return {
        aP: {
            x: aP.x,
            y: aP.y
        },
        bP: {
            x: bP.x,
            y: bP.y
        },
        size: {
            w: size.w,
            h: size.h
        }
    };
}
// faster than using BB.clamp somehow (in chrome)
function clamp(num, min, max) {
    return num <= min ? min : num >= max ? max : num;
}
/**
 * Pixel operations that do the smudging via ImageData
 * @param imageData
 * @param p
 */ function smudge(imageData, p) {
    p = (0, _bb.BB).copyObj(p);
    const cSize = p.brush.size;
    const cX = p.brush.center.x;
    const cY = p.brush.center.y;
    /*if (statCount % 1000 === 0) {
        console.log(statAcc / 1000);
        statAcc = 0;
    }
    let start = performance.now();*/ // determine offset
    let aIndex = p.aP.y * imageData.width + p.aP.x;
    let bIndex = p.bP.y * imageData.width + p.bP.x;
    const offset = (bIndex - aIndex) * 4;
    // array with random numbers. faster than Math.random()
    let randI = 0;
    const randLen = cSize > 30 ? 1024 : 512; // lower lengths lead to noticeable patterns
    const randArr = [];
    for(let i = 0; i < randLen; i++)randArr[i] = (Math.random() - 0.5) / 1.001 + 0.5;
    const softnessPx = Math.max(3, Math.min(8, p.brush.size - 8));
    const pixel = (ai, bi, ix, iy)=>{
        const dist = (0, _bb.BB).dist(cX, cY, ix, iy);
        const fac = 1 - p.brush.opacity * (1 - clamp((dist - (cSize - softnessPx)) / softnessPx, 0, 1));
        if (fac === 1) return;
        if (!imageData.data[ai + 3]) ;
        else if (!imageData.data[bi + 3]) {
            imageData.data[bi] = imageData.data[ai + 0];
            imageData.data[bi + 1] = imageData.data[ai + 1];
            imageData.data[bi + 2] = imageData.data[ai + 2];
        } else {
            // consider alpha ratio. If a has lower alpha than b, then b should be stronger, and vice versa
            // not totally accurate. TODO same compositing as blend brush
            let fac2;
            if (imageData.data[ai + 3] < imageData.data[bi + 3]) fac2 = 1 - imageData.data[ai + 3] / imageData.data[bi + 3] * (1 - fac);
            else fac2 = imageData.data[bi + 3] / imageData.data[ai + 3] * fac;
            // ImageData's Uint8ClampedArray rounds -> 0.5 becomes 1. But not in Safari, so needs to be done manually
            // Offset mixed color by random number noise (-0.5, 0.5), so it doesn't get stuck while mixing.
            // No +0.5, because it cancels out with rand.
            imageData.data[bi] = Math.floor((0, _bb.BB).mix(imageData.data[ai], imageData.data[bi + 0], fac2) + randArr[randI]);
            imageData.data[bi + 1] = Math.floor((0, _bb.BB).mix(imageData.data[ai + 1], imageData.data[bi + 1], fac2) + randArr[randI]);
            imageData.data[bi + 2] = Math.floor((0, _bb.BB).mix(imageData.data[ai + 2], imageData.data[bi + 2], fac2) + randArr[randI]);
            randI = (randI + 1) % randLen;
        }
        // Always mix alpha. unless alpha lock
        if (!p.brush.alphaLock) imageData.data[bi + 3] = Math.floor((0, _bb.BB).mix(imageData.data[ai + 3], imageData.data[bi + 3], fac) + 0.5);
    };
    const bx1 = p.bP.x * 4;
    const bx2 = bx1 + (p.size.w - 1) * 4;
    // transfer of pixels depends on direction of smudging if there is overlap
    if (p.aP.y < p.bP.y) for(let y = p.size.h - 1, iy = p.bP.y + p.size.h - 1; y >= 0; y--, iy--){
        const yStart = (y + p.bP.y) * imageData.width * 4;
        for(let x = bx2 + yStart, x2 = bx2 + yStart - offset, ix = p.bP.x + p.size.w - 1; x >= bx1 + yStart; x -= 4, x2 -= 4, ix--)pixel(x2, x, ix, iy);
    }
    else if (p.aP.y > p.bP.y) for(let y1 = 0, iy1 = p.bP.y; y1 < p.size.h; y1++, iy1++){
        const yStart1 = (y1 + p.bP.y) * imageData.width * 4;
        for(let x1 = bx2 + yStart1, x21 = bx2 + yStart1 - offset, ix1 = p.bP.x + p.size.w - 1; x1 >= bx1 + yStart1; x1 -= 4, x21 -= 4, ix1--)pixel(x21, x1, ix1, iy1);
    }
    else {
        if (p.aP.x < p.bP.x) for(let y2 = p.size.h - 1, iy2 = p.bP.y + p.size.h - 1; y2 >= 0; y2--, iy2--){
            const yStart2 = (y2 + p.bP.y) * imageData.width * 4;
            for(let x3 = bx2 + yStart2, x22 = bx2 + yStart2 - offset, ix2 = p.bP.x + p.size.w - 1; x3 >= bx1 + yStart2; x3 -= 4, x22 -= 4, ix2--)pixel(x22, x3, ix2, iy2);
        }
        else for(let y3 = 0, iy3 = p.bP.y; y3 < p.size.h; y3++, iy3++){
            const yStart3 = (y3 + p.bP.y) * imageData.width * 4;
            for(let x4 = bx1 + yStart3, x23 = bx1 + yStart3 - offset, ix3 = p.bP.x; x4 < bx2 + yStart3; x4 += 4, x23 += 4, ix3++)pixel(x23, x4, ix3, iy3);
        }
    }
//statCount++;
//statAcc += performance.now() - start;
}
class SmudgeBrush {
    history = new (0, _kl.KL).DecoyKlHistory();
    settingColor = {
        r: 0,
        g: 0,
        b: 0
    };
    settingSize = 35;
    settingSpacing = 0.20446882736951905;
    settingOpacity = 0.8;
    settingHasSizePressure = false;
    settingHasOpacityPressure = false;
    settingLockLayerAlpha = false;
    lastInput = {
        x: 0,
        y: 0,
        pressure: 0
    };
    lastInput2 = {
        x: 0,
        y: 0,
        pressure: 0
    };
    isDrawing = false;
    bezierLine = null;
    drawBuffer = [];
    updateRedrawBounds(bounds) {
        this.redrawBounds = (0, _bb.BB).updateBounds(this.redrawBounds, bounds);
    }
    updateCompleteRedrawBounds(x1, y1, x2, y2) {
        this.completeRedrawBounds = (0, _bb.BB).updateBounds(this.completeRedrawBounds, {
            x1,
            y1,
            x2,
            y2
        });
    }
    /**
     * update copyImageData. copy over new regions if needed
     */ copyFromCanvas() {
        const touchedCells = this.copiedCells.map((item)=>false);
        const bounds = [];
        const cellsW = Math.ceil(this.copyImageData.width / CELL_SIZE);
        if (!this.redrawBounds) return;
        bounds.push({
            x1: Math.floor(this.redrawBounds.x1 / CELL_SIZE),
            y1: Math.floor(this.redrawBounds.y1 / CELL_SIZE),
            x2: Math.floor(this.redrawBounds.x2 / CELL_SIZE),
            y2: Math.floor(this.redrawBounds.y2 / CELL_SIZE)
        });
        bounds.forEach((item)=>{
            for(let i = item.x1; i <= item.x2; i++)for(let e = item.y1; e <= item.y2; e++)touchedCells[e * cellsW + i] = true;
        });
        touchedCells.forEach((item, i)=>{
            if (!item || this.copiedCells[i]) // not touched, or already copied
            return;
            this.copiedCells[i] = true;
            const x = i % cellsW;
            const y = Math.floor(i / cellsW);
            const w = (Math.min(x * CELL_SIZE + CELL_SIZE, this.copyImageData.width) - 1) % CELL_SIZE + 1;
            const h = (Math.min(y * CELL_SIZE + CELL_SIZE, this.copyImageData.height) - 1) % CELL_SIZE + 1;
            // temp canvas to prevent main canvas from getting slowed down in chrome
            const tmpCanvas = (0, _bb.BB).canvas(w, h);
            const tmpCtx = tmpCanvas.getContext("2d");
            tmpCtx.drawImage(this.context.canvas, -x * CELL_SIZE, -y * CELL_SIZE);
            const data = tmpCtx.getImageData(0, 0, w, h);
            for(let i1 = 0; i1 < h; i1++)for(let e = 0, e2 = i1 * w * 4, e3 = ((y * CELL_SIZE + i1) * this.copyImageData.width + x * CELL_SIZE) * 4; e < w; e++, e2 += 4, e3 += 4){
                this.copyImageData.data[e3] = data.data[e2];
                this.copyImageData.data[e3 + 1] = data.data[e2 + 1];
                this.copyImageData.data[e3 + 2] = data.data[e2 + 2];
                this.copyImageData.data[e3 + 3] = data.data[e2 + 3];
            }
        });
    }
    /**
     * fill drawBuffer with params about to be drawn
     * @param x
     * @param y
     * @param size
     * @param opacity
     */ prepDot(x, y, size, opacity) {
        if (!this.lastDot) {
            this.lastDot = {
                x: x,
                y: y
            };
            return;
        }
        size = Math.round(size);
        const w = Math.round(size * 2);
        const h = Math.round(size * 2);
        const bounds = prepSmudge(this.copyImageData.width, this.copyImageData.height, {
            x: Math.round(this.lastDot.x - size),
            y: Math.round(this.lastDot.y - size)
        }, {
            x: Math.round(x - size),
            y: Math.round(y - size)
        }, {
            w,
            h
        });
        if (bounds) {
            const params = {
                aP: bounds.aP,
                bP: bounds.bP,
                size: bounds.size,
                brush: {
                    center: {
                        x,
                        y
                    },
                    size,
                    opacity,
                    alphaLock: this.settingLockLayerAlpha
                }
            };
            this.updateRedrawBounds({
                x1: params.bP.x,
                y1: params.bP.y,
                x2: params.bP.x + params.brush.size * 2,
                y2: params.bP.y + params.brush.size * 2
            });
            this.drawBuffer.push(params);
        }
        this.lastDot = {
            x: x,
            y: y
        };
    }
    continueLine(x, y, size, pressure) {
        this.drawBuffer = [];
        if (this.bezierLine === null) {
            this.bezierLine = new (0, _bb.BB).BezierLine();
            this.bezierLine.add(this.lastInput.x, this.lastInput.y, 0, function() {});
        }
        const drawArr = []; //draw instructions. will be all drawn at once
        const dotCallback = (val)=>{
            const localPressure = (0, _bb.BB).mix(this.lastInput2.pressure, pressure, val.t);
            const localOpacity = this.settingOpacity * (this.settingHasOpacityPressure ? localPressure * localPressure : 1);
            const localSize = Math.max(0.1, this.settingSize * (this.settingHasSizePressure ? localPressure : 1));
            drawArr.push([
                val.x,
                val.y,
                localSize,
                localOpacity,
                val.angle
            ]);
        };
        const localSpacing = size * this.settingSpacing / 3;
        if (x === null) this.bezierLine.addFinal(localSpacing, dotCallback);
        else this.bezierLine.add(x, y, localSpacing, dotCallback);
        // execute draw instructions
        let before;
        for(let i = 0; i < drawArr.length; i++){
            const item = drawArr[i];
            this.prepDot(item[0], item[1], item[2], item[3]);
            before = item;
        }
        this.copyFromCanvas();
        for(let i1 = 0; i1 < this.drawBuffer.length; i1++)smudge(this.copyImageData, this.drawBuffer[i1]);
    }
    // ---- public ----
    constructor(){}
    startLine(x, y, p) {
        this.historyEntry = {
            tool: [
                "brush",
                "SmudgeBrush"
            ],
            actions: []
        };
        p = (0, _bb.BB).clamp(p, 0, 1);
        const localOpacity = this.settingHasOpacityPressure ? this.settingOpacity * p * p : this.settingOpacity;
        const localSize = this.settingHasSizePressure ? Math.max(0.1, p * this.settingSize) : Math.max(0.1, this.settingSize);
        this.lastDot = null;
        this.isDrawing = true;
        this.copyImageData = new ImageData(this.context.canvas.width, this.context.canvas.height);
        const totalCells = Math.ceil(this.context.canvas.width / CELL_SIZE) * Math.ceil(this.context.canvas.height / CELL_SIZE);
        this.copiedCells = "0".repeat(totalCells).split("").map((item)=>false);
        this.prepDot(x, y, localSize, localOpacity);
        this.lineToolLastDot = localSize * this.settingSpacing;
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.lastInput.pressure = p;
        this.lastInput2.pressure = p;
        this.completeRedrawBounds = null;
    }
    goLine(x, y, p) {
        if (!this.isDrawing) return;
        this.redrawBounds = null;
        const pressure = (0, _bb.BB).clamp(p, 0, 1);
        const localSize = this.settingHasSizePressure ? Math.max(0.1, this.lastInput.pressure * this.settingSize) : Math.max(0.1, this.settingSize);
        this.continueLine(x, y, localSize, this.lastInput.pressure);
        if (this.redrawBounds) {
            this.context.putImageData(this.copyImageData, 0, 0, this.redrawBounds.x1, this.redrawBounds.y1, this.redrawBounds.x2 - this.redrawBounds.x1 - 1, this.redrawBounds.y2 - this.redrawBounds.y1 - 1);
            this.updateCompleteRedrawBounds(this.redrawBounds.x1, this.redrawBounds.y1, this.redrawBounds.x2, this.redrawBounds.y2);
        }
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.lastInput2.pressure = this.lastInput.pressure;
        this.lastInput.pressure = pressure;
    }
    endLine() {
        this.redrawBounds = null;
        const localSize = this.settingHasSizePressure ? Math.max(0.1, this.lastInput.pressure * this.settingSize) : Math.max(0.1, this.settingSize);
        this.context.save();
        this.continueLine(null, null, localSize, this.lastInput.pressure);
        this.context.restore();
        this.isDrawing = false;
        this.bezierLine = null;
        if (this.redrawBounds) {
            this.context.putImageData(this.copyImageData, 0, 0, this.redrawBounds.x1, this.redrawBounds.y1, this.redrawBounds.x2 - this.redrawBounds.x1 - 1, this.redrawBounds.y2 - this.redrawBounds.y1 - 1);
            this.updateCompleteRedrawBounds(this.redrawBounds.x1, this.redrawBounds.y1, this.redrawBounds.x2, this.redrawBounds.y2);
        }
        if (this.historyEntry && this.completeRedrawBounds) {
            let historyIm = this.copyImageData;
            if (!(this.completeRedrawBounds.x1 === 0 && this.completeRedrawBounds.y1 === 0 && this.completeRedrawBounds.x2 >= this.context.canvas.width - 1 && this.completeRedrawBounds.y2 >= this.context.canvas.height - 1)) {
                // temp canvas to prevent main canvas from getting slowed down in chrome
                const tmpCanvas = (0, _bb.BB).canvas(this.completeRedrawBounds.x2 - this.completeRedrawBounds.x1 + 1, this.completeRedrawBounds.y2 - this.completeRedrawBounds.y1 + 1);
                const tmpCtx = tmpCanvas.getContext("2d");
                tmpCtx.drawImage(this.context.canvas, -this.completeRedrawBounds.x1, -this.completeRedrawBounds.y1);
                historyIm = tmpCanvas; // faster than getting image data (measured on 2018 lenovo chromebook)
            }
            this.historyEntry.actions.push({
                action: "drawImage",
                params: [
                    historyIm,
                    this.completeRedrawBounds.x1,
                    this.completeRedrawBounds.y1, 
                ]
            });
            this.history.push(this.historyEntry);
            this.historyEntry = undefined;
        }
        this.copyImageData = null;
    }
    drawImage(im, x, y) {
        if (im instanceof ImageData) this.context.putImageData(im, x, y);
        else {
            this.context.clearRect(x, y, im.width, im.height);
            this.context.drawImage(im, x, y);
        }
    }
    drawLineSegment(x1, y1, x2, y2) {
        return;
    /*
        // todo
        lastInput.x = x2;
        lastInput.y = y2;
        lastInput.pressure = 1;

        if (isDrawing || x1 === undefined) {
            return;
        }

        let angle = BB.pointsToAngleDeg({x:x1, y:y1}, {x:x2, y:y2});
        let mouseDist = Math.sqrt(Math.pow(x2 - x1, 2.0) + Math.pow(y2 - y1, 2.0));
        let eX = (x2 - x1) / mouseDist;
        let eY = (y2 - y1) / mouseDist;
        let loopDist;
        let bdist = settingSize * settingSpacing;
        lineToolLastDot = settingSize * settingSpacing;
        for (loopDist = lineToolLastDot; loopDist <= mouseDist; loopDist += bdist) {
            drawDot(x1 + eX * loopDist, y1 + eY * loopDist, settingSize, settingOpacity);
        }


        let historyEntry = {
            tool: ["brush", "SmudgeBrush"],
            actions: []
        };
        // todo
        history.add(historyEntry);*/ }
    getIsDrawing() {
        return this.isDrawing;
    }
    setColor(c) {
        if (this.settingColor.r === c.r && this.settingColor.g === c.g && this.settingColor.b === c.b) return;
        this.settingColor = {
            r: c.r,
            g: c.g,
            b: c.b
        };
        this.settingColorStr = (0, _bb.BB).ColorConverter.toRgbStr(this.settingColor);
    }
    setContext(c) {
        this.context = c;
    }
    setHistory(h) {
        this.history = h;
    }
    setSize(s) {
        this.settingSize = s;
    }
    setOpacity(o) {
        this.settingOpacity = o;
    }
    setSpacing(s) {
        this.settingSpacing = s;
    }
    sizePressure(b) {
        this.settingHasSizePressure = !!b;
    }
    opacityPressure(b) {
        this.settingHasOpacityPressure = !!b;
    }
    setLockAlpha(b) {
        this.settingLockLayerAlpha = !!b;
    }
    getSpacing() {
        return this.settingSpacing;
    }
    getSize() {
        return this.settingSize;
    }
    getOpacity() {
        return this.settingOpacity;
    }
    getLockAlpha() {
        return this.settingLockLayerAlpha;
    }
}

},{"../../bb/bb":"dcQKo","../kl":"8nmWp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3wxkc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ChemyBrush", ()=>ChemyBrush);
var _bb = require("../../bb/bb");
class ChemyBrush {
    settingSize = 0.25;
    settingOpacity = 1;
    settingLockLayerAlpha = false;
    settingIsEraser = false;
    settingMode = "fill";
    settingDistort = 0;
    settingXSymmetry = false;
    settingYSymmetry = false;
    settingGradient = false;
    isDrawing = false;
    updateCompleteRedrawBounds(x, y) {
        let bounds = {
            x1: x,
            y1: y,
            x2: x,
            y2: y
        };
        if (this.settingXSymmetry) bounds = (0, _bb.BB).updateBounds(bounds, {
            x1: -x + this.copyCanvas.width,
            y1: y,
            x2: -x + this.copyCanvas.width,
            y2: y
        });
        if (this.settingYSymmetry) bounds = (0, _bb.BB).updateBounds(bounds, {
            x1: x,
            y1: -y + this.copyCanvas.height,
            x2: x,
            y2: -y + this.copyCanvas.height
        });
        const buffer = this.settingMode === "stroke" ? this.settingSize + 1 : 1;
        bounds.x1 = Math.floor(bounds.x1 - buffer);
        bounds.y1 = Math.floor(bounds.y1 - buffer);
        bounds.x2 = Math.ceil(bounds.x2 + buffer);
        bounds.y2 = Math.ceil(bounds.y2 + buffer);
        this.completeRedrawBounds = (0, _bb.BB).updateBounds(this.completeRedrawBounds, bounds);
    }
    drawShape() {
        this.context.save();
        this.context.clearRect(0, 0, this.context.canvas.width, this.context.canvas.height);
        this.context.drawImage(this.copyCanvas, 0, 0);
        let color = {
            ...this.settingColor
        };
        if (this.settingIsEraser) {
            color.r = 255;
            color.g = 255;
            color.b = 255;
            if (this.settingLockLayerAlpha) this.context.globalCompositeOperation = "source-atop";
            else this.context.globalCompositeOperation = "destination-out";
        } else if (this.settingLockLayerAlpha) this.context.globalCompositeOperation = "source-atop";
        if (this.path) {
            // path
            const path = new Path2D();
            this.path.forEach((item, index)=>{
                if (index === 0) path.moveTo(item.x, item.y);
                else path.lineTo(item.x, item.y);
            });
            let style = (0, _bb.BB).ColorConverter.toRgbaStr({
                r: color.r,
                g: color.g,
                b: color.b,
                a: this.settingOpacity
            });
            if (this.settingGradient) {
                const startAtTop = this.path[0].x > this.path[this.path.length - 1].x;
                const gradient = this.context.createLinearGradient(0, startAtTop ? this.minY : this.maxY, 0, startAtTop ? this.maxY : this.minY);
                gradient.addColorStop(0, (0, _bb.BB).ColorConverter.toRgbaStr({
                    r: color.r,
                    g: color.g,
                    b: color.b,
                    a: this.settingOpacity
                }));
                gradient.addColorStop(1, (0, _bb.BB).ColorConverter.toRgbaStr({
                    r: color.r,
                    g: color.g,
                    b: color.b,
                    a: 0
                }));
                style = gradient;
            }
            // setup params
            if (this.settingMode === "fill") this.context.fillStyle = style;
            else {
                this.context.lineWidth = this.settingSize * 2;
                this.context.lineJoin = "bevel";
                this.context.strokeStyle = style;
            }
            // draw
            const draw = ()=>{
                if (this.settingMode === "fill") this.context.fill(path);
                else this.context.stroke(path);
            };
            draw();
            if (this.settingXSymmetry) {
                this.context.save();
                this.context.translate(this.context.canvas.width / 2, 0);
                this.context.scale(-1, 1);
                this.context.translate(-this.context.canvas.width / 2, 0);
                draw();
                this.context.restore();
            }
            if (this.settingYSymmetry) {
                this.context.save();
                this.context.translate(0, this.context.canvas.height / 2);
                this.context.scale(1, -1);
                this.context.translate(0, -this.context.canvas.height / 2);
                draw();
                this.context.restore();
                if (this.settingXSymmetry) {
                    this.context.save();
                    this.context.translate(this.context.canvas.width / 2, this.context.canvas.height / 2);
                    this.context.scale(-1, -1);
                    this.context.translate(-this.context.canvas.width / 2, -this.context.canvas.height / 2);
                    draw();
                    this.context.restore();
                }
            }
        }
        this.context.restore();
    }
    // --- public ----
    constructor(){}
    setHistory(h) {
        this.history = h;
    }
    getSize() {
        return this.settingMode === "stroke" ? this.settingSize : 0;
    }
    setSize(s) {
        this.settingSize = s;
    }
    getOpacity() {
        return this.settingOpacity;
    }
    setOpacity(o) {
        this.settingOpacity = o;
    }
    setColor(c) {
        this.settingColor = (0, _bb.BB).copyObj(c);
    }
    setContext(c) {
        this.context = c;
    }
    setMode(mode) {
        this.settingMode = mode;
    }
    getMode() {
        return this.settingMode;
    }
    setDistort(distort) {
        this.settingDistort = (0, _bb.BB).clamp(distort, 0, 1);
    }
    getDistort() {
        return this.settingDistort;
    }
    setXSymmetry(b) {
        this.settingXSymmetry = !!b;
    }
    getXSymmetry() {
        return this.settingXSymmetry;
    }
    setYSymmetry(b) {
        this.settingYSymmetry = !!b;
    }
    getYSymmetry() {
        return this.settingYSymmetry;
    }
    setGradient(b) {
        this.settingGradient = !!b;
    }
    getGradient() {
        return this.settingGradient;
    }
    getLockAlpha() {
        return this.settingLockLayerAlpha;
    }
    setLockAlpha(b) {
        this.settingLockLayerAlpha = !!b;
    }
    getIsEraser() {
        return this.settingIsEraser;
    }
    setIsEraser(b) {
        this.settingIsEraser = !!b;
    }
    getIsDrawing() {
        return this.isDrawing;
    }
    startLine(x, y) {
        this.isDrawing = true;
        this.path = [
            {
                x,
                y
            }
        ];
        this.minY = y;
        this.maxY = y;
        this.copyCanvas = (0, _bb.BB).canvas(this.context.canvas.width, this.context.canvas.height);
        this.copyCanvas.getContext("2d").drawImage(this.context.canvas, 0, 0);
        this.completeRedrawBounds = null;
        this.updateCompleteRedrawBounds(x, y);
    }
    goLine(x, y) {
        if (!this.isDrawing) return;
        let pos = {
            x,
            y
        };
        if (this.settingDistort > 0) {
            pos.x += (Math.random() - 0.5) * this.settingDistort * 80;
            pos.y += (Math.random() - 0.5) * this.settingDistort * 80;
        }
        this.minY = Math.min(this.minY, pos.y);
        this.maxY = Math.max(this.maxY, pos.y);
        this.path.push(pos);
        this.updateCompleteRedrawBounds(x, y);
        this.drawShape();
    }
    endLine() {
        this.isDrawing = false;
        this.completeRedrawBounds = (0, _bb.BB).boundsInArea(this.completeRedrawBounds, this.copyCanvas.width, this.copyCanvas.height);
        if (this.path.length > 1 && this.completeRedrawBounds) {
            const historyCanvas = (0, _bb.BB).canvas(this.completeRedrawBounds.x2 - this.completeRedrawBounds.x1 + 1, this.completeRedrawBounds.y2 - this.completeRedrawBounds.y1 + 1);
            const historyCtx = historyCanvas.getContext("2d");
            historyCtx.drawImage(this.context.canvas, -this.completeRedrawBounds.x1, -this.completeRedrawBounds.y1);
            this.history.push({
                tool: [
                    "brush",
                    "ChemyBrush"
                ],
                actions: [
                    {
                        action: "drawImage",
                        params: [
                            historyCanvas,
                            this.completeRedrawBounds.x1,
                            this.completeRedrawBounds.y1, 
                        ]
                    }
                ]
            });
        }
        this.path = null;
        this.copyCanvas = null;
    }
    drawImage(im, x, y) {
        this.context.save();
        this.context.clearRect(x, y, im.width, im.height);
        this.context.drawImage(im, x, y);
        this.context.restore();
    }
    drawLineSegment(x1, y1, x2, y2) {
    // might make sense for stroke
    }
}

},{"../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"io8zk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "brushesUI", ()=>brushesUI);
var _penBrushUi = require("./pen-brush-ui");
var _blendBrushUi = require("./blend-brush-ui");
var _sketchyBrushUi = require("./sketchy-brush-ui");
var _pixelBrushUi = require("./pixel-brush-ui");
var _eraserBrushUi = require("./eraser-brush-ui");
var _smudgeBrushUi = require("./smudge-brush-ui");
var _chemyBrushUi = require("./chemy-brush-ui");
const brushesUI = {
    penBrush: (0, _penBrushUi.penBrushUi),
    blendBrush: (0, _blendBrushUi.blendBrushUi),
    sketchyBrush: (0, _sketchyBrushUi.sketchyBrushUi),
    pixelBrush: (0, _pixelBrushUi.pixelBrushUi),
    chemyBrush: (0, _chemyBrushUi.chemyBrushUi),
    smudgeBrush: (0, _smudgeBrushUi.smudgeBrushUi),
    eraserBrush: (0, _eraserBrushUi.eraserBrushUi)
};

},{"./pen-brush-ui":"jEGZw","./blend-brush-ui":"3VdlJ","./sketchy-brush-ui":"cBnfe","./pixel-brush-ui":"h6rIQ","./eraser-brush-ui":"fVvBI","./smudge-brush-ui":"7smKi","./chemy-brush-ui":"cklS9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jEGZw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "penBrushUi", ()=>penBrushUi);
var _bb = require("../../bb/bb");
var _brushes = require("../brushes/brushes");
var _brushesConsts = require("./brushes-consts");
var _klHistory = require("../history/kl-history");
var _checkbox = require("../ui/base-components/checkbox");
var _klSlider = require("../ui/base-components/kl-slider");
var _penPressureToggle = require("../ui/base-components/pen-pressure-toggle");
// @ts-ignore
var _brushPenSvg = require("url:~/src/app/img/ui/brush-pen.svg");
var _brushPenSvgDefault = parcelHelpers.interopDefault(_brushPenSvg);
var _brushAlphas = require("../brushes/alphas/brush-alphas");
var _language = require("../../language/language");
const penBrushUi = function() {
    let brushInterface = {
        image: (0, _brushPenSvgDefault.default),
        tooltip: (0, _language.LANG)("brush-pen"),
        sizeSlider: {
            min: 0.5,
            max: 100,
            curve: (0, _bb.BB).quadraticSplineInput(0.5, 100, 0.1)
        },
        opacitySlider: {
            min: 0.01,
            max: 1,
            curve: [
                [
                    0,
                    0.01
                ],
                [
                    0.5,
                    0.3
                ],
                [
                    1,
                    1
                ]
            ]
        },
        Ui: null
    };
    let alphaNames = [
        (0, _language.LANG)("brush-pen-circle"),
        (0, _language.LANG)("brush-pen-chalk"),
        (0, _language.LANG)("brush-pen-calligraphy"),
        (0, _language.LANG)("brush-pen-square"), 
    ];
    (0, _language.languageStrings).subscribe(()=>{
        brushInterface.tooltip = (0, _language.LANG)("brush-pen");
        alphaNames = [
            (0, _language.LANG)("brush-pen-circle"),
            (0, _language.LANG)("brush-pen-chalk"),
            (0, _language.LANG)("brush-pen-calligraphy"),
            (0, _language.LANG)("brush-pen-square"), 
        ];
    });
    brushInterface.Ui = function(p) {
        let div = document.createElement("div"); // the gui
        let brush = new (0, _brushes.brushes).PenBrush();
        brush.setHistory((0, _klHistory.klHistory));
        p.onSizeChange(brush.getSize());
        let sizeSlider;
        let opacitySlider;
        let alphas = [];
        let currentAlpha = 0;
        for(let i = 0; i < 4; i++)(function(i) {
            let alpha = (0, _bb.BB).el({
                title: alphaNames[i],
                onClick: ()=>{
                    alphaClick(i);
                }
            });
            let canvas = (0, _bb.BB).canvas(70, 70);
            let ctx = canvas.getContext("2d");
            if (i === 0 || i === 3) {
                if (i === 0) {
                    ctx.beginPath();
                    ctx.arc(35, 35, 30, 0, 2 * Math.PI);
                    ctx.closePath();
                    ctx.fill();
                } else ctx.fillRect(5, 5, 60, 60);
            } else if (i === 1) ctx.drawImage((0, _brushAlphas.genBrushAlpha01)(60), 5, 5);
            else if (i === 2) ctx.drawImage((0, _brushAlphas.genBrushAlpha02)(60), 5, 5);
            alpha.style.backgroundImage = "url(" + canvas.toDataURL("image/png") + ")";
            alphas.push(alpha);
        })(i);
        function updateAlphas() {
            for(let i = 0; i < alphas.length; i++)if (i === currentAlpha) alphas[i].className = "brush-alpha-selected";
            else alphas[i].className = "brush-alpha";
        }
        updateAlphas();
        function alphaClick(id) {
            currentAlpha = id;
            brush.setAlpha(id);
            updateAlphas();
        }
        let lockAlphaToggle = new (0, _checkbox.Checkbox)({
            init: brush.getLockAlpha(),
            label: (0, _language.LANG)("lock-alpha"),
            callback: function(b) {
                brush.setLockAlpha(b);
            },
            doHighlight: true,
            title: (0, _language.LANG)("lock-alpha-title"),
            css: {
                cssFloat: "right",
                textAlign: "right"
            }
        });
        let spacingSpline = new (0, _bb.BB).SplineInterpolator([
            [
                0,
                15
            ],
            [
                8,
                7
            ],
            [
                14,
                4
            ],
            [
                30,
                3
            ],
            [
                50,
                2.7
            ],
            [
                100,
                2
            ]
        ]);
        function setSize(size) {
            brush.setSize(size);
            brush.setSpacing(Math.max(2, spacingSpline.interpolate(size)) / 15);
        }
        function init() {
            sizeSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("brush-size"),
                width: 225,
                height: 30,
                min: brushInterface.sizeSlider.min,
                max: brushInterface.sizeSlider.max,
                value: brush.getSize(),
                curve: brushInterface.sizeSlider.curve,
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 2,
                toValue: (displayValue)=>displayValue / 2,
                onChange: (val)=>{
                    setSize(val);
                    p.onSizeChange(val);
                },
                formatFunc: (displayValue)=>{
                    if (displayValue < 10) return (0, _bb.BB).round(displayValue, 1);
                    else return Math.round(displayValue);
                },
                manualInputRoundDigits: 1
            });
            opacitySlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("opacity"),
                width: 225,
                height: 30,
                min: brushInterface.opacitySlider.min,
                max: brushInterface.opacitySlider.max,
                value: brushInterface.opacitySlider.max,
                curve: brushInterface.opacitySlider.curve,
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 100,
                toValue: (displayValue)=>displayValue / 100,
                onChange: (val)=>{
                    brush.setOpacity(val);
                    p.onOpacityChange(val);
                }
            });
            let pressureSizeToggle = (0, _penPressureToggle.penPressureToggle)(true, function(b) {
                brush.sizePressure(b);
            });
            let pressureOpacityToggle = (0, _penPressureToggle.penPressureToggle)(false, function(b) {
                brush.opacityPressure(b);
            });
            div.append((0, _bb.BB).el({
                content: [
                    sizeSlider.getElement(),
                    pressureSizeToggle
                ],
                css: {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center",
                    marginBottom: "10px"
                }
            }), (0, _bb.BB).el({
                content: [
                    opacitySlider.getElement(),
                    pressureOpacityToggle
                ],
                css: {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center"
                }
            }));
            let alphaWrapper = document.createElement("div");
            for(let i = 0; i < alphas.length; i++)alphaWrapper.appendChild(alphas[i]);
            alphaWrapper.style.marginTop = "10px";
            div.appendChild(alphaWrapper);
            alphaWrapper.appendChild(lockAlphaToggle.getElement());
        }
        init();
        this.increaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.changeSliderValue(f);
        };
        this.decreaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.changeSliderValue(-f);
        };
        this.getSize = function() {
            return brush.getSize();
        };
        this.setSize = function(size) {
            setSize(size);
            sizeSlider.setValue(size);
        };
        this.getOpacity = function() {
            return brush.getOpacity();
        };
        this.setOpacity = function(opacity) {
            brush.setOpacity(opacity);
            opacitySlider.setValue(opacity);
        };
        this.setColor = function(c) {
            brush.setColor(c);
        };
        this.setContext = function(c) {
            brush.setContext(c);
        };
        this.startLine = function(x, y, p) {
            brush.startLine(x, y, p);
        };
        this.goLine = function(x, y, p) {
            brush.goLine(x, y, p);
        };
        this.endLine = function(x, y) {
            brush.endLine(x, y);
        };
        this.getBrush = function() {
            return brush;
        };
        this.isDrawing = function() {
            return brush.isDrawing();
        };
        this.getElement = function() {
            return div;
        };
    };
    return brushInterface;
}();

},{"../../bb/bb":"dcQKo","../brushes/brushes":"8eOZC","./brushes-consts":"dlABn","../history/kl-history":"klzEn","../ui/base-components/checkbox":"kPAwM","../ui/base-components/kl-slider":"6YGce","../ui/base-components/pen-pressure-toggle":"h5aJV","url:~/src/app/img/ui/brush-pen.svg":"3rLIS","../brushes/alphas/brush-alphas":"6o2bW","../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dlABn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "eventResMs", ()=>eventResMs);
const eventResMs = 20;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3rLIS":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "brush-pen.3efb96f9.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"3VdlJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "blendBrushUi", ()=>blendBrushUi);
var _bb = require("../../bb/bb");
var _penPressureToggle = require("../ui/base-components/pen-pressure-toggle");
var _brushesConsts = require("./brushes-consts");
var _checkbox = require("../ui/base-components/checkbox");
var _brushes = require("../brushes/brushes");
var _klHistory = require("../history/kl-history");
var _klSlider = require("../ui/base-components/kl-slider");
// @ts-ignore
var _brushBlendSvg = require("url:~/src/app/img/ui/brush-blend.svg");
var _brushBlendSvgDefault = parcelHelpers.interopDefault(_brushBlendSvg);
var _language = require("../../language/language");
const blendBrushUi = function() {
    let brushInterface = {
        image: (0, _brushBlendSvgDefault.default),
        tooltip: (0, _language.LANG)("brush-blend"),
        sizeSlider: {
            min: 0.5,
            max: 100,
            curve: (0, _bb.BB).quadraticSplineInput(0.5, 100, 0.1)
        },
        opacitySlider: {
            min: 0.01,
            max: 1
        },
        Ui: null
    };
    (0, _language.languageStrings).subscribe(()=>{
        brushInterface.tooltip = (0, _language.LANG)("brush-blend");
    });
    brushInterface.Ui = function(p) {
        let div = document.createElement("div"); // the gui
        let brush = new (0, _brushes.brushes).BlendBrush();
        brush.setHistory((0, _klHistory.klHistory));
        p.onSizeChange(brush.getSize());
        let sizeSlider;
        let opacitySlider;
        function setSize(size) {
            brush.setSize(size);
        }
        function init() {
            sizeSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("brush-size"),
                width: 225,
                height: 30,
                min: brushInterface.sizeSlider.min,
                max: brushInterface.sizeSlider.max,
                value: 58,
                curve: brushInterface.sizeSlider.curve,
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 2,
                toValue: (displayValue)=>displayValue / 2,
                onChange: (val)=>{
                    setSize(val);
                    p.onSizeChange(val);
                }
            });
            opacitySlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("opacity"),
                width: 225,
                height: 30,
                min: brushInterface.opacitySlider.min,
                max: brushInterface.opacitySlider.max,
                value: brush.getOpacity(),
                curve: brushInterface.opacitySlider.curve,
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 100,
                toValue: (displayValue)=>displayValue / 100,
                onChange: (val)=>{
                    brush.setOpacity(val);
                    p.onOpacityChange(val);
                }
            });
            let blendingSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("brush-blending"),
                width: 225,
                height: 30,
                min: 0,
                max: 1,
                value: brush.getBlending(),
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 100,
                toValue: (displayValue)=>displayValue / 100,
                onChange: function(val) {
                    brush.setBlending(val);
                }
            });
            blendingSlider.getElement().style.marginTop = "10px";
            let pressureSizeToggle = (0, _penPressureToggle.penPressureToggle)(true, function(b) {
                brush.setSizePressure(b);
            });
            let pressureOpacityToggle = (0, _penPressureToggle.penPressureToggle)(false, function(b) {
                brush.setOpacityPressure(b);
            });
            let lockAlphaToggle = new (0, _checkbox.Checkbox)({
                init: brush.getLockAlpha(),
                label: (0, _language.LANG)("lock-alpha"),
                callback: function(b) {
                    brush.setLockAlpha(b);
                },
                doHighlight: true,
                title: (0, _language.LANG)("lock-alpha-title"),
                css: {
                    marginTop: "10px",
                    display: "inline-block"
                }
            });
            div.append((0, _bb.BB).el({
                content: [
                    sizeSlider.getElement(),
                    pressureSizeToggle
                ],
                css: {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center",
                    marginBottom: "10px"
                }
            }), (0, _bb.BB).el({
                content: [
                    opacitySlider.getElement(),
                    pressureOpacityToggle
                ],
                css: {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center"
                }
            }), blendingSlider.getElement(), lockAlphaToggle.getElement());
        }
        init();
        this.increaseSize = function(f) {
            if (!brush.getIsDrawing()) sizeSlider.changeSliderValue(f);
        };
        this.decreaseSize = function(f) {
            if (!brush.getIsDrawing()) sizeSlider.changeSliderValue(-f);
        };
        this.getSize = function() {
            return brush.getSize();
        };
        this.setSize = function(size) {
            setSize(size);
            sizeSlider.setValue(size);
        };
        this.getOpacity = function() {
            return brush.getOpacity();
        };
        this.setOpacity = function(opacity) {
            brush.setOpacity(opacity);
            opacitySlider.setValue(opacity);
        };
        this.setColor = function(c) {
            brush.setColor(c);
        };
        this.setContext = function(c) {
            brush.setContext(c);
        };
        this.startLine = function(x, y, p) {
            brush.startLine(x, y, p);
        };
        this.goLine = function(x, y, p, isCoalesced) {
            brush.goLine(x, y, p, isCoalesced);
        };
        this.endLine = function() {
            brush.endLine();
        };
        this.getBrush = function() {
            return brush;
        };
        this.isDrawing = function() {
            return brush.getIsDrawing();
        };
        this.getElement = function() {
            return div;
        };
    };
    return brushInterface;
}();

},{"../../bb/bb":"dcQKo","../ui/base-components/pen-pressure-toggle":"h5aJV","./brushes-consts":"dlABn","../ui/base-components/checkbox":"kPAwM","../brushes/brushes":"8eOZC","../history/kl-history":"klzEn","../ui/base-components/kl-slider":"6YGce","url:~/src/app/img/ui/brush-blend.svg":"2YlU4","../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2YlU4":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "brush-blend.c7de15e6.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"cBnfe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sketchyBrushUi", ()=>sketchyBrushUi);
var _brushes = require("../brushes/brushes");
var _brushesConsts = require("./brushes-consts");
var _klHistory = require("../history/kl-history");
var _klSlider = require("../ui/base-components/kl-slider");
// @ts-ignore
var _brushSketchyPng = require("url:~/src/app/img/ui/brush-sketchy.png");
var _brushSketchyPngDefault = parcelHelpers.interopDefault(_brushSketchyPng);
var _language = require("../../language/language");
var _bb = require("../../bb/bb");
const sketchyBrushUi = function() {
    let brushInterface = {
        image: (0, _brushSketchyPngDefault.default),
        tooltip: (0, _language.LANG)("brush-sketchy"),
        sizeSlider: {
            min: 0.5,
            max: 10
        },
        opacitySlider: {
            min: 0.01,
            max: 1
        },
        Ui: null
    };
    (0, _language.languageStrings).subscribe(()=>{
        brushInterface.tooltip = (0, _language.LANG)("brush-sketchy");
    });
    brushInterface.Ui = function(p) {
        let div = document.createElement("div"); // the gui
        let brush = new (0, _brushes.brushes).SketchyBrush();
        brush.setHistory((0, _klHistory.klHistory));
        p.onSizeChange(brush.getSize());
        let sizeSlider;
        let opacitySlider;
        function setSize(size) {
            brush.setSize(size);
        }
        function init() {
            sizeSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("brush-size"),
                width: 250,
                height: 30,
                min: brushInterface.sizeSlider.min,
                max: brushInterface.sizeSlider.max,
                value: brush.getSize() * 2,
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 2,
                toValue: (displayValue)=>displayValue / 2,
                onChange: function(val) {
                    brush.setSize(val);
                    p.onSizeChange(val);
                },
                formatFunc: (displayValue)=>{
                    if (displayValue < 10) return (0, _bb.BB).round(displayValue, 1);
                    else return Math.round(displayValue);
                },
                manualInputRoundDigits: 1
            });
            opacitySlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("opacity"),
                width: 250,
                height: 30,
                min: brushInterface.opacitySlider.min,
                max: brushInterface.opacitySlider.max,
                value: brush.getOpacity(),
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 100,
                toValue: (displayValue)=>displayValue / 100,
                onChange: (val)=>{
                    brush.setOpacity(val);
                    p.onOpacityChange(val);
                }
            });
            let blendSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("brush-blending"),
                width: 250,
                height: 30,
                min: 0,
                max: 1,
                value: brush.getBlending(),
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 100,
                toValue: (displayValue)=>displayValue / 100,
                onChange: function(val) {
                    brush.setBlending(val);
                }
            });
            let scaleSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("brush-sketchy-scale"),
                width: 250,
                height: 30,
                min: 1,
                max: 20,
                value: brush.getScale(),
                eventResMs: (0, _brushesConsts.eventResMs),
                onChange: function(val) {
                    brush.setScale(val);
                }
            });
            opacitySlider.getElement().style.marginTop = "10px";
            blendSlider.getElement().style.marginTop = "10px";
            scaleSlider.getElement().style.marginTop = "10px";
            div.appendChild(sizeSlider.getElement());
            div.appendChild(opacitySlider.getElement());
            div.appendChild(blendSlider.getElement());
            div.appendChild(scaleSlider.getElement());
        }
        init();
        this.increaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.changeSliderValue(f);
        };
        this.decreaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.changeSliderValue(-f);
        };
        this.getSize = function() {
            return brush.getSize();
        };
        this.setSize = function(size) {
            setSize(size);
            sizeSlider.setValue(size);
        };
        this.getOpacity = function() {
            return brush.getOpacity();
        };
        this.setOpacity = function(opacity) {
            brush.setOpacity(opacity);
            opacitySlider.setValue(opacity);
        };
        this.setColor = function(c) {
            brush.setColor(c);
        };
        this.setContext = function(c) {
            brush.setContext(c);
        };
        this.startLine = function(x, y, pressure) {
            brush.startLine(x, y, pressure);
        };
        this.goLine = function(x, y, pressure) {
            brush.goLine(x, y, pressure, null);
        };
        this.endLine = function() {
            brush.endLine();
        };
        this.getSeed = function() {
            return parseInt(brush.getSeed());
        };
        this.setSeed = function(s) {
            brush.setSeed(parseInt(s));
        };
        this.getBrush = function() {
            return brush;
        };
        this.isDrawing = function() {
            return brush.isDrawing();
        };
        this.getElement = function() {
            return div;
        };
    };
    return brushInterface;
}();

},{"../brushes/brushes":"8eOZC","./brushes-consts":"dlABn","../history/kl-history":"klzEn","../ui/base-components/kl-slider":"6YGce","url:~/src/app/img/ui/brush-sketchy.png":"jpfHu","../../language/language":"iiYGN","../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jpfHu":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "brush-sketchy.f7180c8a.png" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"h6rIQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pixelBrushUi", ()=>pixelBrushUi);
var _bb = require("../../bb/bb");
var _brushes = require("../brushes/brushes");
var _brushesConsts = require("./brushes-consts");
var _klHistory = require("../history/kl-history");
var _checkbox = require("../ui/base-components/checkbox");
var _klSlider = require("../ui/base-components/kl-slider");
var _penPressureToggle = require("../ui/base-components/pen-pressure-toggle");
// @ts-ignore
var _brushPixelSvg = require("url:~/src/app/img/ui/brush-pixel.svg");
var _brushPixelSvgDefault = parcelHelpers.interopDefault(_brushPixelSvg);
var _language = require("../../language/language");
const pixelBrushUi = function() {
    let brushInterface = {
        image: (0, _brushPixelSvgDefault.default),
        tooltip: (0, _language.LANG)("brush-pixel"),
        sizeSlider: {
            min: 0.5,
            max: 100,
            curve: (0, _bb.BB).quadraticSplineInput(0.5, 100, 0.1)
        },
        opacitySlider: {
            min: 0.01,
            max: 1,
            curve: [
                [
                    0,
                    0.01
                ],
                [
                    0.5,
                    0.3
                ],
                [
                    1,
                    1
                ]
            ]
        },
        Ui: null
    };
    (0, _language.languageStrings).subscribe(()=>{
        brushInterface.tooltip = (0, _language.LANG)("brush-pixel");
    });
    brushInterface.Ui = function(p) {
        let div = document.createElement("div"); // the gui
        let brush = new (0, _brushes.brushes).PixelBrush();
        brush.setHistory((0, _klHistory.klHistory));
        p.onSizeChange(brush.getSize());
        let sizeSlider;
        let opacitySlider;
        let lockAlphaToggle = new (0, _checkbox.Checkbox)({
            init: brush.getLockAlpha(),
            label: (0, _language.LANG)("lock-alpha"),
            callback: function(b) {
                brush.setLockAlpha(b);
            },
            doHighlight: true,
            title: (0, _language.LANG)("lock-alpha-title"),
            css: {
                marginRight: "10px"
            }
        });
        let eraserToggle = new (0, _checkbox.Checkbox)({
            init: brush.getIsEraser(),
            label: (0, _language.LANG)("eraser"),
            callback: function(b) {
                brush.setIsEraser(b);
            },
            css: {
                marginRight: "10px"
            }
        });
        let ditherToggle = new (0, _checkbox.Checkbox)({
            init: brush.getUseDither(),
            label: (0, _language.LANG)("brush-pixel-dither"),
            callback: function(b) {
                brush.setUseDither(b);
            }
        });
        let spacingSpline = new (0, _bb.BB).SplineInterpolator([
            [
                0.5,
                0.45
            ],
            [
                100,
                4
            ]
        ]);
        function setSize(size) {
            brush.setSize(size);
            brush.setSpacing(spacingSpline.interpolate(size) / size);
        }
        function init() {
            sizeSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("brush-size"),
                width: 225,
                height: 30,
                min: brushInterface.sizeSlider.min,
                max: brushInterface.sizeSlider.max,
                value: brush.getSize(),
                curve: brushInterface.sizeSlider.curve,
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 2,
                toValue: (displayValue)=>displayValue / 2,
                onChange: (val)=>{
                    setSize(val);
                    p.onSizeChange(val);
                }
            });
            opacitySlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("opacity"),
                width: 225,
                height: 30,
                min: brushInterface.opacitySlider.min,
                max: brushInterface.opacitySlider.max,
                value: brushInterface.opacitySlider.max,
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 100,
                toValue: (displayValue)=>displayValue / 100,
                onChange: (val)=>{
                    brush.setOpacity(val);
                    p.onOpacityChange(val);
                }
            });
            let pressureSizeToggle = (0, _penPressureToggle.penPressureToggle)(true, function(b) {
                brush.sizePressure(b);
            });
            div.append((0, _bb.BB).el({
                content: [
                    sizeSlider.getElement(),
                    pressureSizeToggle
                ],
                css: {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center",
                    marginBottom: "10px"
                }
            }), opacitySlider.getElement());
            let toggleRow = (0, _bb.BB).el({
                parent: div,
                css: {
                    display: "flex",
                    marginTop: "10px"
                }
            });
            toggleRow.appendChild(lockAlphaToggle.getElement());
            toggleRow.appendChild(eraserToggle.getElement());
            toggleRow.appendChild(ditherToggle.getElement());
        }
        init();
        this.increaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.changeSliderValue(f);
        };
        this.decreaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.changeSliderValue(-f);
        };
        this.getSize = function() {
            return brush.getSize();
        };
        this.setSize = function(size) {
            setSize(size);
            sizeSlider.setValue(size * 2);
        };
        this.getOpacity = function() {
            return brush.getOpacity();
        };
        this.setOpacity = function(opacity) {
            brush.setOpacity(opacity);
            opacitySlider.setValue(opacity * 100);
        };
        this.setColor = function(c) {
            brush.setColor(c);
        };
        this.setContext = function(c) {
            brush.setContext(c);
        };
        this.startLine = function(x, y, p) {
            brush.startLine(x, y, p);
        };
        this.goLine = function(x, y, p) {
            brush.goLine(x, y, p);
        };
        this.endLine = function(x, y) {
            brush.endLine(x, y);
        };
        this.getBrush = function() {
            return brush;
        };
        this.isDrawing = function() {
            return brush.isDrawing();
        };
        this.getElement = function() {
            return div;
        };
    };
    return brushInterface;
}();

},{"../../bb/bb":"dcQKo","../brushes/brushes":"8eOZC","./brushes-consts":"dlABn","../history/kl-history":"klzEn","../ui/base-components/checkbox":"kPAwM","../ui/base-components/kl-slider":"6YGce","../ui/base-components/pen-pressure-toggle":"h5aJV","url:~/src/app/img/ui/brush-pixel.svg":"4Kx34","../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4Kx34":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "brush-pixel.43717b99.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"fVvBI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "eraserBrushUi", ()=>eraserBrushUi);
var _bb = require("../../bb/bb");
var _brushes = require("../brushes/brushes");
var _brushesConsts = require("./brushes-consts");
var _klHistory = require("../history/kl-history");
var _klSlider = require("../ui/base-components/kl-slider");
var _penPressureToggle = require("../ui/base-components/pen-pressure-toggle");
var _checkbox = require("../ui/base-components/checkbox");
// @ts-ignore
var _brushEraserSvg = require("url:~/src/app/img/ui/brush-eraser.svg");
var _brushEraserSvgDefault = parcelHelpers.interopDefault(_brushEraserSvg);
var _language = require("../../language/language");
const eraserBrushUi = function() {
    let brushInterface = {
        image: (0, _brushEraserSvgDefault.default),
        tooltip: (0, _language.LANG)("eraser") + " [E]",
        sizeSlider: {
            min: 0.5,
            max: 200,
            curve: (0, _bb.BB).quadraticSplineInput(0.5, 200, 0.1)
        },
        opacitySlider: {
            min: 0.01,
            max: 1
        },
        Ui: null
    };
    (0, _language.languageStrings).subscribe(()=>{
        brushInterface.tooltip = (0, _language.LANG)("eraser") + " [E]";
    });
    brushInterface.Ui = function(p) {
        let div = document.createElement("div"); // the gui
        let brush = new (0, _brushes.brushes).EraserBrush();
        brush.setHistory((0, _klHistory.klHistory));
        p.onSizeChange(brush.getSize());
        let sizeSlider;
        let opacitySlider;
        let isTransparentBg = false;
        function setSize(size) {
            brush.setSize(size);
        }
        function init() {
            sizeSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("brush-size"),
                width: 225,
                height: 30,
                min: brushInterface.sizeSlider.min,
                max: brushInterface.sizeSlider.max,
                value: 30,
                curve: brushInterface.sizeSlider.curve,
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 2,
                toValue: (displayValue)=>displayValue / 2,
                onChange: (val)=>{
                    setSize(val);
                    p.onSizeChange(val);
                },
                formatFunc: (displayValue)=>{
                    if (displayValue < 10) return (0, _bb.BB).round(displayValue, 1);
                    else return Math.round(displayValue);
                },
                manualInputRoundDigits: 1
            });
            opacitySlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("opacity"),
                width: 225,
                height: 30,
                min: brushInterface.opacitySlider.min,
                max: brushInterface.opacitySlider.max,
                value: brushInterface.opacitySlider.max,
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 100,
                toValue: (displayValue)=>displayValue / 100,
                onChange: (val)=>{
                    brush.setOpacity(val);
                    p.onOpacityChange(val);
                }
            });
            let pressureSizeToggle = (0, _penPressureToggle.penPressureToggle)(true, function(b) {
                brush.sizePressure(b);
            });
            let pressureOpacityToggle = (0, _penPressureToggle.penPressureToggle)(false, function(b) {
                brush.opacityPressure(b);
            });
            div.append((0, _bb.BB).el({
                content: [
                    sizeSlider.getElement(),
                    pressureSizeToggle
                ],
                css: {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center",
                    marginBottom: "10px"
                }
            }), (0, _bb.BB).el({
                content: [
                    opacitySlider.getElement(),
                    pressureOpacityToggle
                ],
                css: {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center"
                }
            }));
            let transparencyToggle = new (0, _checkbox.Checkbox)({
                init: false,
                label: (0, _language.LANG)("brush-eraser-transparent-bg"),
                callback: function(b) {
                    isTransparentBg = b;
                    brush.setTransparentBG(b);
                },
                css: {
                    marginTop: "10px"
                }
            });
            div.appendChild(transparencyToggle.getElement());
        }
        init();
        function drawDot(x, y) {
            brush.drawDot(x, y);
        }
        this.increaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.changeSliderValue(f);
        };
        this.decreaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.changeSliderValue(-f);
        };
        this.getSize = function() {
            return brush.getSize();
        };
        this.setSize = function(size) {
            setSize(size);
            sizeSlider.setValue(size);
        };
        this.getOpacity = function() {
            return brush.getOpacity();
        };
        this.setOpacity = function(opacity) {
            brush.setOpacity(opacity);
            opacitySlider.setValue(opacity);
        };
        this.setColor = function(c) {
        //brush.setColor(c);
        };
        this.setContext = function(c) {
            brush.setContext(c);
        };
        this.startLine = function(x, y, p) {
            brush.startLine(x, y, p);
        };
        this.goLine = function(x, y, p) {
            brush.goLine(x, y, p);
        };
        this.endLine = function() {
            brush.endLine();
        };
        this.getBrush = function() {
            return brush;
        };
        this.getIsTransparentBg = function() {
            return isTransparentBg;
        };
        this.isDrawing = function() {
            return brush.isDrawing();
        };
        this.getElement = function() {
            return div;
        };
    };
    return brushInterface;
}();

},{"../../bb/bb":"dcQKo","../brushes/brushes":"8eOZC","./brushes-consts":"dlABn","../history/kl-history":"klzEn","../ui/base-components/kl-slider":"6YGce","../ui/base-components/pen-pressure-toggle":"h5aJV","../ui/base-components/checkbox":"kPAwM","url:~/src/app/img/ui/brush-eraser.svg":"cSK4u","../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cSK4u":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "brush-eraser.b3f3ce1a.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"7smKi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "smudgeBrushUi", ()=>smudgeBrushUi);
var _bb = require("../../bb/bb");
var _brushes = require("../brushes/brushes");
var _brushesConsts = require("./brushes-consts");
var _klHistory = require("../history/kl-history");
var _checkbox = require("../ui/base-components/checkbox");
var _klSlider = require("../ui/base-components/kl-slider");
var _penPressureToggle = require("../ui/base-components/pen-pressure-toggle");
// @ts-ignore
var _brushSmudgeSvg = require("url:~/src/app/img/ui/brush-smudge.svg");
var _brushSmudgeSvgDefault = parcelHelpers.interopDefault(_brushSmudgeSvg);
var _language = require("../../language/language");
const smudgeBrushUi = function() {
    let brushInterface = {
        image: (0, _brushSmudgeSvgDefault.default),
        tooltip: (0, _language.LANG)("brush-smudge"),
        sizeSlider: {
            min: 0.5,
            max: 100,
            curve: (0, _bb.BB).quadraticSplineInput(0.5, 100, 0.1)
        },
        opacitySlider: {
            min: 0.01,
            max: 1,
            curve: [
                [
                    0,
                    0.01
                ],
                [
                    0.5,
                    0.3
                ],
                [
                    1,
                    1
                ]
            ]
        },
        Ui: null
    };
    (0, _language.languageStrings).subscribe(()=>{
        brushInterface.tooltip = (0, _language.LANG)("brush-smudge");
    });
    brushInterface.Ui = function(p) {
        let div = document.createElement("div"); // the gui
        let brush = new (0, _brushes.brushes).SmudgeBrush();
        brush.setHistory((0, _klHistory.klHistory));
        p.onSizeChange(brush.getSize());
        let sizeSlider;
        let opacitySlider;
        let lockAlphaToggle = new (0, _checkbox.Checkbox)({
            init: brush.getLockAlpha(),
            label: (0, _language.LANG)("lock-alpha"),
            callback: function(b) {
                brush.setLockAlpha(b);
            },
            doHighlight: true,
            title: (0, _language.LANG)("lock-alpha-title")
        });
        let spacingSpline = new (0, _bb.BB).SplineInterpolator([
            [
                0,
                15
            ],
            [
                8,
                7
            ],
            [
                14,
                4
            ],
            [
                30,
                3
            ],
            [
                50,
                2.7
            ],
            [
                100,
                2
            ]
        ]);
        function setSize(size) {
            brush.setSize(size);
            brush.setSpacing(Math.max(2, spacingSpline.interpolate(size)) / 15);
        }
        function init() {
            sizeSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("brush-size"),
                width: 225,
                height: 30,
                min: brushInterface.sizeSlider.min,
                max: brushInterface.sizeSlider.max,
                value: brush.getSize(),
                curve: brushInterface.sizeSlider.curve,
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 2,
                toValue: (displayValue)=>displayValue / 2,
                onChange: (val)=>{
                    setSize(val);
                    p.onSizeChange(val);
                },
                formatFunc: (displayValue)=>{
                    if (displayValue < 10) return (0, _bb.BB).round(displayValue, 1);
                    else return Math.round(displayValue);
                },
                manualInputRoundDigits: 1
            });
            opacitySlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("opacity"),
                width: 225,
                height: 30,
                min: brushInterface.opacitySlider.min,
                max: brushInterface.opacitySlider.max,
                value: brush.getOpacity(),
                curve: brushInterface.opacitySlider.curve,
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 100,
                toValue: (displayValue)=>displayValue / 100,
                onChange: (val)=>{
                    brush.setOpacity(val);
                    p.onOpacityChange(val);
                }
            });
            let pressureSizeToggle = (0, _penPressureToggle.penPressureToggle)(false, function(b) {
                brush.sizePressure(b);
            });
            let pressureOpacityToggle = (0, _penPressureToggle.penPressureToggle)(false, function(b) {
                brush.opacityPressure(b);
            });
            div.append((0, _bb.BB).el({
                content: [
                    sizeSlider.getElement(),
                    pressureSizeToggle
                ],
                css: {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center",
                    marginBottom: "10px"
                }
            }), (0, _bb.BB).el({
                content: [
                    opacitySlider.getElement(),
                    pressureOpacityToggle
                ],
                css: {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center"
                }
            }));
            let bottomRow = (0, _bb.BB).el({
                parent: div,
                css: {
                    marginTop: "10px"
                }
            });
            bottomRow.append(lockAlphaToggle.getElement());
        }
        init();
        this.increaseSize = function(f) {
            if (!brush.getIsDrawing()) sizeSlider.changeSliderValue(f);
        };
        this.decreaseSize = function(f) {
            if (!brush.getIsDrawing()) sizeSlider.changeSliderValue(-f);
        };
        this.getSize = function() {
            return brush.getSize();
        };
        this.setSize = function(size) {
            setSize(size);
            sizeSlider.setValue(size);
        };
        this.getOpacity = function() {
            return brush.getOpacity();
        };
        this.setOpacity = function(opacity) {
            brush.setOpacity(opacity);
            opacitySlider.setValue(opacity);
        };
        this.setColor = function(c) {
            brush.setColor(c);
        };
        this.setContext = function(c) {
            brush.setContext(c);
        };
        this.startLine = function(x, y, p) {
            brush.startLine(x, y, p);
        };
        this.goLine = function(x, y, p) {
            brush.goLine(x, y, p);
        };
        this.endLine = function(x, y) {
            brush.endLine();
        };
        this.getBrush = function() {
            return brush;
        };
        this.isDrawing = function() {
            return brush.getIsDrawing();
        };
        this.getElement = function() {
            return div;
        };
    };
    return brushInterface;
}();

},{"../../bb/bb":"dcQKo","../brushes/brushes":"8eOZC","./brushes-consts":"dlABn","../history/kl-history":"klzEn","../ui/base-components/checkbox":"kPAwM","../ui/base-components/kl-slider":"6YGce","../ui/base-components/pen-pressure-toggle":"h5aJV","url:~/src/app/img/ui/brush-smudge.svg":"2uypO","../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2uypO":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "brush-smudge.141b13d5.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"cklS9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "chemyBrushUi", ()=>chemyBrushUi);
var _bb = require("../../bb/bb");
var _brushesConsts = require("./brushes-consts");
var _checkbox = require("../ui/base-components/checkbox");
var _brushes = require("../brushes/brushes");
var _klHistory = require("../history/kl-history");
var _klSlider = require("../ui/base-components/kl-slider");
// @ts-ignore
var _brushChemySvg = require("url:~/src/app/img/ui/brush-chemy.svg");
var _brushChemySvgDefault = parcelHelpers.interopDefault(_brushChemySvg);
var _options = require("../ui/base-components/options");
var _boxToggle = require("../ui/base-components/box-toggle");
var _language = require("../../language/language");
const chemyBrushUi = function() {
    const brushInterface = {
        image: (0, _brushChemySvgDefault.default),
        tooltip: (0, _language.LANG)("brush-chemy"),
        sizeSlider: {
            min: 0.25,
            max: 25,
            curve: (0, _bb.BB).quadraticSplineInput(0.25, 25, 0.1),
            isDisabled: true
        },
        opacitySlider: {
            min: 0.01,
            max: 1
        },
        Ui: null
    };
    (0, _language.languageStrings).subscribe(()=>{
        brushInterface.tooltip = (0, _language.LANG)("brush-chemy");
    });
    brushInterface.Ui = function(p) {
        const div = document.createElement("div"); // the gui
        const brush = new (0, _brushes.brushes).ChemyBrush();
        brush.setHistory((0, _klHistory.klHistory));
        p.onSizeChange(brush.getSize());
        let sizeSlider;
        let opacitySlider;
        function setSize(size) {
            brush.setSize(size);
        }
        function init() {
            sizeSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("brush-size"),
                width: 250,
                height: 30,
                min: brushInterface.sizeSlider.min,
                max: brushInterface.sizeSlider.max,
                value: brush.getSize(),
                curve: brushInterface.sizeSlider.curve,
                eventResMs: (0, _brushesConsts.eventResMs),
                isEnabled: brush.getMode() === "stroke",
                toDisplayValue: (val)=>val * 2,
                toValue: (displayValue)=>displayValue / 2,
                onChange: (val)=>{
                    setSize(val);
                    p.onSizeChange(val);
                },
                formatFunc: (displayValue)=>{
                    if (displayValue < 5) return (0, _bb.BB).round(displayValue, 1);
                    else return Math.round(displayValue);
                },
                manualInputRoundDigits: 1
            });
            opacitySlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("opacity"),
                width: 250,
                height: 30,
                min: brushInterface.opacitySlider.min,
                max: brushInterface.opacitySlider.max,
                value: brush.getOpacity(),
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 100,
                toValue: (displayValue)=>displayValue / 100,
                onChange: (val)=>{
                    brush.setOpacity(val);
                    p.onOpacityChange(val);
                }
            });
            (0, _bb.BB).css(opacitySlider.getElement(), {
                marginTop: "10px"
            });
            let eraserToggle = new (0, _checkbox.Checkbox)({
                init: brush.getIsEraser(),
                label: (0, _language.LANG)("eraser"),
                callback: function(b) {
                    brush.setIsEraser(b);
                },
                css: {
                    marginTop: "10px",
                    marginLeft: "10px"
                }
            });
            const lockAlphaToggle = new (0, _checkbox.Checkbox)({
                init: brush.getLockAlpha(),
                label: (0, _language.LANG)("lock-alpha"),
                callback: function(b) {
                    brush.setLockAlpha(b);
                },
                doHighlight: true,
                title: (0, _language.LANG)("lock-alpha-title"),
                css: {
                    marginTop: "10px"
                }
            });
            const toggleRow = (0, _bb.BB).el({
                css: {
                    display: "flex",
                    marginTop: "10px"
                }
            });
            const iconSize = 35;
            const padding = 8;
            const actualIconSize = iconSize - padding * 2;
            const halfSize = actualIconSize / 2;
            const modeOptions = new (0, _options.Options)({
                optionArr: [
                    {
                        id: "fill",
                        label: (0, _bb.BB).createSvg({
                            elementType: "svg",
                            width: iconSize + "",
                            height: iconSize + "",
                            childrenArr: [
                                {
                                    elementType: "path",
                                    fill: "#000",
                                    style: `transform-origin: 0 0; transform: translate(-0.5px, -0.5px) scale(${actualIconSize}, ${actualIconSize}) translate(0.5px, 0.5px)`,
                                    d: "M 0,0 C 1.5,0 -0.5,1 1,1"
                                }, 
                            ]
                        }),
                        title: (0, _language.LANG)("brush-chemy-fill")
                    },
                    {
                        id: "stroke",
                        label: (0, _bb.BB).createSvg({
                            elementType: "svg",
                            width: iconSize + "",
                            height: iconSize + "",
                            childrenArr: [
                                {
                                    elementType: "path",
                                    fill: "none",
                                    stroke: "#000",
                                    style: `stroke-width: 0.12px; transform-origin: 0 0; transform: translate(-0.5px, -0.5px) scale(${actualIconSize}, ${actualIconSize}) translate(0.5px, 0.5px)`,
                                    d: "M 0,0 C 1.5,0 -0.5,1 1,1"
                                }, 
                            ]
                        }),
                        title: (0, _language.LANG)("brush-chemy-stroke")
                    }
                ],
                initId: brush.getMode(),
                onChange: (id)=>{
                    brush.setMode(id);
                    brushInterface.sizeSlider.isDisabled = brush.getMode() === "fill";
                    sizeSlider.setIsEnabled(!brushInterface.sizeSlider.isDisabled);
                    const brushSize = brush.getSize();
                    sizeSlider.setValue(brushSize);
                    p.onSizeChange(brushSize);
                    p.onConfigChange();
                }
            });
            const mirrorXToggle = new (0, _boxToggle.BoxToggle)({
                label: (0, _bb.BB).createSvg({
                    elementType: "svg",
                    width: iconSize + "",
                    height: iconSize + "",
                    childrenArr: [
                        {
                            elementType: "path",
                            fill: "none",
                            stroke: "#000",
                            style: "stroke-width: 1px",
                            d: `M ${halfSize + padding},${padding} ${halfSize + padding},${actualIconSize + padding}`
                        }, 
                    ]
                }),
                title: (0, _language.LANG)("brush-chemy-mirror-x"),
                init: brush.getXSymmetry(),
                onChange: (b)=>{
                    brush.setXSymmetry(b);
                }
            });
            const mirrorYToggle = new (0, _boxToggle.BoxToggle)({
                label: (0, _bb.BB).createSvg({
                    elementType: "svg",
                    width: iconSize + "",
                    height: iconSize + "",
                    childrenArr: [
                        {
                            elementType: "path",
                            fill: "none",
                            stroke: "#000",
                            style: "stroke-width: 1px",
                            d: `M ${padding},${halfSize + padding} ${actualIconSize + padding},${halfSize + padding}`
                        }, 
                    ]
                }),
                title: (0, _language.LANG)("brush-chemy-mirror-y"),
                init: brush.getYSymmetry(),
                onChange: (b)=>{
                    brush.setYSymmetry(b);
                }
            });
            const gradientToggle = new (0, _boxToggle.BoxToggle)({
                label: (0, _bb.BB).createSvg({
                    elementType: "svg",
                    width: iconSize + "",
                    height: iconSize + "",
                    childrenArr: [
                        {
                            elementType: "defs",
                            childrenArr: [
                                {
                                    elementType: "linearGradient",
                                    id: "gradient",
                                    x1: "0",
                                    y1: "0",
                                    x2: "0",
                                    y2: "1",
                                    childrenArr: [
                                        {
                                            elementType: "stop",
                                            offset: "0%",
                                            "stop-color": "rgba(0,0,0,0)"
                                        },
                                        {
                                            elementType: "stop",
                                            offset: "100%",
                                            "stop-color": "rgba(0,0,0,1)"
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            elementType: "rect",
                            fill: "url('#gradient')",
                            x: "" + padding,
                            y: "" + padding,
                            width: "" + actualIconSize,
                            height: "" + actualIconSize
                        }, 
                    ]
                }),
                title: (0, _language.LANG)("brush-chemy-gradient"),
                init: brush.getGradient(),
                onChange: (b)=>{
                    brush.setGradient(b);
                }
            });
            (0, _bb.BB).css(mirrorXToggle.getElement(), {
                marginLeft: "10px"
            });
            {
                const margin = {
                    marginLeft: "4px"
                };
                (0, _bb.BB).css(mirrorYToggle.getElement(), margin);
                (0, _bb.BB).css(gradientToggle.getElement(), margin);
            }
            toggleRow.append(modeOptions.getElement(), mirrorXToggle.getElement(), mirrorYToggle.getElement(), gradientToggle.getElement());
            div.append(sizeSlider.getElement(), opacitySlider.getElement(), toggleRow, (0, _bb.BB).el({
                content: [
                    lockAlphaToggle.getElement(),
                    eraserToggle.getElement(), 
                ],
                css: {
                    display: "flex"
                }
            }));
        }
        init();
        this.increaseSize = function(f) {
            if (!brush.getIsDrawing() && brush.getMode() === "stroke") sizeSlider.changeSliderValue(f);
        };
        this.decreaseSize = function(f) {
            if (!brush.getIsDrawing() && brush.getMode() === "stroke") sizeSlider.changeSliderValue(-f);
        };
        this.getSize = function() {
            return brush.getSize();
        };
        this.setSize = function(size) {
            setSize(size);
            sizeSlider.setValue(size);
        };
        this.getOpacity = function() {
            return brush.getOpacity();
        };
        this.setOpacity = function(opacity) {
            brush.setOpacity(opacity);
            opacitySlider.setValue(opacity);
        };
        this.setColor = function(c) {
            brush.setColor(c);
        };
        this.setContext = function(c) {
            brush.setContext(c);
        };
        this.startLine = function(x, y, p) {
            brush.startLine(x, y);
        };
        this.goLine = function(x, y, p, isCoalesced) {
            brush.goLine(x, y);
        };
        this.endLine = function() {
            brush.endLine();
        };
        this.getBrush = function() {
            return brush;
        };
        this.isDrawing = function() {
            return brush.getIsDrawing();
        };
        this.getElement = function() {
            return div;
        };
    };
    return brushInterface;
}();

},{"../../bb/bb":"dcQKo","./brushes-consts":"dlABn","../ui/base-components/checkbox":"kPAwM","../brushes/brushes":"8eOZC","../history/kl-history":"klzEn","../ui/base-components/kl-slider":"6YGce","url:~/src/app/img/ui/brush-chemy.svg":"lNIbx","../ui/base-components/options":"huqRY","../ui/base-components/box-toggle":"95ffn","../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lNIbx":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "brush-chemy.afd3e842.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"95ffn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BoxToggle", ()=>BoxToggle);
var _bb = require("../../../bb/bb");
class BoxToggle {
    update() {
        this.el.classList.toggle("kl-box-toggle--active", this.value);
    }
    // --- public ---
    constructor(p){
        this.value = !!p.init;
        this.el = (0, _bb.BB).el({
            content: p.label,
            title: p.title,
            className: typeof p.label === "string" ? "kl-box-toggle" : "kl-box-toggle kl-box-toggle--custom-el",
            onClick: ()=>{
                this.value = !this.value;
                this.update();
                p.onChange(this.value);
            },
            css: {
                cursor: "pointer"
            }
        });
        if (typeof p.label !== "string") (0, _bb.BB).css(p.label, {
            display: "block",
            pointerEvents: "none"
        });
        this.update();
    }
    getValue() {
        return this.value;
    }
    setValue(b) {
        this.value = !!b;
        this.update();
    }
    getElement() {
        return this.el;
    }
    destroy() {
        (0, _bb.BB).destroyEl(this.el);
    }
}

},{"../../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gD1Cf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "showIframePopup", ()=>showIframePopup);
var _bb = require("../../../bb/bb");
var _popup = require("./popup");
var _language = require("../../../language/language");
function showIframePopup(url, isEmbed) {
    if (!isEmbed && (window.innerHeight < 500 || window.innerWidth < 700)) {
        window.open(url);
        return;
    }
    let iframe = (0, _bb.BB).el({
        tagName: "iframe",
        custom: {
            src: url
        },
        css: {
            width: "100%",
            height: "100%"
        }
    });
    let titleEl = (0, _bb.BB).el({});
    let linkEl;
    if (!isEmbed) {
        linkEl = (0, _bb.BB).el({
            tagName: "a",
            parent: titleEl,
            content: (0, _language.LANG)("modal-new-tab"),
            custom: {
                href: "help",
                target: "_blank"
            },
            onClick: function() {
                popup.close();
            }
        });
        iframe.onload = function() {
            (0, _bb.BB).setAttributes(linkEl, {
                href: "" + iframe.contentWindow.location
            });
        };
    }
    let popup = new (0, _popup.Popup)({
        title: titleEl,
        content: iframe,
        width: 880,
        isMaxHeight: true,
        onClose: ()=>{
            if (linkEl) (0, _bb.BB).destroyEl(linkEl);
        }
    });
}

},{"../../../bb/bb":"dcQKo","./popup":"4Ltiz","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4jflC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RadioList", ()=>RadioList);
var _bb = require("../../../bb/bb");
class RadioList {
    inputs = [];
    constructor({ name , init , items , ignoreFocus  }){
        this.el = (0, _bb.BB).el({
            className: "kl-radio"
        });
        items.forEach((item)=>{
            let label = (0, _bb.BB).el({
                tagName: "label"
            });
            let input = (0, _bb.BB).el({
                tagName: "input",
                parent: label,
                custom: {
                    name: name,
                    value: item.value,
                    type: "radio"
                }
            });
            if (ignoreFocus) input.setAttribute("data-ignore-focus", "true");
            if (init === item.value) input.checked = true;
            label.append(item.label);
            this.el.append(label);
            this.inputs.push(input);
        });
    }
    getValue() {
        for(let i = 0; i < this.inputs.length; i++){
            if (this.inputs[i].checked) return this.inputs[i].value;
        }
        return null;
    }
    getElement() {
        return this.el;
    }
}

},{"../../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9u5bD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BrowserStorageUi", ()=>BrowserStorageUi);
var _bb = require("../../../bb/bb");
// @ts-ignore
var _removeLayerSvg = require("url:~/src/app/img/ui/remove-layer.svg");
var _removeLayerSvgDefault = parcelHelpers.interopDefault(_removeLayerSvg);
var _showIframePopup = require("../modals/show-iframe-popup");
var _kl = require("../../kl");
var _language = require("../../../language/language");
class BrowserStorageUi {
    updateAge() {
        if (!this.timestamp) return;
        let age = new Date().getTime() - this.timestamp;
        let ageStr;
        age = Math.floor(age / 1000 / 60);
        ageStr = (0, _language.LANG)("file-storage-min-ago").replace("{x}", "" + age);
        if (age > 60) {
            age = Math.floor(age / 60);
            ageStr = (0, _language.LANG)("file-storage-hours-ago").replace("{x}", "" + age);
            if (age > 24) {
                age = Math.floor(age / 24);
                ageStr = (0, _language.LANG)("file-storage-days-ago").replace("{x}", "" + age);
                if (age > 31) ageStr = (0, _language.LANG)("file-storage-month-ago");
            }
        }
        this.ageEl.textContent = ageStr;
    }
    resetButtons() {
        if (this.timestamp) {
            this.storeButtonEl.textContent = (0, _language.LANG)("file-storage-overwrite");
            this.storeButtonEl.disabled = false;
            this.clearButtonEl.disabled = false;
        } else {
            this.storeButtonEl.textContent = (0, _language.LANG)("file-storage-store");
            this.storeButtonEl.disabled = false;
            this.clearButtonEl.disabled = true;
        }
    }
    updateThumb(timestamp, thumbnail) {
        this.timestamp = timestamp;
        if (this.timestamp) {
            (0, _bb.BB).css(thumbnail, {
                display: "block",
                maxWidth: "calc(100% - 2px)",
                maxHeight: "calc(100% - 2px)",
                margin: "0 auto",
                background: "url('" + (0, _bb.BB).createCheckerCanvas(4).toDataURL("image/png") + "')",
                boxShadow: "0 0 0 1px #aaa",
                pointerEvents: "none"
            });
            this.previewEl.innerHTML = "";
            this.updateAge();
            this.previewEl.append(thumbnail, this.ageEl);
        } else this.previewEl.innerHTML = (0, _language.LANG)("file-storage-empty");
        this.resetButtons();
    }
    async store() {
        this.storeButtonEl.textContent = (0, _language.LANG)("file-storage-storing");
        this.storeButtonEl.disabled = true;
        this.clearButtonEl.disabled = true;
        await new Promise((resolve)=>{
            setTimeout(()=>resolve(null), 20);
        });
        try {
            await this.projectStore.store(this.getProject());
            this.saveReminder.reset();
        } catch (e) {
            this.resetButtons();
            (0, _kl.KL).popup({
                target: this.klRootEl,
                type: "error",
                message: [
                    `${(0, _language.LANG)("file-storage-failed-1")}<ul>`,
                    `<li>${(0, _language.LANG)("file-storage-failed-2")}</li>`,
                    `<li>${(0, _language.LANG)("file-storage-failed-3")}</li>`,
                    `<li>${(0, _language.LANG)("file-storage-failed-4")}</li>`,
                    `</ul>`, 
                ].join(""),
                buttons: [
                    "Ok"
                ]
            });
            setTimeout(()=>{
                throw new Error("storage-ui: failed to store browser storage, " + e);
            }, 0);
        }
    }
    async clear() {
        this.storeButtonEl.disabled = true;
        this.clearButtonEl.disabled = true;
        try {
            await this.projectStore.clear();
        } catch (e) {
            this.resetButtons();
            (0, _kl.KL).popup({
                target: this.klRootEl,
                type: "error",
                message: (0, _language.LANG)("file-storage-failed-clear"),
                buttons: [
                    "Ok"
                ]
            });
            setTimeout(()=>{
                throw new Error("storage-ui: failed to clear browser storage, " + e);
            }, 0);
        }
    }
    constructor(projectStore, getProject, saveReminder, klRootEl, options){
        this.projectStore = projectStore;
        this.getProject = getProject;
        this.saveReminder = saveReminder;
        this.klRootEl = klRootEl;
        this.options = options;
        this.element = (0, _bb.BB).el({
            css: {
                display: "grid",
                gridTemplateColumns: "1fr 0fr",
                gridTemplateRows: "0fr 0fr 0fr",
                gap: "0 0",
                gridTemplateAreas: '"title title" "preview store" "preview clear"'
            }
        });
        const title = (0, _bb.BB).el({
            parent: this.element,
            content: (0, _language.LANG)("file-storage"),
            css: {
                gridArea: "title",
                display: "flex",
                margin: "-5px 0"
            }
        });
        this.infoEl = (0, _bb.BB).el({
            parent: title,
            content: "?",
            title: (0, _language.LANG)("file-storage-about"),
            css: {
                cursor: "pointer",
                marginLeft: "5px",
                width: "19px",
                height: "19px",
                borderRadius: "100%",
                textAlign: "center",
                lineHeight: "19px",
                fontWeight: "bold",
                boxShadow: "inset 0 0 0 1px #000"
            },
            onClick: ()=>{
                (0, _showIframePopup.showIframePopup)("./help/#help-browser-storage", false);
            }
        });
        if (this.projectStore.isBroken()) {
            (0, _bb.BB).el({
                parent: this.element,
                content: "\uD83D\uDD34 " + (0, _language.LANG)("file-storage-cant-access"),
                css: {
                    marginTop: "10px"
                }
            });
            return;
        }
        this.previewEl = (0, _bb.BB).el({
            parent: this.element,
            title: (0, _language.LANG)("file-storage-thumb-title"),
            css: {
                gridArea: "preview",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                marginTop: "10px",
                position: "relative",
                boxShadow: "inset 0 0 0 1px #aaa",
                background: "#cdcdcd",
                color: "#545454",
                colorScheme: "only light",
                minHeight: "67px"
            }
        });
        this.ageEl = (0, _bb.BB).el({
            css: {
                position: "absolute",
                right: "0",
                bottom: "0",
                width: "100%",
                textAlign: "center",
                background: "rgba(0,0,0,0.7)",
                color: "#fff",
                textSize: "13px"
            }
        });
        const btnCustom = options?.isFocusable ? {} : {
            tabIndex: -1
        };
        this.storeButtonEl = (0, _bb.BB).el({
            parent: this.element,
            tagName: "button",
            className: "gridButton",
            content: (0, _language.LANG)("file-storage-store"),
            css: {
                gridArea: "store"
            },
            custom: btnCustom,
            onClick: ()=>this.store()
        });
        this.clearButtonEl = (0, _bb.BB).el({
            parent: this.element,
            tagName: "button",
            className: "gridButton",
            content: '<img src="' + (0, _removeLayerSvgDefault.default) + '" height="20"/> ' + (0, _language.LANG)("file-storage-clear"),
            css: {
                gridArea: "clear"
            },
            custom: btnCustom,
            onClick: ()=>this.clear()
        });
        if (this.options?.hideClearButton) this.clearButtonEl.style.visibility = "hidden";
        this.storeListener = {
            onUpdate: (timestamp, thumbnail)=>{
                this.updateThumb(timestamp, thumbnail);
            }
        };
        this.projectStore.subscribe(this.storeListener);
        setInterval(()=>this.updateAge(), 60000);
        (async ()=>{
            try {
                const readResult = await this.projectStore.read();
                if (readResult) this.updateThumb(readResult.timestamp, readResult.thumbnail);
                else this.updateThumb();
            } catch (e) {
                setTimeout(()=>{
                    throw new Error("storage-ui: failed initial read browser storage, " + e);
                }, 0);
            }
        })();
    }
    getElement() {
        return this.element;
    }
    show() {
    // todo
    }
    hide() {
    // todo
    }
    destroy() {
        (0, _bb.BB).destroyEl(this.infoEl);
        (0, _bb.BB).destroyEl(this.storeButtonEl);
        (0, _bb.BB).destroyEl(this.clearButtonEl);
        this.projectStore.unsubscribe(this.storeListener);
    }
}

},{"../../../bb/bb":"dcQKo","url:~/src/app/img/ui/remove-layer.svg":"cI4U0","../modals/show-iframe-popup":"gD1Cf","../../kl":"8nmWp","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gZHsZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * simplified interface for storing projects into browser storage
 */ parcelHelpers.export(exports, "ProjectStore", ()=>ProjectStore);
var _projectConverter = require("./project-converter");
var _indexedDb = require("./indexed-db");
var _localStorage = require("../../bb/base/local-storage");
function makeAsync(func) {
    return new Promise((resolve, reject)=>{
        func(resolve, reject);
    });
}
class ProjectStore {
    listeners = [];
    accessHasFailed = false;
    async lowLevelStore(project) {
        await new Promise((resolve, reject)=>{
            (0, _indexedDb.storeKlProjectObj)(project, resolve, reject);
        });
    }
    async lowLevelRead() {
        return await makeAsync((0, _indexedDb.getKlProjectObj));
    }
    async lowLevelClear() {
        await makeAsync((0, _indexedDb.clear));
    }
    emit(timestamp, thumbnail) {
        this.listeners.forEach((item)=>{
            item.onUpdate(timestamp, thumbnail);
        });
    }
    updateTimestamp() {
        (0, _localStorage.LocalStorage).setItem("indexedDbUpdatedAt", "" + new Date().getTime());
    }
    // --- public ---
    constructor(){
        window.addEventListener("storage", (e)=>{
            if (e.key !== "indexedDbUpdatedAt" || this.listeners.length === 0) return;
            try {
                (async ()=>{
                    const readResult = await this.read();
                    if (readResult) this.emit(readResult.timestamp, readResult.thumbnail);
                    else this.emit();
                })();
            } catch (e1) {
                if (e1.message.indexOf("db-error") === 0) this.accessHasFailed = true;
            }
        });
    }
    async read() {
        let storageProject;
        try {
            storageProject = await this.lowLevelRead();
        } catch (e) {
            this.accessHasFailed = true;
            throw new Error("db-error: " + e);
        }
        if (!storageProject) return null;
        let result;
        try {
            result = await (0, _projectConverter.ProjectConverter).readStorageProject(storageProject);
        } catch (e1) {
            throw new Error("format-error: " + e1);
        }
        return result;
    }
    async store(project) {
        try {
            const storageProject = (0, _projectConverter.ProjectConverter).createStorageProject(project);
            await this.lowLevelStore(storageProject);
        } catch (e) {
            this.accessHasFailed = true;
            throw new Error("db-error: " + e);
        }
        {
            // immediately test if it can be read
            const storageProject1 = await this.lowLevelRead();
            let readResult = null;
            try {
                readResult = await (0, _projectConverter.ProjectConverter).readStorageProject(storageProject1);
            } catch (e1) {
                await this.lowLevelClear();
                this.updateTimestamp();
                setTimeout(()=>this.emit(), 0);
                throw new Error("format-error: " + e1);
            }
            this.updateTimestamp();
            setTimeout(()=>this.emit(readResult.timestamp, readResult.thumbnail), 0);
        }
    }
    async clear() {
        await this.lowLevelClear();
        this.updateTimestamp();
        setTimeout(()=>this.emit(), 0);
    }
    subscribe(listener) {
        if (this.listeners.includes(listener)) return;
        this.listeners.push(listener);
    }
    unsubscribe(listener) {
        for(let i = 0; i < this.listeners.length; i++)if (listener === this.listeners[i]) {
            this.listeners.splice(i, 1);
            return;
        }
    }
    isBroken() {
        return this.accessHasFailed;
    }
}

},{"./project-converter":"jp97c","./indexed-db":"eCGtt","../../bb/base/local-storage":"04p5O","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jp97c":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * for:
 * - preparing project to be stored in ProjectStore
 * - reading a project that came out of the ProjectStore
 */ parcelHelpers.export(exports, "ProjectConverter", ()=>ProjectConverter);
var _bb = require("../../bb/bb");
var _drawProject = require("../canvas/draw-project");
var _base64ToBlob = require("./base-64-to-blob");
const thumbSize = 240;
function loadImage(blob) {
    return new Promise((resolve, reject)=>{
        const im = new Image();
        try {
            im.src = (0, _bb.BB).imageBlobToUrl(blob);
        } catch (e) {
            reject("imageBlobToUrl, " + e.message);
            return;
        }
        im.onload = ()=>{
            URL.revokeObjectURL(im.src);
            resolve(im);
        };
        im.onabort = function() {
            reject("layer image failed loading");
        };
        im.onerror = function() {
            reject("layer image failed loading");
        };
    });
}
class ProjectConverter {
    static createThumbnail(project) {
        const size = (0, _bb.BB).fitInto(project.width, project.height, thumbSize, thumbSize);
        const factor = size.width / project.width;
        return (0, _drawProject.drawProject)(project, factor);
    }
    static createStorageProject(project) {
        return {
            id: 1,
            timestamp: new Date().getTime(),
            thumbnail: (0, _base64ToBlob.base64ToBlob)(ProjectConverter.createThumbnail(project).toDataURL("image/png")),
            width: project.width,
            height: project.height,
            layers: project.layers.map((item)=>{
                let blob;
                if (item.image instanceof HTMLCanvasElement) blob = (0, _base64ToBlob.base64ToBlob)(item.image.toDataURL("image/png"));
                else // todo image
                throw new Error("Not implemented");
                return {
                    name: item.name,
                    opacity: item.opacity,
                    mixModeStr: item.mixModeStr,
                    blob
                };
            })
        };
    }
    static async readStorageProject(storageProject) {
        if (!storageProject.width || !storageProject.height || isNaN(storageProject.width) || isNaN(storageProject.height) || storageProject.width < 1 || storageProject.height < 1) throw new Error("readStorageProject invalid canvas size: " + storageProject.width + ", " + storageProject.height);
        const project = {
            width: storageProject.width,
            height: storageProject.height,
            layers: (await Promise.all(storageProject.layers.map((layer)=>loadImage(layer.blob)))).map((image, i)=>{
                return {
                    name: storageProject.layers[i].name,
                    opacity: storageProject.layers[i].opacity,
                    mixModeStr: storageProject.layers[i].mixModeStr,
                    image
                };
            })
        };
        let thumbnail;
        if (storageProject.thumbnail) thumbnail = await loadImage(storageProject.thumbnail);
        else thumbnail = ProjectConverter.createThumbnail(project);
        return {
            project: project,
            timestamp: storageProject.timestamp,
            thumbnail: thumbnail
        };
    }
}

},{"../../bb/bb":"dcQKo","../canvas/draw-project":"6Yf6D","./base-64-to-blob":"4JT2T","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4JT2T":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "base64ToBlob", ()=>base64ToBlob);
function base64ToBlob(base64Str) {
    let parts = base64Str.match(/data:([^;]*)(;base64)?,([0-9A-Za-z+/]+)/);
    let binStr = atob(parts[3]);
    let buf = new ArrayBuffer(binStr.length);
    let view = new Uint8Array(buf);
    for(let i = 0; i < view.length; i++)view[i] = binStr.charCodeAt(i);
    return new Blob([
        view
    ], {
        "type": parts[1]
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3rIr5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FileTab", ()=>FileTab);
var _bb = require("../../../bb/bb");
var _kl = require("../../kl");
// @ts-ignore
var _newImageSvg = require("url:~/src/app/img/ui/new-image.svg");
var _newImageSvgDefault = parcelHelpers.interopDefault(_newImageSvg);
// @ts-ignore
var _exportSvg = require("url:~/src/app/img/ui/export.svg");
var _exportSvgDefault = parcelHelpers.interopDefault(_exportSvg);
// @ts-ignore
var _shareSvg = require("url:~/src/app/img/ui/share.svg");
var _shareSvgDefault = parcelHelpers.interopDefault(_shareSvg);
// @ts-ignore
var _uploadSvg = require("url:~/src/app/img/ui/upload.svg");
var _uploadSvgDefault = parcelHelpers.interopDefault(_uploadSvg);
// @ts-ignore
var _importSvg = require("url:~/src/app/img/ui/import.svg");
var _importSvgDefault = parcelHelpers.interopDefault(_importSvg);
// @ts-ignore
var _copySvg = require("url:~/src/app/img/ui/copy.svg");
var _copySvgDefault = parcelHelpers.interopDefault(_copySvg);
var _browserStorageUi = require("../components/browser-storage-ui");
var _language = require("../../../language/language");
class FileTab {
    constructor(klRootEl, projectStore, getProject, exportType, onExportTypeChange, onFileSelect, onSaveImageToComputer, onNewImage, onShareImage, onUpload, onCopyToClipboard, saveReminder){
        this.exportType = exportType;
        const _this = this;
        this.div = document.createElement("div");
        const asyncCreation = ()=>{
            let filemenu = document.createElement("div");
            let newButton = document.createElement("button");
            let saveButton = document.createElement("button");
            let shareButton = document.createElement("button");
            let uploadImgurButton = document.createElement("button");
            let clipboardButton = document.createElement("button");
            newButton.style.cssFloat = "left";
            (0, _bb.BB).css(saveButton, {
                cssFloat: "left",
                clear: "both"
            });
            (0, _bb.BB).css(clipboardButton, {
                cssFloat: "left",
                clear: "both"
            });
            newButton.tabIndex = -1;
            saveButton.tabIndex = -1;
            shareButton.tabIndex = -1;
            uploadImgurButton.tabIndex = -1;
            clipboardButton.tabIndex = -1;
            newButton.innerHTML = `<img src='${0, _newImageSvgDefault.default}' alt='icon' height='20'/>${(0, _language.LANG)("file-new")}`;
            saveButton.innerHTML = `<img src='${0, _exportSvgDefault.default}' alt='icon' height='20'/>${(0, _language.LANG)("file-save")}`;
            shareButton.innerHTML = `<img src='${0, _shareSvgDefault.default}' alt='icon' height='20'/>${(0, _language.LANG)("file-share")}`;
            uploadImgurButton.innerHTML = `<img style='float:left' src='${0, _uploadSvgDefault.default}' height='20' alt='icon'/>${(0, _language.LANG)("file-upload")}`;
            clipboardButton.innerHTML = `<img src='${0, _copySvgDefault.default}' alt='icon' height='20'/>${(0, _language.LANG)("file-copy")}`;
            clipboardButton.title = (0, _language.LANG)("file-copy-title");
            newButton.className = "gridButton";
            saveButton.className = "gridButton";
            shareButton.className = "gridButton";
            uploadImgurButton.className = "gridButton";
            clipboardButton.className = "gridButton";
            this.importButton = document.createElement("input");
            this.importButton.tabIndex = -1;
            this.importButton.type = "file";
            this.importButton.multiple = true;
            this.importButton.accept = "image";
            this.importButton.size = "71";
            this.importButton.textContent = "Import";
            let importWrapper = this.importButton;
            function createImportButton() {
                importWrapper = document.createElement("div");
                importWrapper.className = "gridButton";
                importWrapper.style.position = "relative";
                importWrapper.style.cursor = "pointer";
                importWrapper.style.cssFloat = "left";
                let innerMask = document.createElement("div");
                innerMask.style.width = "120px";
                innerMask.style.height = "28px";
                innerMask.style.overflow = "hidden";
                innerMask.style.cursor = "pointer";
                innerMask.style.position = "relative";
                importWrapper.appendChild(innerMask);
                innerMask.appendChild(_this.importButton);
                let importFakeButton = document.createElement("button");
                importFakeButton.innerHTML = "<img style='float:left' height='20' src='" + (0, _importSvgDefault.default) + "' alt='icon'/>" + (0, _language.LANG)("file-import");
                importFakeButton.tabIndex = -1;
                (0, _bb.BB).css(importFakeButton, {
                    width: "120px",
                    display: "box",
                    position: "absolute",
                    left: "0",
                    top: "0",
                    cursor: "pointer"
                });
                (0, _bb.BB).css(_this.importButton, {
                    display: "none"
                });
                importWrapper.appendChild(importFakeButton);
                importFakeButton.onclick = function() {
                    _this.importButton.click();
                };
            }
            createImportButton();
            this.importButton.onchange = function(e) {
                onFileSelect(_this.importButton.files, "default");
                _this.importButton.value = "";
            };
            // --- export filetype dropdown ---
            let exportTypeWrapper;
            let exportTypeSelect;
            exportTypeWrapper = (0, _bb.BB).el({
                css: {
                    fontSize: "15px",
                    marginLeft: "10px",
                    marginTop: "10px",
                    cssFloat: "left",
                    width: "calc(50% - 15px)",
                    height: "30px"
                }
            });
            exportTypeSelect = new (0, _kl.KL).Select({
                optionArr: [
                    [
                        "png",
                        (0, _language.LANG)("file-save-png")
                    ],
                    [
                        "psd",
                        (0, _language.LANG)("file-save-psd")
                    ],
                    [
                        "layers",
                        (0, _language.LANG)("file-save-layers")
                    ], 
                ],
                initValue: exportType,
                onChange: function(val) {
                    exportType = val;
                    onExportTypeChange(exportType);
                    onSaveImageToComputer();
                }
            });
            (0, _bb.BB).css(exportTypeSelect.getElement(), {
                width: "120px",
                height: "30px"
            });
            exportTypeWrapper.appendChild(exportTypeSelect.getElement());
            newButton.onclick = onNewImage;
            saveButton.onclick = function() {
                onSaveImageToComputer();
            };
            shareButton.onclick = function() {
                shareButton.disabled = true;
                onShareImage(()=>{
                    shareButton.disabled = false;
                });
            };
            uploadImgurButton.onclick = function() {
                onUpload();
            };
            clipboardButton.onclick = function() {
                clipboardButton.blur();
                onCopyToClipboard();
            };
            let saveNote = document.createElement("div");
            saveNote.textContent = "‚ö†Ô∏è " + (0, _language.LANG)("file-no-autosave");
            (0, _bb.BB).css(saveNote, {
                textAlign: "center",
                marginTop: "10px",
                background: "rgb(243, 243, 161)",
                padding: "5px 0px",
                color: "rgba(0,0,0,0.65)",
                fontSize: "15px"
            });
            function createSpacer() {
                let el = document.createElement("div");
                let clearer = document.createElement("div");
                let line = document.createElement("div");
                el.appendChild(clearer);
                el.appendChild(line);
                (0, _bb.BB).css(clearer, {
                    clear: "both"
                });
                (0, _bb.BB).css(line, {
                    marginLeft: "10px",
                    marginRight: "10px",
                    marginTop: "10px",
                    borderBottom: "1px solid rgba(0,0,0,0.2)",
                    clear: "both"
                });
                return el;
            }
            _this.fileBrowserStorage = new (0, _browserStorageUi.BrowserStorageUi)(projectStore, getProject, saveReminder, klRootEl);
            (0, _bb.BB).css(_this.fileBrowserStorage.getElement(), {
                //background: 'red',
                margin: "10px"
            });
            //actual structure
            (0, _bb.BB).append(filemenu, [
                saveNote,
                newButton,
                importWrapper,
                (0, _bb.BB).el({
                    css: {
                        clear: "both"
                    }
                }),
                saveButton,
                exportTypeWrapper,
                (0, _bb.BB).el({
                    css: {
                        clear: "both"
                    }
                }),
                clipboardButton,
                (0, _bb.BB).canShareFiles() ? shareButton : null,
                (0, _bb.BB).el({
                    css: {
                        clear: "both"
                    }
                }),
                createSpacer(),
                _this.fileBrowserStorage.getElement(),
                createSpacer(),
                uploadImgurButton, 
            ]);
            this.div.appendChild(filemenu);
        };
        setTimeout(asyncCreation, 1);
    }
    refresh() {}
    getElement() {
        return this.div;
    }
    setIsVisible(isVisible) {
        if (isVisible) this.refresh();
    }
    triggerImport() {
        this.importButton.click();
    }
}

},{"../../../bb/bb":"dcQKo","../../kl":"8nmWp","url:~/src/app/img/ui/new-image.svg":"gt6Bq","url:~/src/app/img/ui/export.svg":"cLBbh","url:~/src/app/img/ui/share.svg":"kDtoI","url:~/src/app/img/ui/upload.svg":"9iG1B","url:~/src/app/img/ui/import.svg":"6FpPK","url:~/src/app/img/ui/copy.svg":"fWmY4","../components/browser-storage-ui":"9u5bD","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9iG1B":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "upload.48a9c420.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"ftyCZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FilterTab", ()=>FilterTab);
var _bb = require("../../../bb/bb");
var _kl = require("../../kl");
var _klHistory = require("../../history/kl-history");
var _language = require("../../../language/language");
class FilterTab {
    constructor(klRootEl, klColorSlider, layerManager, klCanvasWorkspace, handUi, getCurrentColor, getKlMaxCanvasSize, getKlCanvas, getCurrentLayerCtx, isEmbed, statusOverlay){
        this.klRootEl = klRootEl;
        this.klColorSlider = klColorSlider;
        this.layerManager = layerManager;
        this.klCanvasWorkspace = klCanvasWorkspace;
        this.handUi = handUi;
        this.getCurrentColor = getCurrentColor;
        this.getKlMaxCanvasSize = getKlMaxCanvasSize;
        this.getKlCanvas = getKlCanvas;
        this.getCurrentLayerCtx = getCurrentLayerCtx;
        this.isEmbed = isEmbed;
        this.statusOverlay = statusOverlay;
        this.isInit = false;
        this.div = document.createElement("div");
    }
    init() {
        const _this = this;
        let filters = (0, _kl.KL).filterLib;
        let buttons = [];
        (0, _bb.BB).BbLog.emit({
            type: "init-filters"
        });
        if (!(0, _kl.KL).filterLibStatus.isLoaded) throw new Error("filters not loaded");
        function createButton(filterKey, filterArr) {
            let button = document.createElement("button");
            let buttonLabel = (0, _language.LANG)(filterArr[filterKey].lang.button);
            let im = '<img height="20" width="18" src="' + filterArr[filterKey].icon + '" alt="icon" />';
            button.innerHTML = im + buttonLabel;
            button.className = "gridButton";
            (0, _bb.BB).css(button, {
                lineHeight: "20px",
                fontSize: "12px"
            });
            button.tabIndex = -1;
            const filterName = (0, _language.LANG)(filterArr[filterKey].lang.name);
            button.onclick = function() {
                function finishedDialog(result, filterDialog) {
                    if (result == "Cancel") {
                        if (filterDialog.destroy) filterDialog.destroy();
                        return;
                    }
                    let input;
                    try {
                        input = filterDialog.getInput(); // also destroys
                    } catch (e) {
                        if (e.message.indexOf(".getInput is not a function") !== -1) throw "filterDialog.getInput is not a function, filter: " + filterName;
                        else throw e;
                    }
                    applyFilter(input);
                }
                if (!("apply" in filterArr[filterKey])) {
                    alert("Application not fully loaded");
                    return;
                }
                function applyFilter(input) {
                    let filterResult = filterArr[filterKey].apply({
                        context: _this.getCurrentLayerCtx(),
                        klCanvas: _this.getKlCanvas(),
                        history: (0, _klHistory.klHistory),
                        input: input
                    });
                    if (filterResult === false) alert("Couldn't apply the edit action");
                    /*
                     _this.setCurrentLayer(_this.getKlCanvas().getLayer(_this.layerManager.getSelected()));
                    */ if (filterArr[filterKey].updatePos === true) {
                        _this.klCanvasWorkspace.resetView();
                        _this.handUi.update(_this.klCanvasWorkspace.getScale(), _this.klCanvasWorkspace.getAngleDeg());
                    }
                    _this.layerManager.update();
                }
                if (filterArr[filterKey].isInstant) {
                    button.blur();
                    applyFilter(null);
                    _this.statusOverlay.out('"' + filterName + '" ' + (0, _language.LANG)("filter-applied"), true);
                } else {
                    let secondaryColorRGB = _this.klColorSlider.getSecondaryRGB();
                    let filterDialog = filterArr[filterKey].getDialog({
                        context: _this.getCurrentLayerCtx(),
                        klCanvas: _this.getKlCanvas(),
                        maxWidth: _this.getKlMaxCanvasSize(),
                        maxHeight: _this.getKlMaxCanvasSize(),
                        currentColorRgb: {
                            r: _this.getCurrentColor().r,
                            g: _this.getCurrentColor().g,
                            b: _this.getCurrentColor().b
                        },
                        secondaryColorRgb: {
                            r: secondaryColorRGB.r,
                            g: secondaryColorRGB.g,
                            b: secondaryColorRGB.b
                        }
                    });
                    if (!filterDialog) return;
                    let closefunc;
                    // Todo should move into getDialogParams
                    filterDialog.errorCallback = function(e) {
                        setTimeout(function() {
                            alert("Error: could not perform action");
                            throw e;
                        }, 0);
                        closefunc();
                    };
                    let style = {};
                    if ("width" in filterDialog) style.width = filterDialog.width + "px";
                    (0, _kl.KL).popup({
                        target: _this.klRootEl,
                        message: "<b>" + filterName + "</b>",
                        div: filterDialog.element,
                        style: style,
                        buttons: [
                            "Ok",
                            "Cancel"
                        ],
                        clickOnEnter: "Ok",
                        callback: function(result) {
                            finishedDialog(result, filterDialog);
                        },
                        closefunc: function(func) {
                            closefunc = func;
                        }
                    });
                }
            };
            buttons[buttons.length] = button;
            return button;
        }
        function addGroup(groupArr, filterArr, targetEl) {
            for(let filterKey in filterArr){
                if (filterArr.hasOwnProperty[filterKey] || !groupArr.includes(filterKey)) continue;
                if (_this.isEmbed && !filterArr[filterKey].inEmbed) continue;
                targetEl.appendChild(createButton(filterKey, filterArr));
            }
        }
        const groupA = [
            "cropExtend",
            "flip",
            "perspective",
            "resize",
            "rotate",
            "transform", 
        ];
        const groupB = [
            "brightnessContrast",
            "curves",
            "distort",
            "hueSaturation",
            "invert",
            "tiltShift",
            "toAlpha",
            "blur",
            "unsharpMask", 
        ];
        const groupC = [
            "grid",
            "noise",
            "pattern",
            "vanishPoint"
        ];
        addGroup(groupA, filters, _this.div);
        _this.div.appendChild((0, _bb.BB).el({
            className: "gridHr"
        }));
        addGroup(groupB, filters, _this.div);
        _this.div.appendChild((0, _bb.BB).el({
            className: "gridHr"
        }));
        addGroup(groupC, filters, _this.div);
        this.isInit = true;
    }
    getElement() {
        return this.div;
    }
    show() {
        if (!this.isInit) this.init();
        this.div.style.display = "block";
    }
    hide() {
        this.div.style.display = "none";
    }
}

},{"../../../bb/bb":"dcQKo","../../kl":"8nmWp","../../history/kl-history":"klzEn","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cZn9c":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "imgurUpload", ()=>imgurUpload);
var _bb = require("../../../bb/bb");
var _kl = require("../../kl");
// @ts-ignore
var _loadingGif = require("url:~/src/app/img/ui/loading.gif");
var _loadingGifDefault = parcelHelpers.interopDefault(_loadingGif);
var _base64ToBlob = require("../../storage/base-64-to-blob");
var _language = require("../../../language/language");
async function upload(canvas, title, description, type, imgurKey) {
    let img = (0, _base64ToBlob.base64ToBlob)(canvas.toDataURL("image/" + type));
    let w = window.open();
    let label = w.document.createElement("div");
    let gif = w.document.createElement("img");
    gif.src = (0, _loadingGifDefault.default);
    label.appendChild(gif);
    (0, _bb.BB).css(gif, {
        filter: "invert(1)"
    });
    w.document.body.style.backgroundColor = "#121211";
    w.document.body.style.backgroundImage = "linear-gradient(#2b2b2b 0%, #121211 50%)";
    w.document.body.style.backgroundRepeat = "no-repeat";
    let labelText = w.document.createElement("div");
    labelText.style.marginTop = "10px";
    label.appendChild(labelText);
    labelText.textContent = (0, _language.LANG)("upload-uploading");
    w.document.body.appendChild(label);
    (0, _bb.BB).css(label, {
        marginLeft: "auto",
        marginRight: "auto",
        marginTop: "100px",
        fontFamily: "Arial, sans-serif",
        fontSize: "20px",
        textAlign: "center",
        transition: "opacity 0.3s ease-in-out",
        opacity: "0",
        color: "#ccc"
    });
    setTimeout(function() {
        label.style.opacity = "1";
    }, 20);
    let response;
    try {
        const formData = new FormData();
        formData.append("title", title);
        formData.append("description", description);
        formData.append("image", img);
        response = await fetch("https://api.imgur.com/3/image", {
            method: "POST",
            headers: {
                Authorization: "Client-ID " + imgurKey
            },
            body: formData
        });
    } catch (e) {
        w.close();
        throw new Error(e);
    }
    if (!response.ok) {
        w.close();
        throw new Error();
    }
    let data = (await response.json()).data;
    w.location.href = data.link.replace(/\.(jpg|png)/, "");
    return data;
}
function imgurUpload(klCanvas, klRootEl, saveReminder, imgurKey) {
    if (!imgurKey) throw new Error("imgur key missing");
    let inputTitle = document.createElement("input");
    inputTitle.type = "text";
    inputTitle.value = (0, _language.LANG)("upload-title-untitled");
    let inputDescription = (0, _bb.BB).el({
        tagName: "textarea",
        custom: {
            rows: 2
        },
        css: {
            width: "100%",
            maxWidth: "100%"
        }
    });
    let labelTitle = document.createElement("div");
    labelTitle.textContent = (0, _language.LANG)("upload-name") + ":";
    let labelDescription = (0, _bb.BB).el({
        content: (0, _language.LANG)("upload-caption") + ":",
        css: {
            marginTop: "10px"
        }
    });
    let tos = document.createElement("div");
    tos.innerHTML = `<br/><a href="https://imgur.com/tos" target="_blank" rel="noopener noreferrer">${(0, _language.LANG)("upload-tos")}</a> ${(0, _language.LANG)("upload-tos-2")}`;
    const typeRadio = new (0, _kl.KL).RadioList({
        name: "filetype",
        init: "jpeg",
        items: [
            {
                label: "JPG",
                value: "jpeg"
            },
            {
                label: "PNG",
                value: "png"
            }, 
        ],
        ignoreFocus: true
    });
    (0, _bb.BB).css(typeRadio.getElement(), {
        marginBottom: "10px"
    });
    let outDiv = document.createElement("div");
    let infoHint = document.createElement("div");
    infoHint.className = "info-hint";
    infoHint.textContent = (0, _language.LANG)("upload-link-notice");
    outDiv.append(infoHint, typeRadio.getElement(), labelTitle, inputTitle, labelDescription, inputDescription, tos);
    (0, _kl.KL).popup({
        target: klRootEl,
        message: `<b>${(0, _language.LANG)("upload-title")}</b>`,
        type: "upload",
        div: outDiv,
        buttons: [
            (0, _language.LANG)("upload-submit"),
            "Cancel"
        ],
        clickOnEnter: (0, _language.LANG)("upload-submit"),
        primaries: [
            (0, _language.LANG)("upload-submit")
        ],
        autoFocus: (0, _language.LANG)("upload-submit"),
        callback: async function(val) {
            if (val === (0, _language.LANG)("upload-submit") || val === "Yes" || val === "Ok") try {
                const result = await upload(klCanvas.getCompleteCanvas(1), inputTitle.value, inputDescription.value, typeRadio.getValue(), imgurKey);
                (0, _kl.KL).popup({
                    target: klRootEl,
                    type: "ok",
                    message: `<h3>${(0, _language.LANG)("upload-success")}</h3><br>${(0, _language.LANG)("upload-delete")}<br><a target='_blank' rel="noopener noreferrer" href='https://imgur.com/delete/${result.deletehash}'>imgur.com/delete/${result.deletehash}</a><br><br>`,
                    buttons: [
                        "Ok"
                    ]
                });
                saveReminder.reset();
            } catch (e) {
                (0, _kl.KL).popup({
                    target: klRootEl,
                    type: "error",
                    message: (0, _language.LANG)("upload-failed"),
                    buttons: [
                        "Ok"
                    ]
                });
            }
        }
    });
}

},{"../../../bb/bb":"dcQKo","../../kl":"8nmWp","url:~/src/app/img/ui/loading.gif":"8QkLB","../../storage/base-64-to-blob":"4JT2T","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8QkLB":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "loading.cfc18193.gif" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"kPUiJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "loadAgPsd", ()=>loadAgPsd);
var _bb = require("../../bb/bb");
let agPsdLazy;
async function loadAgPsd() {
    if (!agPsdLazy) {
        agPsdLazy = await require("499b4e816e225738");
        (0, _bb.BB).BbLog.emit({
            type: "loaded-agpsd"
        });
    }
    return agPsdLazy;
}

},{"../../bb/bb":"dcQKo","499b4e816e225738":"75zf2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"75zf2":[function(require,module,exports) {
module.exports = require("./helpers/browser/js-loader")(require("./helpers/bundle-url").getBundleURL("d3gnI") + "dist.d00432e1.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root("7dPZz"));

},{"./helpers/browser/js-loader":"61B45","./helpers/bundle-url":"lgJ39"}],"i5Pgf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * remind user of saving, keep user aware of save state
 */ parcelHelpers.export(exports, "SaveReminder", ()=>SaveReminder);
var _kl = require("../../kl");
var _bb = require("../../../bb/bb");
var _language = require("../../../language/language");
var _browserStorageUi = require("./browser-storage-ui");
const reminderTimelimitMs = 1200000; // 20 minutes
const unsavedActionsLimit = 100; // number of actions user did since last save
class SaveReminder {
    showPopup() {
        if (!this.projectStore || !this.getProject) throw new Error("projectStore and getProject need to be set");
        const min = Math.round((performance.now() - this.lastSavedAt) / 1000 / 60);
        const contentEl = (0, _bb.BB).el({});
        contentEl.append((0, _bb.BB).el({
            content: (0, _language.LANG)("save-reminder-text", {
                a: "<strong>" + min,
                b: "</strong>"
            }),
            css: {
                marginBottom: "20px"
            }
        }));
        const psdWrapper = (0, _bb.BB).el({
            css: {
                borderTop: "1px solid #aaa",
                margin: "0 -20px",
                padding: "20px"
            }
        });
        const storageWrapper = (0, _bb.BB).el({
            css: {
                borderTop: "1px solid #aaa",
                margin: "0 -20px",
                padding: "20px",
                paddingBottom: "0"
            }
        });
        contentEl.append(psdWrapper, storageWrapper);
        const psdBtn = (0, _bb.BB).el({
            tagName: "button",
            className: "kl-button",
            content: (0, _language.LANG)("save-reminder-save-psd"),
            onClick: ()=>this.onSaveAsPsd()
        });
        psdWrapper.append(psdBtn, (0, _bb.BB).el({
            content: (0, _language.LANG)("save-reminder-psd-layers"),
            css: {
                marginTop: "10px"
            }
        }));
        const storageUi = new (0, _browserStorageUi.BrowserStorageUi)(this.projectStore, this.getProject, this, document.body, {
            hideClearButton: true,
            isFocusable: true
        });
        storageWrapper.append(storageUi.getElement());
        (0, _kl.KL).popup({
            target: document.body,
            message: `<b>${(0, _language.LANG)("save-reminder-title")}</b>`,
            div: contentEl,
            ignoreBackground: true,
            callback: ()=>{
                storageUi.destroy();
                (0, _bb.BB).destroyEl(psdBtn);
                this.closeFunc = null;
                this.lastReminderShownAt = performance.now();
            },
            closefunc: (f)=>{
                this.closeFunc = f;
            }
        });
        setTimeout(()=>{
            psdBtn.focus();
        }, 40);
    }
    constructor(history, showReminder, changeTitle, onSaveAsPsd, isDrawing, projectStore, getProject, title = "Klecks"){
        this.history = history;
        this.showReminder = showReminder;
        this.changeTitle = changeTitle;
        this.onSaveAsPsd = onSaveAsPsd;
        this.isDrawing = isDrawing;
        this.projectStore = projectStore;
        this.getProject = getProject;
        this.title = title;
        this.lastSavedActionNumber = null;
    }
    init() {
        if (this.lastSavedActionNumber !== null) return;
        this.lastSavedActionNumber = this.history.getActionNumber();
        this.lastReminderShownAt = performance.now();
        this.lastSavedAt = performance.now();
        if (this.showReminder) setInterval(()=>{
            if (document.visibilityState !== "visible") return;
            let unsavedActions = Math.abs(this.history.getActionNumber() - this.lastSavedActionNumber);
            if ((0, _kl.KL).dialogCounter.get() === 0 && !this.isDrawing() && this.lastReminderShownAt + reminderTimelimitMs < performance.now() && unsavedActions >= unsavedActionsLimit) this.showPopup();
        }, 5000);
        // confirmation dialog when closing tab
        function onBeforeUnload(e) {
            e.preventDefault();
            e.returnValue = "";
        }
        this.history.addListener(()=>{
            let actionNumber = this.history.getActionNumber();
            if (this.lastSavedActionNumber !== actionNumber) (0, _bb.BB).setEventListener(window, "onbeforeunload", onBeforeUnload);
            else (0, _bb.BB).setEventListener(window, "onbeforeunload", null);
        });
        if (this.changeTitle) document.addEventListener("visibilitychange", ()=>{
            if (document.visibilityState === "visible") {
                document.title = this.title;
                clearInterval(this.unsavedInterval);
            } else {
                let actionNumber = this.history.getActionNumber();
                if (this.lastSavedActionNumber !== actionNumber) {
                    document.title = (0, _language.LANG)("unsaved") + " - " + this.title;
                    let state = 0;
                    this.unsavedInterval = setInterval(()=>{
                        state = (state + 1) % 2;
                        if (state === 1) document.title = (0, _language.LANG)("unsaved") + " \xb7 " + this.title;
                        else document.title = (0, _language.LANG)("unsaved") + " - " + this.title;
                    }, 180000);
                }
            }
        });
    }
    reset() {
        if (this.lastSavedActionNumber === null) return;
        this.lastSavedActionNumber = this.history.getActionNumber();
        this.lastReminderShownAt = performance.now();
        this.lastSavedAt = performance.now();
        (0, _bb.BB).setEventListener(window, "onbeforeunload", null);
        if (this.closeFunc) this.closeFunc();
    }
}

},{"../../kl":"8nmWp","../../../bb/bb":"dcQKo","../../../language/language":"iiYGN","./browser-storage-ui":"9u5bD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"axnPV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SaveToComputer", ()=>SaveToComputer);
var _bb = require("../../bb/bb");
var _kl = require("../kl");
var _fileSaver = require("file-saver");
class SaveToComputer {
    constructor(saveReminder, klRootEl, getExportType, getKlCanvas, filenameBase){
        this.saveReminder = saveReminder;
        this.klRootEl = klRootEl;
        this.getExportType = getExportType;
        this.getKlCanvas = getKlCanvas;
        this.filenameBase = filenameBase;
    }
    save(format) {
        const _this = this;
        _this.saveReminder.reset();
        function saveImage(canvas, filename, mimeType) {
            let parts = canvas.toDataURL(mimeType).match(/data:([^;]*)(;base64)?,([0-9A-Za-z+/]+)/);
            //assume base64 encoding
            let binStr = atob(parts[3]);
            //convert to binary in ArrayBuffer
            let buf = new ArrayBuffer(binStr.length);
            let view = new Uint8Array(buf);
            for(let i = 0; i < view.length; i++)view[i] = binStr.charCodeAt(i);
            let blob = new Blob([
                view
            ], {
                "type": parts[1]
            });
            (0, _fileSaver.saveAs)(blob, filename);
        }
        if (!format) format = _this.getExportType();
        if (format === "png") {
            let extension = "png";
            let mimeType = "image/png";
            let filename = (0, _bb.BB).getDate() + this.filenameBase + "." + extension;
            let fullCanvas = _this.getKlCanvas().getCompleteCanvas(1);
            /*fullCanvas.toBlob(function(blob) {
                if (blob === null) {
                    throw 'save image error, blob is null';
                }
                saveAs(blob, filename);
            }, mimetype);*/ //using old code, because saving somehow doesn't work for ipad before ios 13
            //and it doesn't even throw an exception
            try {
                saveImage(fullCanvas, filename, mimeType);
            } catch (error) {
                let im = new Image();
                im.width = _this.getKlCanvas().getWidth();
                im.height = _this.getKlCanvas().getHeight();
                im.src = fullCanvas.toDataURL(mimeType);
                (0, _kl.KL).exportDialog(_this.klRootEl, im);
            }
        } else if (format === "layers") {
            let extension1 = "png";
            let mimeType1 = "image/png";
            let fileBase = (0, _bb.BB).getDate() + this.filenameBase;
            let layerArr = _this.getKlCanvas().getLayersFast();
            for(let i = 0; i < layerArr.length; i++){
                let item = layerArr[i];
                let fnameArr = [
                    fileBase,
                    "_",
                    ("" + (i + 1)).padStart(2, "0"),
                    "_",
                    item.name,
                    ".",
                    extension1
                ];
                saveImage(item.canvas, fnameArr.join(""), mimeType1);
            }
        } else if (format === "psd") {
            let layerArr1 = _this.getKlCanvas().getLayersFast();
            let psdConfig = {
                width: _this.getKlCanvas().getWidth(),
                height: _this.getKlCanvas().getHeight(),
                children: [],
                canvas: _this.getKlCanvas().getCompleteCanvas(1)
            };
            for(let i1 = 0; i1 < layerArr1.length; i1++){
                let item1 = layerArr1[i1];
                psdConfig.children.push({
                    name: item1.name,
                    opacity: item1.opacity,
                    canvas: item1.canvas,
                    blendMode: (0, _kl.KL).PSD.blendKlToPsd(item1.mixModeStr),
                    left: 0,
                    top: 0
                });
            }
            (0, _kl.KL).loadAgPsd().then((agPsdLazy)=>{
                let buffer = agPsdLazy.writePsdBuffer(psdConfig);
                let blob = new Blob([
                    buffer
                ], {
                    type: "application/octet-stream"
                });
                (0, _fileSaver.saveAs)(blob, (0, _bb.BB).getDate() + this.filenameBase + ".psd");
            }).catch(()=>{
                alert("Error: failed to load PSD library");
            });
        }
    }
}

},{"../../bb/bb":"dcQKo","../kl":"8nmWp","file-saver":"3ILQE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3ILQE":[function(require,module,exports) {
var global = arguments[3];
(function(a, b) {
    if ("function" == typeof define && define.amd) define([], b);
    else b();
})(this, function() {
    "use strict";
    function b(a, b) {
        return "undefined" == typeof b ? b = {
            autoBom: !1
        } : "object" != typeof b && (console.warn("Deprecated: Expected third argument to be a object"), b = {
            autoBom: !b
        }), b.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type) ? new Blob([
            "\uFEFF",
            a
        ], {
            type: a.type
        }) : a;
    }
    function c(a, b, c) {
        var d = new XMLHttpRequest;
        d.open("GET", a), d.responseType = "blob", d.onload = function() {
            g(d.response, b, c);
        }, d.onerror = function() {
            console.error("could not download file");
        }, d.send();
    }
    function d(a) {
        var b = new XMLHttpRequest;
        b.open("HEAD", a, !1);
        try {
            b.send();
        } catch (a1) {}
        return 200 <= b.status && 299 >= b.status;
    }
    function e(a) {
        try {
            a.dispatchEvent(new MouseEvent("click"));
        } catch (c) {
            var b = document.createEvent("MouseEvents");
            b.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), a.dispatchEvent(b);
        }
    }
    var f = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof global && global.global === global ? global : void 0, a = f.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g = f.saveAs || ("object" != typeof window || window !== f ? function() {} : "download" in HTMLAnchorElement.prototype && !a ? function(b, g, h) {
        var i = f.URL || f.webkitURL, j = document.createElement("a");
        g = g || b.name || "download", j.download = g, j.rel = "noopener", "string" == typeof b ? (j.href = b, j.origin === location.origin ? e(j) : d(j.href) ? c(b, g, h) : e(j, j.target = "_blank")) : (j.href = i.createObjectURL(b), setTimeout(function() {
            i.revokeObjectURL(j.href);
        }, 4E4), setTimeout(function() {
            e(j);
        }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(f, g, h) {
        if (g = g || f.name || "download", "string" != typeof f) navigator.msSaveOrOpenBlob(b(f, h), g);
        else if (d(f)) c(f, g, h);
        else {
            var i = document.createElement("a");
            i.href = f, i.target = "_blank", setTimeout(function() {
                e(i);
            });
        }
    } : function(b, d, e, g) {
        if (g = g || open("", "_blank"), g && (g.document.title = g.document.body.innerText = "downloading..."), "string" == typeof b) return c(b, d, e);
        var h = "application/octet-stream" === b.type, i = /constructor/i.test(f.HTMLElement) || f.safari, j = /CriOS\/[\d]+/.test(navigator.userAgent);
        if ((j || h && i || a) && "undefined" != typeof FileReader) {
            var k = new FileReader;
            k.onloadend = function() {
                var a = k.result;
                a = j ? a : a.replace(/^data:[^;]*;/, "data:attachment/file;"), g ? g.location.href = a : location = a, g = null;
            }, k.readAsDataURL(b);
        } else {
            var l = f.URL || f.webkitURL, m = l.createObjectURL(b);
            g ? g.location = m : location.href = m, g = null, setTimeout(function() {
                l.revokeObjectURL(m);
            }, 4E4);
        }
    });
    f.saveAs = g.saveAs = g, module.exports = g;
});

},{}],"e5QXt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UndoRedoCatchup", ()=>UndoRedoCatchup);
var _kl = require("../kl");
var _klHistory = require("./kl-history");
class UndoRedoCatchup {
    /**
     * Prevent multiple undo / redo getting triggered at once.
     * Might be confusing if main thread is choking.
     */ ignoreTest() {
        if (this.doIgnore) return false;
        this.doIgnore = true;
        setTimeout(()=>{
            this.doIgnore = false;
        }, 0);
        return true;
    }
    // ---- public ----
    constructor(brushUiObj, layerPreview, layerManager, handUi, klCanvasWorkspace, getInitState, getKlCanvas, getCurrentLayerCtx, setCurrentLayerCtx, getCurrentBrush){
        this.brushUiObj = brushUiObj;
        this.layerPreview = layerPreview;
        this.layerManager = layerManager;
        this.handUi = handUi;
        this.klCanvasWorkspace = klCanvasWorkspace;
        this.getInitState = getInitState;
        this.getKlCanvas = getKlCanvas;
        this.getCurrentLayerCtx = getCurrentLayerCtx;
        this.setCurrentLayerCtx = setCurrentLayerCtx;
        this.getCurrentBrush = getCurrentBrush;
        this.doIgnore = false;
    }
    undo() {
        if (!this.ignoreTest()) return false;
        if (!(0, _klHistory.klHistory).canUndo()) return false;
        const actions = (0, _klHistory.klHistory).undo();
        const klCanvas = this.getKlCanvas();
        (0, _klHistory.klHistory).pause(true);
        const initState = this.getInitState();
        const oldSize = {
            w: klCanvas.getWidth(),
            h: klCanvas.getHeight()
        };
        klCanvas.copy(initState.canvas);
        let layerIndex = initState.focus;
        this.setCurrentLayerCtx(klCanvas.getLayerContext(layerIndex));
        const brushes = {};
        for(let b in (0, _kl.KL).brushes)if ((0, _kl.KL).brushes.hasOwnProperty(b)) {
            brushes[b] = new (0, _kl.KL).brushes[b]();
            brushes[b].setContext(this.getCurrentLayerCtx());
        }
        brushes.SketchyBrush.setSeed(initState.brushes.SketchyBrush.getSeed());
        for(let i = 0; i < actions.length; i++)((i)=>{
            if (actions[i].tool[0] === "brush") {
                const b = brushes[actions[i].tool[1]];
                if (actions[i].actions) for(let e = 0; e < actions[i].actions.length; e++){
                    const p = actions[i].actions[e].params;
                    b[actions[i].actions[e].action].apply(b, p);
                }
                else {
                    const p1 = actions[i].params;
                    b[actions[i].action].apply(b, p1);
                }
            } else if (actions[i].tool[0] === "canvas") {
                const p2 = actions[i].params;
                const id = klCanvas[actions[i].action].apply(klCanvas, p2);
                if (typeof id === "number") {
                    layerIndex = id;
                    this.setCurrentLayerCtx(klCanvas.getLayerContext(layerIndex));
                    for(let b1 in brushes)if (brushes.hasOwnProperty(b1)) brushes[b1].setContext(this.getCurrentLayerCtx());
                }
            } else if (actions[i].tool[0] === "filter") {
                const p3 = [
                    {
                        context: this.getCurrentLayerCtx(),
                        klCanvas,
                        input: actions[i].params[0].input,
                        history: new (0, _kl.KL).DecoyKlHistory()
                    }
                ];
                (0, _kl.KL).filterLib[actions[i].tool[1]][actions[i].action].apply(null, p3);
            } else if (actions[i].tool[0] === "misc" && actions[i].action === "focusLayer") {
                layerIndex = actions[i].params[0];
                this.setCurrentLayerCtx(klCanvas.getLayerContext(actions[i].params[0]));
                for(let b2 in brushes)if (brushes.hasOwnProperty(b2)) brushes[b2].setContext(this.getCurrentLayerCtx());
            } else if (actions[i].tool[0] === "misc" && actions[i].action === "importImage") {
                const id1 = klCanvas.addLayer();
                if (typeof id1 === "number") {
                    layerIndex = id1;
                    if (actions[i].params[1]) klCanvas.renameLayer(layerIndex, actions[i].params[1]);
                    this.setCurrentLayerCtx(klCanvas.getLayerContext(layerIndex));
                    for(let b3 in brushes)if (brushes.hasOwnProperty(b3)) brushes[b3].setContext(this.getCurrentLayerCtx());
                }
                this.getCurrentLayerCtx().drawImage(actions[i].params[0], 0, 0);
            }
        })(i);
        if (oldSize.w !== klCanvas.getWidth() || oldSize.h !== klCanvas.getHeight()) {
            this.klCanvasWorkspace.resetView();
            this.handUi.update(this.klCanvasWorkspace.getScale(), this.klCanvasWorkspace.getAngleDeg());
        }
        this.layerManager.update(layerIndex);
        this.layerPreview.setLayer(klCanvas.getLayer(layerIndex));
        this.brushUiObj.sketchyBrush.setSeed(brushes.SketchyBrush.getSeed());
        this.getCurrentBrush().setContext(this.getCurrentLayerCtx());
        this.klCanvasWorkspace.setLastDrawEvent(null);
        (0, _klHistory.klHistory).pause(false);
        return true;
    }
    redo() {
        if (!this.ignoreTest()) return false;
        if (!(0, _klHistory.klHistory).canRedo()) return false;
        const actions = (0, _klHistory.klHistory).redo();
        const klCanvas = this.getKlCanvas();
        (0, _klHistory.klHistory).pause(true);
        const oldSize = {
            w: klCanvas.getWidth(),
            h: klCanvas.getHeight()
        };
        let layerIndex;
        const brushes = {};
        for(let b in (0, _kl.KL).brushes)if ((0, _kl.KL).brushes.hasOwnProperty(b)) {
            brushes[b] = new (0, _kl.KL).brushes[b]();
            brushes[b].setContext(this.getCurrentLayerCtx());
        }
        brushes.SketchyBrush.setSeed(this.brushUiObj.sketchyBrush.getSeed());
        for(let i = 0; i < actions.length; i++)((i)=>{
            if (actions[i].tool[0] === "brush") {
                const b = brushes[actions[i].tool[1]];
                if (actions[i].actions) for(let e = 0; e < actions[i].actions.length; e++){
                    const p = actions[i].actions[e].params;
                    b[actions[i].actions[e].action].apply(b, p);
                }
                else {
                    const p1 = actions[i].params;
                    b[actions[i].action].apply(b, p1);
                }
            } else if (actions[i].tool[0] === "canvas") {
                const p2 = actions[i].params;
                const id = klCanvas[actions[i].action].apply(klCanvas, p2);
                if (typeof id === "number") {
                    layerIndex = id;
                    this.setCurrentLayerCtx(klCanvas.getLayerContext(layerIndex));
                    for(let b1 in brushes)if (brushes.hasOwnProperty(b1)) brushes[b1].setContext(this.getCurrentLayerCtx());
                }
            } else if (actions[i].tool[0] === "filter") {
                const p3 = [
                    {
                        context: this.getCurrentLayerCtx(),
                        klCanvas,
                        input: actions[i].params[0].input,
                        history: new (0, _kl.KL).DecoyKlHistory()
                    }
                ];
                (0, _kl.KL).filterLib[actions[i].tool[1]][actions[i].action].apply(null, p3);
            } else if (actions[i].tool[0] === "misc" && actions[i].action === "focusLayer") {
                layerIndex = actions[i].params[0];
                this.setCurrentLayerCtx(klCanvas.getLayerContext(actions[i].params[0]));
                for(let b2 in brushes)if (brushes.hasOwnProperty(b2)) brushes[b2].setContext(this.getCurrentLayerCtx());
            } else if (actions[i].tool[0] === "misc" && actions[i].action === "importImage") {
                const id1 = klCanvas.addLayer();
                if (typeof id1 === "number") {
                    layerIndex = id1;
                    if (actions[i].params[1]) klCanvas.renameLayer(layerIndex, actions[i].params[1]);
                    this.setCurrentLayerCtx(klCanvas.getLayerContext(layerIndex));
                    for(let b3 in brushes)if (brushes.hasOwnProperty(b3)) brushes[b3].setContext(this.getCurrentLayerCtx());
                }
                this.getCurrentLayerCtx().drawImage(actions[i].params[0], 0, 0);
            }
        })(i);
        if (oldSize.w !== klCanvas.getWidth() || oldSize.h !== klCanvas.getHeight()) {
            this.klCanvasWorkspace.resetView();
            this.handUi.update(this.klCanvasWorkspace.getScale(), this.klCanvasWorkspace.getAngleDeg());
        }
        const currentLayerIndex = klCanvas.getLayerIndex(this.getCurrentLayerCtx().canvas);
        this.layerManager.update(currentLayerIndex);
        this.layerPreview.setLayer(klCanvas.getLayer(currentLayerIndex));
        this.brushUiObj.sketchyBrush.setSeed(brushes.SketchyBrush.getSeed());
        this.getCurrentBrush().setContext(this.getCurrentLayerCtx());
        this.klCanvasWorkspace.setLastDrawEvent(null);
        (0, _klHistory.klHistory).pause(false);
        return true;
    }
    catchup(logParam) {
        // const start = performance.now();
        //play catch up (the version that is a few steps behind)
        if (logParam && logParam.bufferUpdate) {
            const initState = this.getInitState();
            const brushes = initState.brushes;
            const actions = [
                logParam.bufferUpdate
            ];
            let localCurrentLayerCtx = initState.canvas.getLayerContext(initState.focus);
            const klCanvas = initState.canvas;
            let layerIndex = initState.focus;
            ((i)=>{
                if (actions[i].tool[0] === "brush") {
                    let b = brushes[actions[i].tool[1]];
                    if (actions[i].actions) for(let e = 0; e < actions[i].actions.length; e++){
                        const p = actions[i].actions[e].params;
                        b[actions[i].actions[e].action].apply(b, p);
                    }
                    else {
                        const p1 = actions[i].params;
                        b[actions[i].action].apply(b, p1);
                    }
                } else if (actions[i].tool[0] === "canvas") {
                    const p2 = actions[i].params;
                    const id = klCanvas[actions[i].action].apply(klCanvas, p2);
                    if (typeof id === "number") {
                        layerIndex = id;
                        localCurrentLayerCtx = klCanvas.getLayerContext(layerIndex);
                        for(let b1 in brushes)if (brushes.hasOwnProperty(b1)) brushes[b1].setContext(localCurrentLayerCtx);
                    }
                } else if (actions[i].tool[0] === "filter") {
                    const p3 = [
                        {
                            context: localCurrentLayerCtx,
                            klCanvas,
                            input: actions[i].params[0].input,
                            history: new (0, _kl.KL).DecoyKlHistory()
                        }
                    ];
                    (0, _kl.KL).filterLib[actions[i].tool[1]][actions[i].action].apply(null, p3);
                } else if (actions[i].tool[0] === "misc" && actions[i].action === "focusLayer") {
                    layerIndex = actions[i].params[0];
                    localCurrentLayerCtx = klCanvas.getLayerContext(actions[i].params[0]);
                    for(let b2 in brushes)if (brushes.hasOwnProperty(b2)) brushes[b2].setContext(localCurrentLayerCtx);
                } else if (actions[i].tool[0] === "misc" && actions[i].action === "importImage") {
                    const id1 = klCanvas.addLayer();
                    if (typeof id1 === "number") {
                        layerIndex = id1;
                        if (actions[i].params[1]) klCanvas.renameLayer(layerIndex, actions[i].params[1]);
                        localCurrentLayerCtx = klCanvas.getLayerContext(layerIndex);
                        for(let b3 in brushes)if (brushes.hasOwnProperty(b3)) brushes[b3].setContext(localCurrentLayerCtx);
                    }
                    localCurrentLayerCtx.drawImage(actions[i].params[0], 0, 0);
                }
            })(0);
            initState.focus = layerIndex;
        }
    // console.log('catchup', performance.now() - start);
    }
}

},{"../kl":"8nmWp","./kl-history":"klzEn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dTdDM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Central place to update brush settings, and to subscribe to changes.
 */ parcelHelpers.export(exports, "BrushSettingService", ()=>BrushSettingService);
class BrushSettingService {
    emit(obj, skipSubscriber) {
        for(let i = 0; i < this.subscriberArr.length; i++){
            if (this.subscriberArr[i] === skipSubscriber) continue;
            this.subscriberArr[i](obj);
        }
    }
    // --- public ---
    constructor(onSetColor, onSetSize, onSetOpacity, onGetColor, onGetSize, onGetOpacity, onGetSliderConfig){
        this.onSetColor = onSetColor;
        this.onSetSize = onSetSize;
        this.onSetOpacity = onSetOpacity;
        this.onGetColor = onGetColor;
        this.onGetSize = onGetSize;
        this.onGetOpacity = onGetOpacity;
        this.onGetSliderConfig = onGetSliderConfig;
        this.subscriberArr = [];
        if (BrushSettingService.instance) throw new Error("BrushSettingService already instantiated");
        BrushSettingService.instance = this;
    }
    emitColor(color, skipSubscriber) {
        this.emit({
            type: "color",
            value: color
        }, skipSubscriber);
    }
    emitSize(size, skipSubscriber) {
        this.emit({
            type: "size",
            value: size
        }, skipSubscriber);
    }
    emitOpacity(opacity, skipSubscriber) {
        this.emit({
            type: "opacity",
            value: opacity
        }, skipSubscriber);
    }
    emitSliderConfig(sliderConfig, skipSubscriber) {
        this.emit({
            type: "sliderConfig",
            value: sliderConfig
        }, skipSubscriber);
    }
    /**
     * set current brush color
     * @param color
     * @param skipSubscriber
     */ setColor(color, skipSubscriber) {
        this.onSetColor(color);
        this.emitColor(color, skipSubscriber);
    }
    /**
     * set current brush size
     * @param size
     * @param skipSubscriber
     */ setSize(size, skipSubscriber) {
        this.onSetSize(size);
    // why not emitting?
    }
    /**
     * set current opacity
     * @param opacity
     * @param skipSubscriber
     */ setOpacity(opacity, skipSubscriber) {
        this.onSetOpacity(opacity);
    // why not emitting?
    }
    /**
     * get current brush color
     */ getColor() {
        return this.onGetColor();
    }
    getSize() {
        return this.onGetSize();
    }
    getOpacity() {
        return this.onGetOpacity();
    }
    getSliderConfig() {
        return this.onGetSliderConfig();
    }
    /**
     * subscribe to changes
     * @param func
     */ subscribe(func) {
        if (this.subscriberArr.includes(func)) return;
        this.subscriberArr.push(func);
    }
    unsubscribe(func) {
        for(let i = 0; i < this.subscriberArr.length; i++)if (func === this.subscriberArr[i]) {
            this.subscriberArr.splice(i, 1);
            i--;
        }
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4JW40":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SettingsTab", ()=>SettingsTab);
var _bb = require("../../../bb/bb");
var _language = require("../../../language/language");
var _kl = require("../../kl");
var _languages = require("../../../../languages/languages");
var _popup = require("../modals/popup");
// @ts-ignore
var _bitbofLogoSvg = require("url:~/src/app/img/bitbof-logo.svg");
var _bitbofLogoSvgDefault = parcelHelpers.interopDefault(_bitbofLogoSvg);
// @ts-ignore
var _klecksLogoPng = require("url:~/src/app/img/klecks-logo.png");
var _klecksLogoPngDefault = parcelHelpers.interopDefault(_klecksLogoPng);
// @ts-ignore
var _uiSwapLrSvg = require("url:~/src/app/img/ui/ui-swap-lr.svg");
var _uiSwapLrSvgDefault = parcelHelpers.interopDefault(_uiSwapLrSvg);
var _localStorage = require("../../../bb/base/local-storage");
class SettingsTab {
    // --- public ---
    constructor(onLeftRight, customAbout){
        // ---- language ----
        const language = (0, _language.languageStrings).getLanguage();
        this.el = (0, _bb.BB).el({
            content: `
${(0, _language.LANG)("settings-language")}: ${language.name} (${language.code})
            `,
            css: {
                margin: "10px"
            }
        });
        const preferredLanguageRow = (0, _bb.BB).el({
            content: (0, _language.LANG)("settings-preferred-language") + ":<br>",
            css: {
                marginTop: "10px"
            }
        });
        const options = [
            [
                "auto",
                (0, _language.LANG)("auto")
            ]
        ].concat((0, _languages.languages).map((item)=>{
            return [
                item.code,
                item.name + ` (${item.code})`
            ];
        }));
        const languageSelect = new (0, _kl.KL).Select({
            initValue: (0, _localStorage.LocalStorage).getItem((0, _language.LS_LANGUAGE_KEY)) ? (0, _localStorage.LocalStorage).getItem((0, _language.LS_LANGUAGE_KEY)) : "auto",
            optionArr: options,
            onChange: (val)=>{
                if (val === "auto") (0, _localStorage.LocalStorage).removeItem((0, _language.LS_LANGUAGE_KEY));
                else (0, _localStorage.LocalStorage).setItem((0, _language.LS_LANGUAGE_KEY), val);
                languageHint.style.display = "block";
            }
        });
        const languageHint = (0, _bb.BB).el({
            content: (0, _language.LANG)("settings-language-reload"),
            css: {
                display: "none",
                marginTop: "5px"
            }
        });
        preferredLanguageRow.append(languageSelect.getElement(), languageHint);
        this.el.append(preferredLanguageRow);
        // ---- flip ui ----
        (0, _bb.BB).el({
            tagName: "button",
            parent: this.el,
            content: '<img height="20" width="18" src="' + (0, _uiSwapLrSvgDefault.default) + '" alt="icon" style="margin-right: 5px"/>' + (0, _language.LANG)("switch-ui-left-right"),
            onClick: ()=>onLeftRight(),
            css: {
                marginTop: "20px"
            },
            custom: {
                tabIndex: "-1"
            }
        });
        // ---- about ----
        this.el.append((0, _bb.BB).el({
            className: "gridHr",
            css: {
                margin: "10px 0"
            }
        }));
        function makeLicenses() {
            return (0, _bb.BB).el({
                tagName: "a",
                content: (0, _language.LANG)("licenses"),
                onClick: ()=>{
                    require("99ffdd801f47c2ca").then((result)=>{
                        new (0, _popup.Popup)({
                            title: (0, _bb.BB).el({
                                content: (0, _language.LANG)("licenses")
                            }),
                            content: (0, _bb.BB).el({
                                content: (0, _bb.BB).el({
                                    content: result.licenses.replace(/\n/g, "<br>"),
                                    css: {
                                        padding: "20px"
                                    }
                                }),
                                css: {
                                    height: "100%",
                                    overflowY: "scroll"
                                }
                            }),
                            width: 800,
                            isMaxHeight: true
                        });
                    });
                }
            });
        }
        if (customAbout) {
            this.el.append(customAbout);
            if (!customAbout.innerHTML) {
                const minimalAbout = (0, _bb.BB).el({
                    parent: customAbout,
                    css: {
                        textAlign: "center"
                    }
                });
                minimalAbout.append((0, _bb.BB).el({
                    content: `<img alt="icon" height="20" style="vertical-align:middle" src="${(0, _bitbofLogoSvgDefault.default)}"> <a href="https://bitbof.com" target="_blank" tabIndex="-1">bitbof</a> ¬© 2022<br>`
                }), makeLicenses());
            }
        } else {
            const versionEl = (0, _bb.BB).el({
                parent: this.el,
                css: {
                    textAlign: "center"
                },
                content: `
<img alt="Klecks" height="25" src="${(0, _klecksLogoPngDefault.default)}"><br>
<img alt="icon" height="20" style="vertical-align:middle" src="${(0, _bitbofLogoSvgDefault.default)}"> <a href="https://bitbof.com" target="_blank" tabIndex="-1">bitbof</a> ¬© 2022<br>`
            });
            versionEl.append(makeLicenses(), document.createTextNode(" | "), (0, _bb.BB).el({
                tagName: "a",
                content: (0, _language.LANG)("donate"),
                custom: {
                    href: "https://kleki.com/donate/",
                    target: "_blank"
                }
            }), document.createTextNode(" | "), (0, _bb.BB).el({
                tagName: "a",
                content: (0, _language.LANG)("source-code"),
                custom: {
                    href: "https://klecks.org",
                    target: "_blank"
                }
            }));
        }
        window.addEventListener("storage", (e)=>{
            if (e.key !== (0, _language.LS_LANGUAGE_KEY)) return;
            languageSelect.setValue((0, _localStorage.LocalStorage).getItem((0, _language.LS_LANGUAGE_KEY)) ? (0, _localStorage.LocalStorage).getItem((0, _language.LS_LANGUAGE_KEY)) : "auto");
        });
    }
    getElement() {
        return this.el;
    }
}

},{"../../../bb/bb":"dcQKo","../../../language/language":"iiYGN","../../kl":"8nmWp","../../../../languages/languages":"5K1G7","../modals/popup":"4Ltiz","url:~/src/app/img/bitbof-logo.svg":"7X1RP","url:~/src/app/img/klecks-logo.png":"5kpJy","url:~/src/app/img/ui/ui-swap-lr.svg":"fdJ0i","../../../bb/base/local-storage":"04p5O","99ffdd801f47c2ca":"6hvGh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7X1RP":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "bitbof-logo.c317c28a.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"fdJ0i":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "ui-swap-lr.e21c7203.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"6hvGh":[function(require,module,exports) {
module.exports = require("./helpers/browser/js-loader")(require("./helpers/bundle-url").getBundleURL("d3gnI") + "licenses.2c035fa3.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root("ki4n9"));

},{"./helpers/browser/js-loader":"61B45","./helpers/bundle-url":"lgJ39"}],"gytag":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Scroll buttons at the top and bottom of toolspace
 * Show up when window is very small.
 * Allow user to scroll up and down toolspace.
 */ parcelHelpers.export(exports, "ToolspaceScroller", ()=>ToolspaceScroller);
var _bb = require("../../../bb/bb");
var _language = require("../../../language/language");
var _modalCount = require("../modals/modal-count");
class ToolspaceScroller {
    update() {
        if (this.toolspace.scrollHeight > this.toolspace.offsetHeight + 3) {
            if (!this.upInterval) this.upBtn.style.display = this.toolspace.scrollTop === 0 ? "none" : "block";
            if (!this.downInterval) this.downBtn.style.display = this.toolspace.scrollTop + this.toolspace.offsetHeight + 1 >= this.toolspace.scrollHeight ? "none" : "block";
        } else {
            this.upBtn.style.display = "none";
            this.downBtn.style.display = "none";
        }
    }
    // --- public ---
    constructor(p){
        this.toolspace = p.toolspace;
        this.upBtn = (0, _bb.BB).el({
            parent: this.toolspace,
            title: (0, _language.LANG)("scroll"),
            className: "kl-scroller",
            css: {
                top: "0",
                transform: "rotate(180deg)"
            }
        });
        this.downBtn = (0, _bb.BB).el({
            parent: this.toolspace,
            title: (0, _language.LANG)("scroll"),
            className: "kl-scroller",
            css: {
                bottom: "0"
            }
        });
        this.updateUiState(p.uiState);
        const upListener = new (0, _bb.BB).PointerListener({
            target: this.upBtn,
            onPointer: (e)=>{
                if (e.type === "pointerdown") this.upInterval = setInterval(()=>{
                    this.toolspace.scrollBy(0, -13);
                    this.update();
                }, 20);
                if (e.type === "pointerup") {
                    clearInterval(this.upInterval);
                    setTimeout(()=>{
                        this.upInterval = null;
                        this.update();
                    }, 50);
                }
            }
        });
        const downListener = new (0, _bb.BB).PointerListener({
            target: this.downBtn,
            onPointer: (e)=>{
                if (e.type === "pointerdown") this.downInterval = setInterval(()=>{
                    this.toolspace.scrollBy(0, 13);
                    this.update();
                }, 20);
                if (e.type === "pointerup") {
                    clearInterval(this.downInterval);
                    setTimeout(()=>{
                        this.downInterval = null;
                        this.update();
                    }, 50);
                }
            }
        });
        const wheelListener = (e)=>{
            this.toolspace.scrollBy(0, Math.round(0.7 * e.deltaY));
            this.update();
        };
        this.upBtn.addEventListener("wheel", wheelListener);
        this.downBtn.addEventListener("wheel", wheelListener);
        this.update();
        const observer = new MutationObserver(()=>this.update());
        observer.observe(this.toolspace, {
            attributes: true,
            childList: true,
            subtree: true
        });
        window.addEventListener("resize", ()=>this.update());
        // hide if in dialog because that can have its own scrollbar
        (0, _modalCount.dialogCounter).subscribe((v)=>{
            // ignores the 0.5 by tool dropdown
            this.upBtn.style.opacity = v >= 1 ? "0" : "";
            this.downBtn.style.opacity = v >= 1 ? "0" : "";
        });
    }
    updateUiState(uiState) {
        (0, _bb.BB).css(this.upBtn, {
            left: uiState === "left" ? "0" : null,
            right: uiState === "right" ? "0" : null
        });
        (0, _bb.BB).css(this.downBtn, {
            left: uiState === "left" ? "0" : null,
            right: uiState === "right" ? "0" : null
        });
    }
}

},{"../../../bb/bb":"dcQKo","../../../language/language":"iiYGN","../modals/modal-count":"lsSVM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"boDxv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Gradient Tool tab contents
 *
 * p = {
 *     colorSlider: KlColorSlider// when opening tab, inserts it (snatches it from where else it was)
 * }
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "GradientUi", ()=>GradientUi);
var _bb = require("../../../bb/bb");
var _klSlider = require("../base-components/kl-slider");
var _language = require("../../../language/language");
var _checkbox = require("../base-components/checkbox");
var _options = require("../base-components/options");
class GradientUi {
    settings = {
        opacity: 1,
        type: "linear",
        doLockAlpha: false,
        doSnap: false,
        isReversed: false,
        isEraser: false
    };
    updateIcons() {
        const col1 = this.settings.isReversed ? "#0000" : "#000";
        const col2 = this.settings.isReversed ? "#000" : "#0000";
        this.iconArr[0].style.background = `linear-gradient(${col1}, ${col2})`;
        this.iconArr[1].style.background = `linear-gradient(${col2}, ${col1}, ${col2})`;
        this.iconArr[2].style.background = `radial-gradient(${col1}, ${col2})`;
    }
    // ----- public -------
    constructor(p){
        this.colorSlider = p.colorSlider;
        this.rootEl = (0, _bb.BB).el({
            css: {
                margin: "10px"
            }
        });
        this.isVisible = true;
        this.colorDiv = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                marginBottom: "10px"
            }
        });
        this.iconArr = [];
        {
            const size = 33;
            [
                0,
                1,
                2
            ].forEach((item)=>{
                const el = (0, _bb.BB).el({
                    css: {
                        width: size + "px",
                        height: size + "px",
                        borderRadius: "3px",
                        margin: "1px"
                    }
                });
                this.iconArr.push(el);
            });
        }
        this.updateIcons();
        const typeOptions = new (0, _options.Options)({
            optionArr: [
                {
                    id: "linear",
                    label: this.iconArr[0],
                    title: (0, _language.LANG)("gradient-linear")
                },
                {
                    id: "linear-mirror",
                    label: this.iconArr[1],
                    title: (0, _language.LANG)("gradient-linear-mirror")
                },
                {
                    id: "radial",
                    label: this.iconArr[2],
                    title: (0, _language.LANG)("gradient-radial")
                }
            ],
            initId: "linear",
            onChange: (id)=>{
                this.settings.type = id;
            }
        });
        this.rootEl.append(typeOptions.getElement());
        const opacitySlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)("opacity"),
            width: 250,
            height: 30,
            min: 0.01,
            max: 1,
            value: this.settings.opacity,
            toValue: (displayValue)=>displayValue / 100,
            toDisplayValue: (value)=>value * 100,
            onChange: (val)=>{
                this.settings.opacity = val;
            }
        });
        (0, _bb.BB).css(opacitySlider.getElement(), {
            marginTop: "10px"
        });
        this.rootEl.append(opacitySlider.getElement());
        const row1 = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                display: "flex",
                alignItems: "center",
                marginTop: "10px"
            }
        });
        const reverseToggle = new (0, _checkbox.Checkbox)({
            init: false,
            label: (0, _language.LANG)("reverse"),
            callback: (b)=>{
                this.settings.isReversed = b;
                this.updateIcons();
            },
            css: {
                width: "50%"
            }
        });
        const doSnapToggle = new (0, _checkbox.Checkbox)({
            init: false,
            label: (0, _language.LANG)("angle-snap"),
            title: (0, _language.LANG)("angle-snap-title"),
            callback: (b)=>{
                this.settings.doSnap = b;
            },
            css: {
                width: "50%"
            }
        });
        row1.append(reverseToggle.getElement(), doSnapToggle.getElement());
        const row2 = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                display: "flex",
                alignItems: "center",
                marginTop: "10px"
            }
        });
        const eraserToggle = new (0, _checkbox.Checkbox)({
            init: this.settings.isEraser,
            label: (0, _language.LANG)("eraser"),
            callback: (b)=>{
                this.settings.isEraser = b;
            },
            css: {
                width: "50%"
            }
        });
        const lockAlphaToggle = new (0, _checkbox.Checkbox)({
            init: false,
            label: (0, _language.LANG)("lock-alpha"),
            title: (0, _language.LANG)("lock-alpha-title"),
            callback: (b)=>{
                this.settings.doLockAlpha = b;
            },
            doHighlight: true,
            css: {
                width: "50%"
            }
        });
        row2.append(eraserToggle.getElement(), lockAlphaToggle.getElement());
    }
    getElement() {
        return this.rootEl;
    }
    setIsVisible(isVisible) {
        this.isVisible = !!isVisible;
        this.rootEl.style.display = isVisible ? "block" : "none";
        if (isVisible) {
            this.colorDiv.appendChild(this.colorSlider.getElement());
            this.colorDiv.appendChild(this.colorSlider.getOutputElement());
        }
    }
    getSettings() {
        return (0, _bb.BB).copyObj(this.settings);
    }
}

},{"../../../bb/bb":"dcQKo","../base-components/kl-slider":"6YGce","../../../language/language":"iiYGN","../base-components/checkbox":"kPAwM","../base-components/options":"huqRY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1tywk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "KlApp", ()=>KlApp);
var _kl = require("../klecks/kl");
var _klHistory = require("../klecks/history/kl-history");
var _bb = require("../bb/bb");
var _showIframePopup = require("../klecks/ui/modals/show-iframe-popup");
var _fileTab = require("../klecks/ui/tool-tabs/file-tab");
var _toolspaceTopRow = require("../embed/toolspace-top-row");
var _filtersLazy = require("../klecks/filters/filters-lazy");
var _base64ToBlob = require("../klecks/storage/base-64-to-blob");
var _klCanvasToPsdBlob = require("../klecks/storage/kl-canvas-to-psd-blob");
var _language = require("../language/language");
// @ts-ignore
var _toolPaintSvg = require("url:~/src/app/img/ui/tool-paint.svg");
var _toolPaintSvgDefault = parcelHelpers.interopDefault(_toolPaintSvg);
// @ts-ignore
var _toolHandSvg = require("url:~/src/app/img/ui/tool-hand.svg");
var _toolHandSvgDefault = parcelHelpers.interopDefault(_toolHandSvg);
// @ts-ignore
var _toolFillSvg = require("url:~/src/app/img/ui/tool-fill.svg");
var _toolFillSvgDefault = parcelHelpers.interopDefault(_toolFillSvg);
// @ts-ignore
var _toolGradientSvg = require("url:~/src/app/img/ui/tool-gradient.svg");
var _toolGradientSvgDefault = parcelHelpers.interopDefault(_toolGradientSvg);
// @ts-ignore
var _toolTextSvg = require("url:~/src/app/img/ui/tool-text.svg");
var _toolTextSvgDefault = parcelHelpers.interopDefault(_toolTextSvg);
// @ts-ignore
var _toolShapeSvg = require("url:~/src/app/img/ui/tool-shape.svg");
var _toolShapeSvgDefault = parcelHelpers.interopDefault(_toolShapeSvg);
// @ts-ignore
var _tabSettingsSvg = require("url:~/src/app/img/ui/tab-settings.svg");
var _tabSettingsSvgDefault = parcelHelpers.interopDefault(_tabSettingsSvg);
// @ts-ignore
var _tabLayersSvg = require("url:~/src/app/img/ui/tab-layers.svg");
var _tabLayersSvgDefault = parcelHelpers.interopDefault(_tabLayersSvg);
var _localStorage = require("../bb/base/local-storage");
(0, _filtersLazy.importFilters)();
function KlApp(pProject, pOptions) {
    // default 2048, unless your screen is bigger than that (that computer then probably has the horsepower for that)
    // but not larger than 4096 - a fairly arbitrary decision
    let klMaxCanvasSize = Math.min(4096, Math.max(2048, Math.max(window.screen.width, window.screen.height)));
    let collapseThreshold = 820;
    let uiState = pOptions.embed ? "left" : (0, _localStorage.LocalStorage).getItem("uiState") ? (0, _localStorage.LocalStorage).getItem("uiState") : "right";
    const filenameBase = pOptions.app?.filenameBase ? pOptions.app.filenameBase : "Klecks";
    const projectStore = pOptions.projectStore;
    let klRootEl = document.createElement("div");
    klRootEl.className = "g-root";
    let uiWidth = Math.max(0, window.innerWidth);
    let uiHeight = Math.max(0, window.innerHeight);
    const toolWidth = 271;
    let exportType = "png";
    let klCanvas = new (0, _kl.KL).KlCanvas(pProject ? {
        projectObj: pProject
    } : {
        width: Math.max(10, Math.min(klMaxCanvasSize, window.innerWidth < collapseThreshold ? uiWidth : uiWidth - toolWidth)),
        height: Math.max(10, Math.min(klMaxCanvasSize, uiHeight))
    }, pOptions.embed ? -1 : 0);
    klCanvas.setHistory((0, _klHistory.klHistory));
    let initState = null;
    let mainTabRow;
    if (!pOptions.saveReminder) pOptions.saveReminder = {
        init: ()=>{},
        reset: ()=>{}
    };
    function translateSmoothing(s) {
        if (s == 1) return 0.5;
        if (s == 2) return 0.84;
        if (s == 3) return 0.965;
        if (s == 4) return 0.9825;
        if (s == 5) return 0.99125;
        return s;
    }
    let isFirstImage = true;
    if (pProject) {
        pProject.layers.forEach((layer)=>{
            layer.image = null;
        });
        pProject = null;
    } else {
        (0, _klHistory.klHistory).pause(true);
        klCanvas.addLayer();
        klCanvas.layerFill(0, {
            r: 255,
            g: 255,
            b: 255
        });
        (0, _klHistory.klHistory).pause(false);
    }
    try {
        initState = {
            canvas: new (0, _kl.KL).KlCanvas({
                copy: klCanvas
            }, pOptions.embed ? -1 : 0),
            focus: klCanvas.getLayerCount() - 1,
            brushes: {}
        };
    } catch (e) {
        if (e.message === "kl-create-canvas-error") klCanvas.destroy();
        throw e;
    }
    for(let b in (0, _kl.KL).brushes)if ((0, _kl.KL).brushes.hasOwnProperty(b)) {
        initState.brushes[b] = new (0, _kl.KL).brushes[b]();
        if (initState.canvas) initState.brushes[b].setContext(initState.canvas.getLayerContext(initState.focus));
    }
    let currentColor = new (0, _bb.BB).RGB(0, 0, 0);
    let currentBrush;
    let currentBrushId;
    let lastNonEraserBrushId;
    let currentLayerCtx = klCanvas.getLayerContext(klCanvas.getLayerCount() - 1);
    // when cycling through brushes you need to know the next non-eraser brush
    function getNextBrushId() {
        if (currentBrushId === "eraserBrush") return lastNonEraserBrushId;
        const keyArr = Object.keys(brushUiObj).filter((item)=>item !== "eraserBrush");
        const i = keyArr.findIndex((item)=>item === currentBrushId);
        return keyArr[(i + 1) % keyArr.length];
    }
    function sizeWatcher(val) {
        brushSettingService.emitSize(val);
        if (klCanvasWorkspace) klCanvasWorkspace.setCursorSize(val * 2);
    }
    const brushSettingService = new (0, _kl.KL).BrushSettingService((color)=>{
        klColorSlider.setColor(color);
        currentBrush.setColor(color);
        currentColor = (0, _bb.BB).copyObj(color);
    }, (size)=>{
        currentBrush.setSize(size);
        klCanvasWorkspace.setCursorSize(size * 2);
    }, (opacity)=>{
        currentBrush.setOpacity(opacity);
    }, ()=>klColorSlider.getColor(), ()=>brushUiObj[currentBrushId].getSize(), ()=>brushUiObj[currentBrushId].getOpacity(), ()=>{
        return {
            sizeSlider: (0, _kl.KL).brushesUI[currentBrushId].sizeSlider,
            opacitySlider: (0, _kl.KL).brushesUI[currentBrushId].opacitySlider
        };
    });
    let lineSmoothing = new (0, _bb.BB).EventChain.LineSmoothing({
        smoothing: translateSmoothing(1)
    });
    let lineSanitizer = new (0, _bb.BB).EventChain.LineSanitizer();
    let drawEventChain = new (0, _bb.BB).EventChain.EventChain({
        chainArr: [
            lineSanitizer,
            lineSmoothing
        ]
    });
    drawEventChain.setChainOut(function(event) {
        if (event.type === "down") {
            toolspace.style.pointerEvents = "none";
            currentBrush.startLine(event.x, event.y, event.pressure);
            klCanvasWorkspace.requestFrame();
        }
        if (event.type === "move") {
            currentBrush.goLine(event.x, event.y, event.pressure, false, event.isCoalesced);
            klCanvasWorkspace.setLastDrawEvent(event.x, event.y, event.pressure);
            klCanvasWorkspace.requestFrame();
        }
        if (event.type === "up") {
            toolspace.style.pointerEvents = "";
            currentBrush.endLine();
            klCanvasWorkspace.requestFrame();
        }
        if (event.type === "line") {
            currentBrush.getBrush().drawLineSegment(event.x0, event.y0, event.x1, event.y1);
            klCanvasWorkspace.requestFrame();
        }
    });
    let textToolSettings = {
        size: 20,
        align: "left",
        isBold: false,
        isItalic: false,
        font: "sans-serif",
        opacity: 1
    };
    const klCanvasWorkspace = new (0, _kl.KL).KlCanvasWorkspace({
        klCanvas: klCanvas,
        width: Math.max(0, uiWidth - toolWidth),
        height: uiHeight,
        onDraw: drawEventChain.chainIn,
        onPick: function(rgbObj, isDragDone) {
            brushSettingService.setColor(rgbObj);
            if (isDragDone) {
                klColorSlider.pickingDone();
                klCanvasWorkspace.setMode(toolspaceToolRow.getActive());
            }
        },
        onFill: function(canvasX, canvasY) {
            let layerIndex = klCanvas.getLayerIndex(currentLayerCtx.canvas);
            klCanvas.floodFill(layerIndex, canvasX, canvasY, fillUi.getIsEraser() ? null : klColorSlider.getColor(), fillUi.getOpacity(), fillUi.getTolerance(), fillUi.getSample(), fillUi.getGrow(), fillUi.getContiguous());
            klCanvasWorkspace.requestFrame();
        },
        onGradient: function(typeStr, canvasX, canvasY, angleRad) {
            if (typeStr === "down") gradientTool.onDown(canvasX, canvasY, angleRad);
            if (typeStr === "move") gradientTool.onMove(canvasX, canvasY);
            if (typeStr === "up") gradientTool.onUp(canvasX, canvasY);
        },
        onText: function(canvasX, canvasY, angleRad) {
            if ((0, _kl.KL).dialogCounter.get() > 0) return;
            (0, _kl.KL).textToolDialog({
                klCanvas: klCanvas,
                layerIndex: klCanvas.getLayerIndex(currentLayerCtx.canvas),
                x: canvasX,
                y: canvasY,
                angleRad: angleRad,
                color: klColorSlider.getColor(),
                secondaryColor: klColorSlider.getSecondaryRGB(),
                size: textToolSettings.size,
                align: textToolSettings.align,
                isBold: textToolSettings.isBold,
                isItalic: textToolSettings.isItalic,
                font: textToolSettings.font,
                opacity: textToolSettings.opacity,
                onConfirm: function(val) {
                    let colorRGBA = val.color;
                    colorRGBA.a = val.opacity;
                    textToolSettings.size = val.size;
                    textToolSettings.align = val.align;
                    textToolSettings.isBold = val.isBold;
                    textToolSettings.isItalic = val.isItalic;
                    textToolSettings.font = val.font;
                    textToolSettings.opacity = val.opacity;
                    let layerIndex = klCanvas.getLayerIndex(currentLayerCtx.canvas);
                    klCanvas.text(layerIndex, {
                        textStr: val.textStr,
                        x: val.x,
                        y: val.y,
                        size: val.size,
                        font: val.font,
                        align: val.align,
                        isBold: val.isBold,
                        isItalic: val.isItalic,
                        angleRad: angleRad,
                        color: (0, _bb.BB).ColorConverter.toRgbaStr(colorRGBA)
                    });
                    klCanvasWorkspace.requestFrame();
                }
            });
        },
        onShape: function(typeStr, canvasX, canvasY, angleRad) {
            if (typeStr === "down") shapeTool.onDown(canvasX, canvasY, angleRad);
            if (typeStr === "move") shapeTool.onMove(canvasX, canvasY);
            if (typeStr === "up") shapeTool.onUp(canvasX, canvasY);
        },
        onViewChange: function(viewChangeObj) {
            if (viewChangeObj.changed.includes("scale")) statusOverlay.out({
                type: "transform",
                scale: viewChangeObj.scale,
                angleDeg: viewChangeObj.angle * 180 / Math.PI
            });
            toolspaceToolRow.setEnableZoomIn(viewChangeObj.scale !== klCanvasWorkspace.getMaxScale());
            toolspaceToolRow.setEnableZoomOut(viewChangeObj.scale !== klCanvasWorkspace.getMinScale());
            handUi.update(viewChangeObj.scale, viewChangeObj.angle * 180 / Math.PI);
        },
        onUndo: function() {
            if ((0, _klHistory.klHistory).canUndo()) {
                if (undoRedoCatchup.undo()) statusOverlay.out((0, _language.LANG)("undo"), true);
            }
        },
        onRedo: function() {
            if ((0, _klHistory.klHistory).canRedo()) {
                if (undoRedoCatchup.redo()) statusOverlay.out((0, _language.LANG)("redo"), true);
            }
        }
    });
    let keyListener = new (0, _bb.BB).KeyListener({
        onDown: function(keyStr, event, comboStr) {
            if ((0, _kl.KL).dialogCounter.get() > 0 || (0, _bb.BB).isInputFocused(true)) return;
            let isDrawing = lineSanitizer.getIsDrawing() || klCanvasWorkspace.getIsDrawing();
            if (isDrawing) return;
            if (comboStr === "plus") klCanvasWorkspace.zoomByStep(keyListener.isPressed("shift") ? 1 / 8 : 0.5);
            if (comboStr === "minus") klCanvasWorkspace.zoomByStep(keyListener.isPressed("shift") ? -1 / 8 : -0.5);
            if (comboStr === "home") klCanvasWorkspace.fitView();
            if (comboStr === "end") klCanvasWorkspace.resetView(true);
            if ([
                "ctrl+z",
                "cmd+z"
            ].includes(comboStr)) {
                event.preventDefault();
                undoRedoCatchup.undo();
            }
            if ([
                "ctrl+y",
                "cmd+y"
            ].includes(comboStr) || ((0, _bb.BB).sameKeys("ctrl+shift+z", comboStr) || (0, _bb.BB).sameKeys("cmd+shift+z", comboStr)) && keyStr === "z") {
                event.preventDefault();
                undoRedoCatchup.redo();
            }
            if (!pOptions.embed) {
                if ([
                    "ctrl+s",
                    "cmd+s"
                ].includes(comboStr)) {
                    event.preventDefault();
                    saveToComputer.save();
                }
                if ([
                    "ctrl+shift+s",
                    "cmd+shift+s"
                ].includes(comboStr)) {
                    event.preventDefault();
                    (async ()=>{
                        let success = true;
                        try {
                            await projectStore.store(klCanvas.getProject());
                        } catch (e) {
                            success = false;
                            setTimeout(()=>{
                                throw new Error("keyboard-shortcut: failed to store browser storage, " + e);
                            }, 0);
                            statusOverlay.out("‚ùå " + (0, _language.LANG)("file-storage-failed"), true);
                        }
                        if (success) {
                            pOptions.saveReminder.reset();
                            statusOverlay.out((0, _language.LANG)("file-storage-stored"), true);
                        }
                    })();
                }
                if ([
                    "ctrl+c",
                    "cmd+c"
                ].includes(comboStr)) {
                    event.preventDefault();
                    copyToClipboard(true);
                }
            }
            if ([
                "ctrl+a",
                "cmd+a"
            ].includes(comboStr)) event.preventDefault();
            if (keyListener.comboOnlyContains([
                "left",
                "right",
                "up",
                "down"
            ])) {
                if (keyStr === "left") klCanvasWorkspace.translateView(1, 0);
                if (keyStr === "right") klCanvasWorkspace.translateView(-1, 0);
                if (keyStr === "up") klCanvasWorkspace.translateView(0, 1);
                if (keyStr === "down") klCanvasWorkspace.translateView(0, -1);
            }
            if ([
                "r+left",
                "r+right"
            ].includes(comboStr)) {
                if (keyStr === "left") {
                    klCanvasWorkspace.setAngle(-15, true);
                    handUi.update(klCanvasWorkspace.getScale(), klCanvasWorkspace.getAngleDeg());
                }
                if (keyStr === "right") {
                    klCanvasWorkspace.setAngle(15, true);
                    handUi.update(klCanvasWorkspace.getScale(), klCanvasWorkspace.getAngleDeg());
                }
            }
            if ([
                "r+up"
            ].includes(comboStr)) {
                klCanvasWorkspace.setAngle(0);
                handUi.update(klCanvasWorkspace.getScale(), klCanvasWorkspace.getAngleDeg());
            }
            if (comboStr === "sqbr_open") currentBrush.decreaseSize(0.03 / klCanvasWorkspace.getScale());
            if (comboStr === "sqbr_close") currentBrush.increaseSize(0.03 / klCanvasWorkspace.getScale());
            if (comboStr === "enter") {
                klCanvas.layerFill(klCanvas.getLayerIndex(currentLayerCtx.canvas), klColorSlider.getColor());
                statusOverlay.out((0, _language.LANG)("filled"), true);
            }
            if ([
                "delete",
                "backspace"
            ].includes(comboStr)) {
                let layerIndex = klCanvas.getLayerIndex(currentLayerCtx.canvas);
                if (layerIndex === 0 && !brushUiObj.eraserBrush.getIsTransparentBg()) klCanvas.layerFill(layerIndex, {
                    r: 255,
                    g: 255,
                    b: 255
                }, "source-in");
                else klCanvas.clearLayer(layerIndex);
                statusOverlay.out((0, _language.LANG)("cleared-layer"), true);
            }
            if (comboStr === "e") {
                event.preventDefault();
                klCanvasWorkspace.setMode("draw");
                toolspaceToolRow.setActive("draw");
                mainTabRow.open("draw");
                updateMainTabVisibility();
                brushTabRow.open("eraserBrush");
            }
            if (comboStr === "b") {
                event.preventDefault();
                const prevMode = klCanvasWorkspace.getMode();
                klCanvasWorkspace.setMode("draw");
                toolspaceToolRow.setActive("draw");
                mainTabRow.open("draw");
                updateMainTabVisibility();
                brushTabRow.open(prevMode === "draw" ? getNextBrushId() : currentBrushId);
            }
            if (comboStr === "g") {
                event.preventDefault();
                const newMode = klCanvasWorkspace.getMode() === "fill" ? "gradient" : "fill";
                klCanvasWorkspace.setMode(newMode);
                toolspaceToolRow.setActive(newMode);
                mainTabRow.open(newMode);
                updateMainTabVisibility();
            }
            if (comboStr === "t") {
                event.preventDefault();
                klCanvasWorkspace.setMode("text");
                toolspaceToolRow.setActive("text");
                mainTabRow.open("text");
                updateMainTabVisibility();
            }
            if (comboStr === "u") {
                event.preventDefault();
                klCanvasWorkspace.setMode("shape");
                toolspaceToolRow.setActive("shape");
                mainTabRow.open("shape");
                updateMainTabVisibility();
            }
            if (comboStr === "x") {
                event.preventDefault();
                klColorSlider.swapColors();
            }
        },
        onUp: function(keyStr, event) {}
    });
    /**
     *
     * @param importedImage - convertedPsd | {type: 'image', width: number, height: number, canvas: image | canvas}
     * @param filename - string e.g. 'drawing.psd'
     * @param optionStr? - 'default' | 'layer' | 'image'
     */ function importFinishedLoading(importedImage, filename, optionStr) {
        if (!importedImage || isNaN(importedImage.width) || isNaN(importedImage.height) || importedImage.width <= 0 || importedImage.height <= 0) {
            (0, _kl.KL).popup({
                target: klRootEl,
                type: "error",
                message: (0, _language.LANG)("import-broken-file"),
                buttons: [
                    "Ok"
                ]
            });
            return;
        }
        function getResizedDimensions(width, height) {
            let w = parseInt(width);
            let h = parseInt(height);
            if (w > klMaxCanvasSize) {
                h = klMaxCanvasSize / w * h;
                w = klMaxCanvasSize;
            }
            if (h > klMaxCanvasSize) {
                w = klMaxCanvasSize / h * w;
                h = klMaxCanvasSize;
            }
            w = parseInt("" + w);
            h = parseInt("" + h);
            return {
                width: w,
                height: h
            };
        }
        function importAsImage(canvas) {
            let resizedDimensions = getResizedDimensions(canvas.width, canvas.height);
            //resize first
            let tempCanvas = (0, _bb.BB).canvas(canvas.width, canvas.height);
            let tempCanvasCtx = tempCanvas.getContext("2d");
            tempCanvasCtx.drawImage(canvas, 0, 0);
            (0, _bb.BB).resizeCanvas(tempCanvas, resizedDimensions.width, resizedDimensions.height);
            klCanvas.reset({
                width: resizedDimensions.width,
                height: resizedDimensions.height,
                image: tempCanvas,
                layerName: filename
            });
            layerManager.update(0);
            setCurrentLayer(klCanvas.getLayer(0));
            klCanvasWorkspace.resetView();
            handUi.update(klCanvasWorkspace.getScale(), klCanvasWorkspace.getAngleDeg());
            isFirstImage = false;
        }
        /**
         *
         * @param convertedPsdObj - if flattened then without layers
         * @param cropObj? - {x: number, y: number, width: number, height: number}
         */ function importAsImagePsd(convertedPsdObj, cropObj) {
            // crop
            function crop(targetCanvas, cropCanvas, cropObj) {
                cropCanvas.width = cropCanvas.width;
                cropCanvas.getContext("2d").drawImage(targetCanvas, -cropObj.x, -cropObj.y);
                targetCanvas.width = cropObj.width;
                targetCanvas.height = cropObj.height;
                targetCanvas.getContext("2d").drawImage(cropCanvas, 0, 0);
            }
            if (cropObj && (cropObj.width !== convertedPsdObj.width || cropObj.height !== convertedPsdObj.height)) {
                let cropCanvas = (0, _bb.BB).canvas(cropObj.width, cropObj.height);
                convertedPsdObj.width = cropObj.width;
                convertedPsdObj.height = cropObj.height;
                if (!convertedPsdObj.layers) crop(convertedPsdObj.canvas, cropCanvas, cropObj);
                if (convertedPsdObj.layers) for(let i = 0; i < convertedPsdObj.layers.length; i++){
                    let item = convertedPsdObj.layers[i];
                    crop(item.image, cropCanvas, cropObj);
                }
            }
            // resize
            let resizedDimensions = getResizedDimensions(convertedPsdObj.width, convertedPsdObj.height);
            convertedPsdObj.width = resizedDimensions.width;
            convertedPsdObj.height = resizedDimensions.height;
            if (!convertedPsdObj.layers) (0, _bb.BB).resizeCanvas(convertedPsdObj.canvas, convertedPsdObj.width, convertedPsdObj.height);
            if (convertedPsdObj.layers) for(let i1 = 0; i1 < convertedPsdObj.layers.length; i1++){
                let item1 = convertedPsdObj.layers[i1];
                (0, _bb.BB).resizeCanvas(item1.image, convertedPsdObj.width, convertedPsdObj.height);
            }
            let layerIndex;
            if (convertedPsdObj.layers) layerIndex = klCanvas.reset({
                width: convertedPsdObj.width,
                height: convertedPsdObj.height,
                layers: convertedPsdObj.layers
            });
            else layerIndex = klCanvas.reset({
                width: convertedPsdObj.width,
                height: convertedPsdObj.height,
                image: convertedPsdObj.canvas
            });
            layerManager.update(layerIndex);
            setCurrentLayer(klCanvas.getLayer(layerIndex));
            klCanvasWorkspace.resetView();
            handUi.update(klCanvasWorkspace.getScale(), klCanvasWorkspace.getAngleDeg());
            isFirstImage = false;
        }
        function importAsLayer(canvas) {
            (0, _kl.KL).showImportAsLayerDialog({
                target: klRootEl,
                klCanvas: klCanvas,
                importImage: canvas,
                callback: function(transformObj, isPixelated) {
                    if (!transformObj) return;
                    (0, _klHistory.klHistory).pause(true);
                    klCanvas.addLayer();
                    let layers = klCanvas.getLayers();
                    let activeLayerIndex = layers.length - 1;
                    if (filename) klCanvas.renameLayer(activeLayerIndex, filename);
                    let activeLayerContext = klCanvas.getLayerContext(activeLayerIndex);
                    (0, _bb.BB).drawTransformedImageWithBounds(activeLayerContext, canvas, transformObj, null, isPixelated);
                    setCurrentLayer(klCanvas.getLayer(activeLayerIndex));
                    layerManager.update(activeLayerIndex);
                    (0, _klHistory.klHistory).pause(false);
                    (0, _klHistory.klHistory).push({
                        tool: [
                            "misc"
                        ],
                        action: "importImage",
                        params: [
                            (0, _bb.BB).copyCanvas(activeLayerContext.canvas),
                            filename
                        ]
                    });
                }
            });
        }
        if (optionStr === "default" || !optionStr) (0, _kl.KL).showImportImageDialog({
            image: importedImage,
            target: klRootEl,
            maxSize: klMaxCanvasSize,
            callback: function(res) {
                if (res.type === "as-image") importAsImage(res.image);
                else if (res.type === "as-image-psd") importAsImagePsd(res.image, res.cropObj);
                else if (res.type === "as-layer") importAsLayer(res.image);
                else res.type;
            }
        });
        if (optionStr === "layer") importAsLayer(importedImage.canvas);
        if (optionStr === "image") {
            if (importedImage.type === "psd") importAsImagePsd(importedImage);
            else importAsImage(importedImage.canvas);
        }
    }
    function onPaste(e) {
        if ((0, _kl.KL).dialogCounter.get() > 0) return;
        function retrieveImageFromClipboardAsBlob(pasteEvent, callback) {
            if (pasteEvent.clipboardData == false) {
                if (typeof callback == "function") callback(undefined);
            }
            let items = pasteEvent.clipboardData.items;
            if (items == undefined) {
                if (typeof callback == "function") callback(undefined);
            } else for(let i = 0; i < items.length; i++){
                if (items[i].type.indexOf("image") == -1) continue;
                let blob = items[i].getAsFile();
                if (typeof callback == "function") callback(blob);
            }
        }
        e.stopPropagation();
        e.preventDefault();
        if (e.clipboardData.files[0]) retrieveImageFromClipboardAsBlob(e, function(imageBlob) {
            // If there's an image, display it in the canvas
            if (imageBlob) {
                let img = new Image();
                img.onload = function() {
                    URL.revokeObjectURL(img.src);
                    importFinishedLoading({
                        type: "image",
                        width: img.width,
                        height: img.height,
                        canvas: img
                    }, null, "default");
                };
                let URLObj = window.URL || window.webkitURL;
                img.src = URLObj.createObjectURL(imageBlob);
            }
        });
        else if (e.clipboardData.items[0]) e.clipboardData.items[0].getAsString(function(pasteStr) {
            pasteStr = pasteStr.trim();
            if (pasteStr.match(/^https?/)) {
                // url
                let img = new Image();
                img.onload = function() {
                    importFinishedLoading({
                        type: "image",
                        width: img.width,
                        height: img.height,
                        canvas: img
                    }, null, "default");
                };
                img.onerror = function(e) {
                    console.log("error loading", e);
                };
                img.crossOrigin = "Anonymous";
                img.src = pasteStr;
            } else if (pasteStr.match(/^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/)) {
                // url
                let rgbObj = (0, _bb.BB).ColorConverter.hexToRGB(pasteStr.replace("#", ""));
                brushSettingService.setColor(rgbObj);
            }
        });
    }
    function handleFileSelect(files, optionStr) {
        function showWarningPsdFlattened() {
            (0, _kl.KL).popup({
                target: klRootEl,
                type: "warning",
                message: (0, _language.LANG)("import-psd-unsupported") + "<br /><br />",
                buttons: [
                    "Ok"
                ]
            });
        }
        let hasUnsupportedFile = false;
        for(let i = 0, file; file = files[i]; i++){
            let extension = file.name.split(".");
            extension = extension[extension.length - 1].toLowerCase();
            if (extension === "psd") (function(f) {
                let loaderSizeBytes = 26214400; // 25mb
                let maxSizeBytes = 1073741824; // 1gb
                let maxResolution = 4096;
                if (f.size >= maxSizeBytes) {
                    (0, _kl.KL).popup({
                        target: klRootEl,
                        type: "error",
                        message: "File too big. Unable to import.<br /><br />",
                        buttons: [
                            "Ok"
                        ]
                    });
                    return;
                }
                let doShowLoader = files.length === 1 && f.size >= loaderSizeBytes;
                let loaderIsOpen = true;
                let closeLoader;
                if (doShowLoader) (0, _kl.KL).popup({
                    target: klRootEl,
                    message: (0, _language.LANG)("import-opening"),
                    callback: function(result) {
                        loaderIsOpen = false;
                        closeLoader = null;
                    },
                    closefunc: function(f) {
                        closeLoader = f;
                    }
                });
                let reader = new FileReader();
                reader.onload = function(readerResult) {
                    (0, _kl.KL).loadAgPsd().then(function(agPsdLazy) {
                        if (doShowLoader && !loaderIsOpen) return;
                        try {
                            let psd;
                            // first pass, only read metadata
                            psd = agPsdLazy.readPsd(readerResult.target.result, {
                                skipLayerImageData: true,
                                skipThumbnail: true,
                                skipCompositeImageData: true
                            });
                            if (psd.width > maxResolution || psd.height > maxResolution) {
                                if (closeLoader) closeLoader();
                                (0, _kl.KL).popup({
                                    target: klRootEl,
                                    type: "error",
                                    //message: "Image exceeds maximum dimensions of " + maxResolution + " x " + maxResolution + " pixels. Unable to import."
                                    message: (0, _language.LANG)("import-psd-too-large").replace(/{x}/g, "" + maxResolution) + "<br /><br />" + (0, _language.LANG)("import-psd-size") + ": " + psd.width + " x " + psd.height + " pixels" + "<br /><br />",
                                    buttons: [
                                        "Ok"
                                    ]
                                });
                                return;
                            }
                            // second pass, now load actual data.
                            psd = null;
                            try {
                                psd = agPsdLazy.readPsd(readerResult.target.result);
                            } catch (e) {
                            //console.log('failed regular psd import', e);
                            }
                            if (psd) {
                                //console.log('psd', psd);
                                let convertedPsd = (0, _kl.KL).PSD.readPsd(psd);
                                //console.log('converted', convertedPsd);
                                if (optionStr === "image" && convertedPsd.error) showWarningPsdFlattened();
                                if (closeLoader) closeLoader();
                                importFinishedLoading(convertedPsd, f.name, optionStr);
                            } else {
                                psd = agPsdLazy.readPsd(readerResult.target.result, {
                                    skipLayerImageData: true,
                                    skipThumbnail: true
                                });
                                if (optionStr === "image") showWarningPsdFlattened();
                                if (closeLoader) closeLoader();
                                importFinishedLoading({
                                    type: "psd",
                                    width: psd.width,
                                    height: psd.height,
                                    canvas: psd.canvas,
                                    error: true
                                }, f.name, optionStr);
                            }
                        } catch (e1) {
                            if (closeLoader) closeLoader();
                            (0, _kl.KL).popup({
                                target: klRootEl,
                                type: "error",
                                message: "Failed to load PSD.<br /><br />",
                                buttons: [
                                    "Ok"
                                ]
                            });
                        }
                    }).catch(()=>{
                        closeLoader();
                        alert("Error: failed to load PSD library");
                    });
                };
                reader.readAsArrayBuffer(f);
            })(file);
            else if (file.type.match("image.*")) (function(f) {
                window.URL = window.URL || window.webkitURL;
                let url = window.URL.createObjectURL(f);
                let im = new Image();
                im.src = url;
                (0, _bb.BB).loadImage(im, function() {
                    importFinishedLoading({
                        type: "image",
                        width: im.width,
                        height: im.height,
                        canvas: im
                    }, f.name, optionStr);
                });
            })(file);
            else hasUnsupportedFile = true;
        }
        if (hasUnsupportedFile) (0, _kl.KL).popup({
            target: klRootEl,
            message: (0, _language.LANG)("import-unsupported-file"),
            type: "error",
            buttons: [
                "OK"
            ]
        });
    }
    if (!pOptions.embed) {
        new (0, _kl.KL).KlImageDropper({
            target: document.body,
            onDrop: function(files, optionStr) {
                if ((0, _kl.KL).dialogCounter.get() > 0) return;
                handleFileSelect(files, optionStr);
            },
            enabledTest: function() {
                return (0, _kl.KL).dialogCounter.get() === 0;
            }
        });
        (0, _bb.BB).addEventListener(window, "paste", onPaste, false);
    }
    const brushUiObj = {};
    // create brush UIs
    for(let b1 in (0, _kl.KL).brushesUI)if ((0, _kl.KL).brushesUI.hasOwnProperty(b1)) {
        let ui = new (0, _kl.KL).brushesUI[b1].Ui({
            onSizeChange: sizeWatcher,
            onOpacityChange: function(opacity) {
                brushSettingService.emitOpacity(opacity);
            },
            onConfigChange: ()=>{
                brushSettingService.emitSliderConfig({
                    sizeSlider: (0, _kl.KL).brushesUI[currentBrushId].sizeSlider,
                    opacitySlider: (0, _kl.KL).brushesUI[currentBrushId].opacitySlider
                });
            }
        });
        brushUiObj[b1] = ui;
        ui.getElement().style.padding = "10px";
    }
    (0, _bb.BB).css(klRootEl, {
        position: "absolute",
        left: "0",
        top: "0",
        right: "0",
        bottom: "0"
    });
    let statusOverlay = new (0, _kl.KL).StatusOverlay();
    const toolspace = (0, _bb.BB).el({});
    const toolspaceInner = (0, _bb.BB).el({
        parent: toolspace
    });
    toolspace.oncontextmenu = function() {
        return false;
    };
    toolspace.onclick = (0, _bb.BB).handleClick;
    let toolspaceCollapser = new (0, _kl.KL).ToolspaceCollapser({
        onChange: function() {
            updateCollapse();
        }
    });
    function updateCollapse() {
        //collapser
        if (uiWidth < collapseThreshold) {
            toolspaceCollapser.getElement().style.display = "block";
            toolspaceCollapser.setDirection(uiState);
            if (toolspaceCollapser.isOpen()) {
                if (uiState === "left") {
                    (0, _bb.BB).css(toolspaceCollapser.getElement(), {
                        left: "271px",
                        right: ""
                    });
                    (0, _bb.BB).css(klCanvasWorkspace.getElement(), {
                        left: "271px"
                    });
                } else {
                    (0, _bb.BB).css(toolspaceCollapser.getElement(), {
                        left: "",
                        right: "271px"
                    });
                    (0, _bb.BB).css(klCanvasWorkspace.getElement(), {
                        left: "0"
                    });
                }
                toolspace.style.display = "block";
                klCanvasWorkspace.setSize(Math.max(0, uiWidth - toolWidth), uiHeight);
                statusOverlay.setWide(false);
            } else {
                if (uiState === "left") {
                    (0, _bb.BB).css(toolspaceCollapser.getElement(), {
                        left: "0",
                        right: ""
                    });
                    (0, _bb.BB).css(klCanvasWorkspace.getElement(), {
                        left: "0"
                    });
                } else {
                    (0, _bb.BB).css(toolspaceCollapser.getElement(), {
                        left: "",
                        right: "0"
                    });
                    (0, _bb.BB).css(klCanvasWorkspace.getElement(), {
                        left: "0"
                    });
                }
                toolspace.style.display = "none";
                klCanvasWorkspace.setSize(Math.max(0, uiWidth), uiHeight);
                statusOverlay.setWide(true);
            }
        } else {
            toolspaceCollapser.getElement().style.display = "none";
            if (uiState === "left") (0, _bb.BB).css(klCanvasWorkspace.getElement(), {
                left: "271px"
            });
            else (0, _bb.BB).css(klCanvasWorkspace.getElement(), {
                left: "0"
            });
            toolspace.style.display = "block";
            klCanvasWorkspace.setSize(Math.max(0, uiWidth - toolWidth), uiHeight);
            statusOverlay.setWide(false);
        }
    }
    updateCollapse();
    function updateUi() {
        if (uiState === "left") {
            (0, _bb.BB).css(toolspace, {
                left: "0",
                right: "",
                borderLeft: "none",
                borderRight: "1px solid rgb(135, 135, 135)"
            });
            (0, _bb.BB).css(klCanvasWorkspace.getElement(), {
                left: "271px"
            });
        } else {
            (0, _bb.BB).css(toolspace, {
                left: "",
                right: "0",
                borderLeft: "1px solid rgb(135, 135, 135)",
                borderRight: "none"
            });
            (0, _bb.BB).css(klCanvasWorkspace.getElement(), {
                left: "0"
            });
        }
        statusOverlay.setUiState(uiState);
        layerPreview.setUiState("" + uiState);
        layerManager.setUiState("" + uiState);
        updateCollapse();
        toolspaceScroller.updateUiState(uiState);
    }
    let overlayToolspace;
    setTimeout(function() {
        overlayToolspace = new (0, _kl.KL).OverlayToolspace({
            enabledTest: function() {
                return (0, _kl.KL).dialogCounter.get() === 0 && !lineSanitizer.getIsDrawing();
            },
            brushSettingService
        });
        klRootEl.appendChild(overlayToolspace.getElement());
    }, 0);
    (0, _bb.BB).append(klRootEl, [
        klCanvasWorkspace.getElement(),
        toolspace,
        toolspaceCollapser.getElement()
    ]);
    (0, _bb.BB).css(toolspace, {
        position: "absolute",
        right: "0",
        top: "0",
        bottom: "0",
        width: toolWidth - 1 + "px",
        overflow: "hidden",
        backgroundColor: "#ddd",
        borderLeft: "1px solid rgb(135, 135, 135)",
        userSelect: "none",
        touchAction: "none"
    });
    let toolspaceTopRow;
    if (pOptions.embed) toolspaceTopRow = new (0, _toolspaceTopRow.ToolspaceTopRow)({
        onHelp: ()=>{
            (0, _showIframePopup.showIframePopup)(pOptions.embed.url + "/help.html", !!pOptions.embed);
        },
        onSubmit: ()=>{
            (0, _kl.KL).popup({
                target: klRootEl,
                message: (0, _language.LANG)("submit-prompt"),
                buttons: [
                    (0, _language.LANG)("submit"),
                    "Cancel"
                ],
                callback: async (result)=>{
                    if (result !== (0, _language.LANG)("submit")) return;
                    let overlay = (0, _bb.BB).el({
                        parent: klRootEl,
                        className: "upload-overlay",
                        content: '<div class="spinner"></div> ' + (0, _language.LANG)("submit-submitting")
                    });
                    pOptions.embed.onSubmit(()=>{
                        pOptions.saveReminder.reset();
                        klRootEl.removeChild(overlay);
                    }, ()=>{
                        klRootEl.removeChild(overlay);
                    });
                }
            });
        },
        onLeftRight: ()=>{
            uiState = uiState === "left" ? "right" : "left";
            updateUi();
        }
    });
    else toolspaceTopRow = new (0, _kl.KL).ToolspaceTopRow({
        logoImg: pOptions.logoImg,
        onLogo: function() {
            (0, _showIframePopup.showIframePopup)("./home/", !!pOptions.embed);
        },
        onNew: function() {
            showNewImageDialog();
        },
        onImport: function() {
            fileTab.triggerImport();
        },
        onSave: function() {
            saveToComputer.save();
        },
        onShare: function() {
            shareImage();
        },
        onHelp: function() {
            (0, _showIframePopup.showIframePopup)("./help/", !!pOptions.embed);
        }
    });
    toolspaceTopRow.getElement().classList.add("toolspace-row-shadow");
    toolspaceTopRow.getElement().style.marginBottom = "10px";
    toolspaceInner.appendChild(toolspaceTopRow.getElement());
    let toolspaceToolRow = new (0, _kl.KL).ToolspaceToolRow({
        onActivate: function(activeStr) {
            if (activeStr === "draw") klCanvasWorkspace.setMode("draw");
            else if (activeStr === "hand") klCanvasWorkspace.setMode("hand");
            else if (activeStr === "fill") klCanvasWorkspace.setMode("fill");
            else if (activeStr === "gradient") klCanvasWorkspace.setMode("gradient");
            else if (activeStr === "text") klCanvasWorkspace.setMode("text");
            else if (activeStr === "shape") klCanvasWorkspace.setMode("shape");
            else throw new Error("unknown activeStr");
            mainTabRow.open(activeStr);
            updateMainTabVisibility();
            klColorSlider.pickingDone();
        },
        onZoomIn: function() {
            klCanvasWorkspace.zoomByStep(keyListener.isPressed("shift") ? 1 / 8 : 0.5);
        },
        onZoomOut: function() {
            klCanvasWorkspace.zoomByStep(keyListener.isPressed("shift") ? -1 / 8 : -0.5);
        },
        onUndo: function() {
            undoRedoCatchup.undo();
        },
        onRedo: function() {
            undoRedoCatchup.redo();
        }
    });
    toolspaceToolRow.setIsSmall(uiHeight < 540);
    (0, _klHistory.klHistory).addListener(function() {
        toolspaceToolRow.setEnableUndo((0, _klHistory.klHistory).canUndo());
        toolspaceToolRow.setEnableRedo((0, _klHistory.klHistory).canRedo());
    });
    toolspaceToolRow.getElement().classList.add("toolspace-row-shadow");
    toolspaceInner.appendChild(toolspaceToolRow.getElement());
    let klColorSlider;
    function setCurrentBrush(brushId) {
        if (brushId !== "eraserBrush") lastNonEraserBrushId = brushId;
        if (klColorSlider) {
            if (brushId === "eraserBrush") klColorSlider.enable(false);
            else klColorSlider.enable(true);
        }
        currentBrushId = brushId;
        currentBrush = brushUiObj[brushId];
        currentBrush.setColor(currentColor);
        currentBrush.setContext(currentLayerCtx);
        klCanvasWorkspace.setMode("draw");
        toolspaceToolRow.setActive("draw");
        updateMainTabVisibility();
    }
    function setCurrentLayer(layer) {
        currentLayerCtx = layer.context;
        currentBrush.setContext(layer.context);
        layerPreview.setLayer(layer);
    }
    function setBrushColor(p_color) {
        currentColor = p_color;
        currentBrush.setColor(p_color);
        brushSettingService.emitColor(p_color);
        klColorSlider.pickingDone();
    }
    klColorSlider = new (0, _kl.KL).KlColorSlider({
        width: 250,
        height: 30,
        svHeight: 100,
        startValue: new (0, _bb.BB).RGB(0, 0, 0),
        onPick: setBrushColor
    });
    klColorSlider.setHeight(Math.max(163, Math.min(400, uiHeight - 505)));
    klColorSlider.setPickCallback(function(doPick) {
        if (doPick) klCanvasWorkspace.setMode("pick");
        else {
            klCanvasWorkspace.setMode(toolspaceToolRow.getActive());
            updateMainTabVisibility();
        }
    });
    let brushDiv = document.createElement("div");
    let colorDiv = document.createElement("div");
    (0, _bb.BB).css(colorDiv, {
        margin: "10px",
        display: "flex",
        flexWrap: "wrap",
        justifyContent: "space-between",
        alignItems: "flex-end"
    });
    let toolspaceStabilizerRow = new (0, _kl.KL).ToolspaceStabilizerRow({
        smoothing: 1,
        onSelect: function(v) {
            lineSmoothing.setSmoothing(translateSmoothing(v));
        }
    });
    brushDiv.appendChild(colorDiv);
    (0, _bb.BB).append(colorDiv, [
        klColorSlider.getElement(),
        klColorSlider.getOutputElement(),
        toolspaceStabilizerRow.getElement()
    ]);
    let brushTabRow = new (0, _kl.KL).TabRow({
        initialId: "penBrush",
        useAccent: true,
        tabArr: function() {
            let result = [];
            function createTab(keyStr) {
                return {
                    id: keyStr,
                    image: (0, _kl.KL).brushesUI[keyStr].image,
                    title: (0, _kl.KL).brushesUI[keyStr].tooltip,
                    onOpen: function() {
                        brushUiObj[keyStr].getElement().style.display = "block";
                        setCurrentBrush(keyStr);
                        klColorSlider.pickingDone();
                        brushSettingService.emitSliderConfig({
                            sizeSlider: (0, _kl.KL).brushesUI[keyStr].sizeSlider,
                            opacitySlider: (0, _kl.KL).brushesUI[keyStr].opacitySlider
                        });
                        sizeWatcher(brushUiObj[keyStr].getSize());
                        brushSettingService.emitOpacity(brushUiObj[keyStr].getOpacity());
                    },
                    onClose: function() {
                        brushUiObj[keyStr].getElement().style.display = "none";
                    }
                };
            }
            let keyArr = Object.keys(brushUiObj);
            for(let i = 0; i < keyArr.length; i++)result.push(createTab(keyArr[i]));
            return result;
        }()
    });
    brushDiv.appendChild(brushTabRow.getElement());
    for(let b2 in (0, _kl.KL).brushesUI)if ((0, _kl.KL).brushesUI.hasOwnProperty(b2)) brushDiv.appendChild(brushUiObj[b2].getElement());
    const handUi = new (0, _kl.KL).HandUi({
        scale: 1,
        angleDeg: 0,
        onReset: function() {
            klCanvasWorkspace.resetView(true);
            handUi.update(klCanvasWorkspace.getScale(), klCanvasWorkspace.getAngleDeg());
        },
        onFit: function() {
            klCanvasWorkspace.fitView();
            handUi.update(klCanvasWorkspace.getScale(), klCanvasWorkspace.getAngleDeg());
        },
        onAngleChange: function(angleDeg, isRelative) {
            klCanvasWorkspace.setAngle(angleDeg, isRelative);
            handUi.update(klCanvasWorkspace.getScale(), klCanvasWorkspace.getAngleDeg());
        }
    });
    let fillUi = new (0, _kl.KL).FillUi({
        colorSlider: klColorSlider
    });
    let gradientUi = new (0, _kl.KL).GradientUi({
        colorSlider: klColorSlider
    });
    let textUi = new (0, _kl.KL).TextUi({
        colorSlider: klColorSlider
    });
    let shapeUi = new (0, _kl.KL).ShapeUi({
        colorSlider: klColorSlider
    });
    const gradientTool = new (0, _kl.KL).GradientTool({
        onGradient: (isDone, x1, y1, x2, y2, angleRad)=>{
            const layerIndex = klCanvas.getLayerIndex(currentLayerCtx.canvas);
            const settings = gradientUi.getSettings();
            const gradientObj = {
                type: settings.type,
                color1: klColorSlider.getColor(),
                isReversed: settings.isReversed,
                opacity: settings.opacity,
                doLockAlpha: settings.doLockAlpha,
                isEraser: settings.isEraser,
                doSnap: keyListener.isPressed("shift") || settings.doSnap,
                x1,
                y1,
                x2,
                y2,
                angleRad
            };
            if (isDone) {
                klCanvas.setComposite(layerIndex, null);
                klCanvas.drawGradient(layerIndex, gradientObj);
            } else klCanvas.setComposite(layerIndex, {
                draw: function(ctx) {
                    (0, _kl.KL).drawGradient(ctx, gradientObj);
                }
            });
            klCanvasWorkspace.requestFrame();
        }
    });
    let shapeTool = new (0, _kl.KL).ShapeTool({
        onShape: function(isDone, x1, y1, x2, y2, angleRad) {
            let layerIndex = klCanvas.getLayerIndex(currentLayerCtx.canvas);
            let shapeObj = {
                type: shapeUi.getShape(),
                x1: x1,
                y1: y1,
                x2: x2,
                y2: y2,
                angleRad: angleRad,
                isOutwards: shapeUi.getIsOutwards(),
                opacity: shapeUi.getOpacity(),
                isEraser: shapeUi.getIsEraser(),
                doLockAlpha: shapeUi.getDoLockAlpha()
            };
            if (shapeUi.getShape() === "line") {
                shapeObj.strokeRgb = klColorSlider.getColor();
                shapeObj.lineWidth = shapeUi.getLineWidth();
                shapeObj.isAngleSnap = shapeUi.getIsSnap() || keyListener.isPressed("shift");
            } else {
                shapeObj.isFixedRatio = shapeUi.getIsFixed() || keyListener.isPressed("shift");
                if (shapeUi.getMode() === "stroke") {
                    shapeObj.strokeRgb = klColorSlider.getColor();
                    shapeObj.lineWidth = shapeUi.getLineWidth();
                } else shapeObj.fillRgb = klColorSlider.getColor();
            }
            if (isDone) {
                klCanvas.setComposite(layerIndex, null);
                klCanvas.drawShape(layerIndex, shapeObj);
            } else klCanvas.setComposite(layerIndex, {
                draw: function(ctx) {
                    (0, _kl.KL).drawShape(ctx, shapeObj);
                }
            });
            klCanvasWorkspace.requestFrame();
        }
    });
    const layerManager = (0, _kl.KL).klLayerManager(klCanvas, function(val) {
        setCurrentLayer(klCanvas.getLayer(val));
        (0, _klHistory.klHistory).push({
            tool: [
                "misc"
            ],
            action: "focusLayer",
            params: [
                val
            ]
        });
    }, klRootEl);
    const layerPreview = new (0, _kl.KL).LayerPreview({
        klRootEl: klRootEl,
        onClick: function() {
            mainTabRow.open("layers");
        }
    });
    layerPreview.setIsVisible(uiHeight >= 579);
    layerPreview.setLayer(klCanvas.getLayer(klCanvas.getLayerIndex(currentLayerCtx.canvas)));
    const filterTab = new (0, _kl.KL).FilterTab(klRootEl, klColorSlider, layerManager, // setCurrentLayer,
    klCanvasWorkspace, handUi, ()=>{
        return currentColor;
    }, ()=>{
        return klMaxCanvasSize;
    }, ()=>{
        return klCanvas;
    }, ()=>{
        return currentLayerCtx;
    }, !!pOptions.embed, statusOverlay);
    const undoRedoCatchup = new (0, _kl.KL).UndoRedoCatchup(brushUiObj, layerPreview, layerManager, handUi, klCanvasWorkspace, ()=>{
        if (!initState) throw new Error("initState not initialized");
        return initState;
    }, ()=>klCanvas, ()=>currentLayerCtx, (clctx)=>{
        currentLayerCtx = clctx;
    }, ()=>currentBrush);
    (0, _klHistory.klHistory).addListener((p)=>{
        undoRedoCatchup.catchup(p);
    });
    function showNewImageDialog() {
        (0, _kl.KL).newImageDialog({
            currentColor: currentColor,
            secondaryColor: klColorSlider.getSecondaryRGB(),
            maxCanvasSize: klMaxCanvasSize,
            canvasWidth: klCanvas.getWidth(),
            canvasHeight: klCanvas.getHeight(),
            workspaceWidth: window.innerWidth < collapseThreshold ? uiWidth : uiWidth - toolWidth,
            workspaceHeight: uiHeight,
            onConfirm: function(width, height, color) {
                klCanvas.reset({
                    width: width,
                    height: height,
                    color: color.a === 1 ? color : null
                });
                layerManager.update(0);
                setCurrentLayer(klCanvas.getLayer(0));
                klCanvasWorkspace.resetView();
                handUi.update(klCanvasWorkspace.getScale(), klCanvasWorkspace.getAngleDeg());
                isFirstImage = false;
            },
            onCancel: function() {}
        });
    }
    function shareImage(callback) {
        (0, _bb.BB).shareCanvas({
            canvas: klCanvas.getCompleteCanvas(1),
            fileName: (0, _bb.BB).getDate() + filenameBase + ".png",
            title: (0, _bb.BB).getDate() + filenameBase + ".png",
            callback: callback ? callback : function() {}
        });
    }
    const saveToComputer = new (0, _kl.KL).SaveToComputer(pOptions.saveReminder, klRootEl, ()=>exportType, ()=>klCanvas, filenameBase);
    const fileTab = pOptions.embed ? null : new (0, _kl.KL).FileTab(klRootEl, projectStore, ()=>klCanvas.getProject(), exportType, (type)=>{
        exportType = type;
    }, handleFileSelect, ()=>{
        saveToComputer.save();
    }, showNewImageDialog, shareImage, ()=>{
        (0, _kl.KL).imgurUpload(klCanvas, klRootEl, pOptions.saveReminder, pOptions.app && pOptions.app.imgurKey ? pOptions.app.imgurKey : null);
    }, copyToClipboard, pOptions.saveReminder);
    const settingsTab = new (0, _kl.KL).SettingsTab(()=>{
        uiState = uiState === "left" ? "right" : "left";
        updateUi();
        if (!pOptions.embed) (0, _localStorage.LocalStorage).setItem("uiState", uiState);
    }, pOptions.aboutEl);
    mainTabRow = new (0, _kl.KL).TabRow({
        initialId: "draw",
        tabArr: [
            {
                id: "draw",
                title: (0, _language.LANG)("tool-brush"),
                image: (0, _toolPaintSvgDefault.default),
                onOpen: function() {
                    if (currentBrushId === "eraserBrush") klColorSlider.enable(false);
                    (0, _bb.BB).append(colorDiv, [
                        klColorSlider.getElement(),
                        klColorSlider.getOutputElement(),
                        toolspaceStabilizerRow.getElement()
                    ]);
                    brushDiv.style.display = "block";
                },
                onClose: function() {
                    brushDiv.style.display = "none";
                },
                css: {
                    minWidth: "45px"
                }
            },
            {
                id: "hand",
                title: (0, _language.LANG)("tool-hand"),
                image: (0, _toolHandSvgDefault.default),
                isVisible: false,
                onOpen: function() {
                    handUi.setIsVisible(true);
                },
                onClose: function() {
                    handUi.setIsVisible(false);
                },
                css: {
                    minWidth: "45px"
                }
            },
            {
                id: "fill",
                title: (0, _language.LANG)("tool-paint-bucket"),
                image: (0, _toolFillSvgDefault.default),
                isVisible: false,
                onOpen: function() {
                    klColorSlider.enable(true);
                    fillUi.setIsVisible(true);
                },
                onClose: function() {
                    fillUi.setIsVisible(false);
                },
                css: {
                    minWidth: "45px"
                }
            },
            {
                id: "gradient",
                title: (0, _language.LANG)("tool-gradient"),
                image: (0, _toolGradientSvgDefault.default),
                isVisible: false,
                onOpen: function() {
                    klColorSlider.enable(true);
                    gradientUi.setIsVisible(true);
                },
                onClose: function() {
                    gradientUi.setIsVisible(false);
                },
                css: {
                    minWidth: "45px"
                }
            },
            {
                id: "text",
                title: (0, _language.LANG)("tool-text"),
                image: (0, _toolTextSvgDefault.default),
                isVisible: false,
                onOpen: function() {
                    klColorSlider.enable(true);
                    textUi.setIsVisible(true);
                },
                onClose: function() {
                    textUi.setIsVisible(false);
                },
                css: {
                    minWidth: "45px"
                }
            },
            {
                id: "shape",
                title: (0, _language.LANG)("tool-shape"),
                image: (0, _toolShapeSvgDefault.default),
                isVisible: false,
                onOpen: function() {
                    klColorSlider.enable(true);
                    shapeUi.setIsVisible(true);
                },
                onClose: function() {
                    shapeUi.setIsVisible(false);
                },
                css: {
                    minWidth: "45px"
                }
            },
            {
                id: "layers",
                title: (0, _language.LANG)("tab-layers"),
                image: (0, _tabLayersSvgDefault.default),
                onOpen: function() {
                    layerManager.update();
                    layerManager.style.display = "block";
                },
                onClose: function() {
                    layerManager.style.display = "none";
                },
                css: {
                    minWidth: "45px"
                }
            },
            {
                id: "edit",
                label: (0, _language.LANG)("tab-edit"),
                onOpen: function() {
                    filterTab.show();
                },
                onClose: function() {
                    filterTab.hide();
                },
                css: {
                    padding: "0 7px"
                }
            },
            {
                id: "file",
                label: (0, _language.LANG)("tab-file"),
                isVisible: !!fileTab,
                onOpen: function() {
                    if (!fileTab) return;
                    fileTab.getElement().style.display = "block";
                    fileTab.setIsVisible(true);
                },
                onClose: function() {
                    if (!fileTab) return;
                    fileTab.getElement().style.display = "none";
                    fileTab.setIsVisible(false);
                },
                css: {
                    padding: "0 7px"
                }
            },
            {
                id: "settings",
                title: (0, _language.LANG)("tab-settings"),
                image: (0, _tabSettingsSvgDefault.default),
                onOpen: function() {
                    settingsTab.getElement().style.display = "block";
                // settingsTab.setIsVisible(true);
                },
                onClose: function() {
                    settingsTab.getElement().style.display = "none";
                // settingsTab.setIsVisible(false);
                },
                css: {
                    minWidth: "45px"
                }
            }
        ]
    });
    function updateMainTabVisibility() {
        if (!mainTabRow) return;
        let toolObj = {
            "draw": {},
            "hand": {},
            "fill": {},
            "gradient": {},
            "text": {},
            "shape": {}
        };
        let activeStr = toolspaceToolRow.getActive();
        let oldTabId = mainTabRow.getOpenedTabId();
        let keysArr = Object.keys(toolObj);
        for(let i = 0; i < keysArr.length; i++)if (activeStr === keysArr[i]) mainTabRow.setIsVisible(keysArr[i], true);
        else {
            mainTabRow.setIsVisible(keysArr[i], false);
            if (oldTabId === keysArr[i]) mainTabRow.open(activeStr);
        }
    }
    function copyToClipboard(showCrop) {
        (0, _kl.KL).clipboardDialog(klRootEl, klCanvas.getCompleteCanvas(1), function(inputObj) {
            if (inputObj.left === 0 && inputObj.right === 0 && inputObj.top === 0 && inputObj.bottom === 0) return;
            //do a crop
            (0, _kl.KL).filterLib.cropExtend.apply({
                context: currentLayerCtx,
                klCanvas: klCanvas,
                input: inputObj,
                history: (0, _klHistory.klHistory)
            });
            layerManager.update();
            klCanvasWorkspace.resetView();
            handUi.update(klCanvasWorkspace.getScale(), klCanvasWorkspace.getAngleDeg());
        }, statusOverlay, showCrop);
    }
    const bottomBarWrapper = (0, _bb.BB).el({
        css: {
            width: "270px",
            position: "absolute",
            bottom: "0",
            left: "0"
        }
    });
    if (pOptions.bottomBar) {
        bottomBarWrapper.append(pOptions.bottomBar);
        const observer = new MutationObserver(()=>updateBottomBar());
        observer.observe(toolspaceInner, {
            attributes: true,
            childList: true,
            subtree: true
        });
    }
    function updateBottomBar() {
        if (!pOptions.bottomBar) return;
        const threshold = 617; //590
        const isVisible = threshold < window.innerHeight && toolspaceInner.scrollHeight + 50 < window.innerHeight;
        bottomBarWrapper.style.display = isVisible ? "" : "none";
    }
    (0, _bb.BB).append(toolspaceInner, [
        layerPreview.getElement(),
        mainTabRow.getElement(),
        brushDiv,
        handUi.getElement(),
        fillUi.getElement(),
        gradientUi.getElement(),
        textUi.getElement(),
        shapeUi.getElement(),
        layerManager,
        filterTab.getElement(),
        fileTab ? fileTab.getElement() : null,
        settingsTab.getElement(),
        (0, _bb.BB).el({
            css: {
                height: "10px"
            }
        }),
        bottomBarWrapper ? bottomBarWrapper : null
    ]);
    const toolspaceScroller = new (0, _kl.KL).ToolspaceScroller({
        toolspace,
        uiState
    });
    // --- interface ---
    this.getEl = ()=>{
        return klRootEl;
    };
    this.resize = (w, h)=>{
        // iPad scrolls down when increasing text zoom
        if (window.scrollY > 0) window.scrollTo(0, 0);
        if (uiWidth === Math.max(0, w) && uiHeight === Math.max(0, h)) return;
        uiWidth = Math.max(0, w);
        uiHeight = Math.max(0, h);
        updateCollapse();
        updateBottomBar();
        layerPreview.setIsVisible(uiHeight >= 579);
        klColorSlider.setHeight(Math.max(163, Math.min(400, uiHeight - 505)));
        toolspaceToolRow.setIsSmall(uiHeight < 540);
    };
    this.out = (msg)=>{
        statusOverlay.out(msg);
    };
    this.getPNG = function() {
        return (0, _base64ToBlob.base64ToBlob)(klCanvas.getCompleteCanvas(1).toDataURL("image/png"));
    };
    this.getPSD = async function() {
        return await (0, _klCanvasToPsdBlob.klCanvasToPsdBlob)(klCanvas);
    };
    this.getProject = ()=>klCanvas.getProject();
    this.swapUiLeftRight = ()=>{
        uiState = uiState === "left" ? "right" : "left";
        if (!pOptions.embed) (0, _localStorage.LocalStorage).setItem("uiState", uiState);
        updateUi();
    };
    this.saveAsPsd = ()=>{
        saveToComputer.save("psd");
    };
    this.isDrawing = ()=>{
        return lineSanitizer.getIsDrawing() || klCanvasWorkspace.getIsDrawing();
    };
    // --- end interface ---
    this.resize(uiWidth, uiHeight);
    updateUi();
    {
        (0, _bb.BB).addEventListener(window, "resize", ()=>{
            this.resize(window.innerWidth, window.innerHeight);
        });
        (0, _bb.BB).addEventListener(window, "orientationchange", ()=>{
            this.resize(window.innerWidth, window.innerHeight);
        });
        // iPad doesn't trigger 'resize' event when using text zoom, although it's resizing the window.
        // Workaround: place a div in the body that fills the window, and use a ResizeObserver
        const windowResizeWatcher = (0, _bb.BB).el({
            parent: document.body,
            css: {
                position: "fixed",
                left: "0",
                top: "0",
                right: "0",
                bottom: "0",
                pointerEvents: "none",
                zIndex: "-1",
                userSelect: "none"
            }
        });
        try {
            // Not all browsers support ResizeObserver. Not critical though.
            const observer1 = new ResizeObserver(()=>this.resize(window.innerWidth, window.innerHeight));
            observer1.observe(windowResizeWatcher);
        } catch (e1) {
            windowResizeWatcher.parentNode.removeChild(windowResizeWatcher);
        }
        // prevent ctrl scroll -> zooming page
        (0, _bb.BB).addEventListener(klRootEl, "wheel", (event)=>{
            if (keyListener.isPressed("ctrl")) event.preventDefault();
        });
        //maybe prevent zooming on safari mac os - todo still needed?
        const prevent = (e)=>{
            e.preventDefault();
        };
        window.addEventListener("gesturestart", prevent);
        window.addEventListener("gesturechange", prevent);
        window.addEventListener("gestureend", prevent);
    }
}

},{"../klecks/kl":"8nmWp","../klecks/history/kl-history":"klzEn","../bb/bb":"dcQKo","../klecks/ui/modals/show-iframe-popup":"gD1Cf","../klecks/ui/tool-tabs/file-tab":"3rIr5","../embed/toolspace-top-row":"guBAU","../klecks/filters/filters-lazy":"eBdPo","../klecks/storage/base-64-to-blob":"4JT2T","../klecks/storage/kl-canvas-to-psd-blob":"gh8aB","../language/language":"iiYGN","url:~/src/app/img/ui/tool-paint.svg":"kLkxS","url:~/src/app/img/ui/tool-hand.svg":"gqsT0","url:~/src/app/img/ui/tool-fill.svg":"dcadi","url:~/src/app/img/ui/tool-gradient.svg":"4GC9I","url:~/src/app/img/ui/tool-text.svg":"cQlT4","url:~/src/app/img/ui/tool-shape.svg":"4ddc9","url:~/src/app/img/ui/tab-settings.svg":"czJ1u","url:~/src/app/img/ui/tab-layers.svg":"dKFwY","../bb/base/local-storage":"04p5O","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"guBAU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ToolspaceTopRow", ()=>ToolspaceTopRow);
/**
 * Topmost row of buttons in toolspace
 *
 * p = { // button click callbacks
 *     onSubmit: function(),
 *     onLeftRight: function(),
 *     onHelp: function()
 * }
 *
 * @param p
 * @constructor
 */ var _bb = require("../bb/bb");
// @ts-ignore
var _uiSwapLrSvg = require("url:~/src/app/img/ui/ui-swap-lr.svg");
var _uiSwapLrSvgDefault = parcelHelpers.interopDefault(_uiSwapLrSvg);
// @ts-ignore
var _helpSvg = require("url:~/src/app/img/ui/help.svg");
var _helpSvgDefault = parcelHelpers.interopDefault(_helpSvg);
var _language = require("../language/language");
class ToolspaceTopRow {
    constructor(p){
        let div = document.createElement("div");
        this.el = div;
        (0, _bb.BB).css(div, {
            height: "36px",
            //background: '#f00',
            display: "flex",
            backgroundImage: "linear-gradient(to top, rgba(255, 255, 255, 0) 20%, rgba(255, 255, 255, 0.6) 100%)"
        });
        function createButton(p) {
            let padding = 6 + (p.extraPadding ? p.extraPadding : 0);
            let result = (0, _bb.BB).el({
                className: "toolspace-row-button nohighlight",
                title: p.title,
                onClick: p.onClick,
                css: {
                    padding: p.content ? "" : p.contain ? padding + "px 0" : ""
                }
            });
            if (p.content) result.appendChild(p.content);
            else {
                let im = (0, _bb.BB).el({
                    css: {
                        backgroundImage: "url('" + p.image + "')",
                        backgroundRepeat: "no-repeat",
                        backgroundPosition: "center",
                        backgroundSize: p.contain ? "contain" : "",
                        //filter: 'grayscale(1)',
                        height: "100%"
                    }
                });
                im.style.pointerEvents = "none";
                result.appendChild(im);
            }
            result.pointerListener = new (0, _bb.BB).PointerListener({
                target: result,
                onEnterLeave: function(isOver) {
                    result.classList.toggle("toolspace-row-button-hover", isOver);
                }
            });
            return result;
        }
        let submitButton = createButton({
            onClick: p.onSubmit,
            title: (0, _language.LANG)("submit-title"),
            content: (0, _bb.BB).el({
                content: (0, _language.LANG)("submit"),
                className: "toolspace-row-button__submit",
                css: {
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    width: "100%",
                    height: "100%"
                }
            }),
            contain: true
        });
        submitButton.style.width = "45px";
        let helpButton = createButton({
            onClick: p.onHelp,
            title: (0, _language.LANG)("help"),
            image: (0, _helpSvgDefault.default),
            contain: true
        });
        let leftRightButton = createButton({
            onClick: p.onLeftRight,
            title: (0, _language.LANG)("switch-ui-left-right"),
            image: (0, _uiSwapLrSvgDefault.default),
            contain: true
        });
        div.appendChild(submitButton);
        div.appendChild(leftRightButton);
        div.appendChild(helpButton);
    }
    getElement() {
        return this.el;
    }
}

},{"../bb/bb":"dcQKo","url:~/src/app/img/ui/ui-swap-lr.svg":"fdJ0i","url:~/src/app/img/ui/help.svg":"c0SPg","../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eBdPo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "importFilters", ()=>importFilters);
var _filters = require("./filters");
var _filterBrightnessContrast = require("./filter-brightness-contrast");
var _filterCropExtend = require("./filter-crop-extend");
var _filterCurves = require("./filter-curves");
var _filterFlip = require("./filter-flip");
var _filterHueSaturation = require("./filter-hue-saturation");
var _filterInvert = require("./filter-invert");
var _filterPerspective = require("./filter-perspective");
var _filterResize = require("./filter-resize");
var _filterRotate = require("./filter-rotate");
var _filterTiltShift = require("./filter-tilt-shift");
var _filterTransform = require("./filter-transform");
var _filterBlur = require("./filter-blur");
var _filterUnsharpMask = require("./filter-unsharp-mask");
var _filterToAlpha = require("./filter-to-alpha");
var _filterGrid = require("./filter-grid");
var _filterNoise = require("./filter-noise");
var _filterPattern = require("./filter-pattern");
var _filterDistort = require("./filter-distort");
var _filterVanishPoint = require("./filter-vanish-point");
let embed;
function importFilter(libObj, moduleObj) {
    if (moduleObj.getDialog) libObj.getDialog = moduleObj.getDialog;
    libObj.apply = moduleObj.apply;
}
function importFilters(isEmbed) {
    if ((0, _filters.filterLibStatus).isLoaded) return;
    embed = isEmbed;
    importFilter((0, _filters.filterLib).brightnessContrast, (0, _filterBrightnessContrast.filterBrightnessContrast));
    importFilter((0, _filters.filterLib).cropExtend, (0, _filterCropExtend.filterCropExtend));
    importFilter((0, _filters.filterLib).curves, (0, _filterCurves.filterCurves));
    importFilter((0, _filters.filterLib).flip, (0, _filterFlip.filterFlip));
    importFilter((0, _filters.filterLib).hueSaturation, (0, _filterHueSaturation.filterHueSaturation));
    importFilter((0, _filters.filterLib).invert, (0, _filterInvert.filterInvert));
    importFilter((0, _filters.filterLib).perspective, (0, _filterPerspective.filterPerspective));
    importFilter((0, _filters.filterLib).resize, (0, _filterResize.filterResize));
    importFilter((0, _filters.filterLib).rotate, (0, _filterRotate.filterRotate));
    importFilter((0, _filters.filterLib).tiltShift, (0, _filterTiltShift.filterTiltShift));
    importFilter((0, _filters.filterLib).transform, (0, _filterTransform.filterTransform));
    importFilter((0, _filters.filterLib).blur, (0, _filterBlur.filterBlur));
    importFilter((0, _filters.filterLib).unsharpMask, (0, _filterUnsharpMask.filterUnsharpMask));
    importFilter((0, _filters.filterLib).toAlpha, (0, _filterToAlpha.filterToAlpha));
    importFilter((0, _filters.filterLib).grid, (0, _filterGrid.filterGrid));
    importFilter((0, _filters.filterLib).noise, (0, _filterNoise.filterNoise));
    importFilter((0, _filters.filterLib).pattern, (0, _filterPattern.filterPattern));
    importFilter((0, _filters.filterLib).distort, (0, _filterDistort.filterDistort));
    importFilter((0, _filters.filterLib).vanishPoint, (0, _filterVanishPoint.filterVanishPoint));
    (0, _filters.filterLibStatus).isLoaded = true;
}

},{"./filters":"lIjDv","./filter-brightness-contrast":"8bXtn","./filter-crop-extend":"46o4U","./filter-curves":"gJs7S","./filter-flip":"4eiAA","./filter-hue-saturation":"kj8ue","./filter-invert":"1YJog","./filter-perspective":"3vxXl","./filter-resize":"kqYtn","./filter-rotate":"8CV7p","./filter-tilt-shift":"5Dznd","./filter-transform":"7kdP4","./filter-blur":"5iOmO","./filter-unsharp-mask":"1fHVB","./filter-to-alpha":"iGpbg","./filter-grid":"bN7Vm","./filter-noise":"eLTh7","./filter-pattern":"ltDe9","./filter-distort":"dW7B1","./filter-vanish-point":"ftQ30","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8bXtn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterBrightnessContrast", ()=>filterBrightnessContrast);
var _bb = require("../../bb/bb");
var _klSlider = require("../ui/base-components/kl-slider");
var _filtersConsts = require("./filters-consts");
var _canvasPreview = require("../canvas-ui/canvas-preview");
var _sharedGlFx = require("./shared-gl-fx");
var _language = require("../../language/language");
const filterBrightnessContrast = {
    getDialog (params) {
        let div = document.createElement("div");
        let result = {
            element: div
        };
        let context = params.context;
        let klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        let layers = klCanvas.getLayers();
        let selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        let fit = (0, _bb.BB).fitInto(context.canvas.width, context.canvas.height, 280, 200, 1);
        let w = parseInt("" + fit.width), h = parseInt("" + fit.height);
        let tempCanvas = (0, _bb.BB).canvas(w, h);
        {
            const ctx = tempCanvas.getContext("2d");
            ctx.save();
            if (tempCanvas.width > context.canvas.width) ctx.imageSmoothingEnabled = false;
            ctx.drawImage(context.canvas, 0, 0, w, h);
            ctx.restore();
        }
        function finishInit() {
            let brightness = 0, contrast = 0;
            div.innerHTML = (0, _language.LANG)("filter-bright-contrast-description") + "<br/><br/>";
            let glCanvas = (0, _sharedGlFx.getSharedFx)();
            if (!glCanvas) return; // todo throw?
            let texture = glCanvas.texture(tempCanvas);
            glCanvas.draw(texture).update(); // update glCanvas size
            let brightnessSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("filter-bright-contrast-brightness"),
                width: 300,
                height: 30,
                min: 0,
                max: 100,
                value: (brightness + 1) * 50,
                eventResMs: (0, _filtersConsts.eventResMs),
                onChange: function(val) {
                    brightness = val / 50 - 1;
                    glCanvas.draw(texture).brightnessContrast(brightness, contrast).update();
                    klCanvasPreview.render();
                }
            });
            let contrastSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("filter-bright-contrast-contrast"),
                width: 300,
                height: 30,
                min: 0,
                max: 100,
                value: (contrast + 1) * 50,
                eventResMs: (0, _filtersConsts.eventResMs),
                onChange: function(val) {
                    contrast = val / 50 - 1;
                    glCanvas.draw(texture).brightnessContrast(brightness, contrast).update();
                    klCanvasPreview.render();
                }
            });
            brightnessSlider.getElement().style.marginBottom = "10px";
            div.appendChild(brightnessSlider.getElement());
            div.appendChild(contrastSlider.getElement());
            let previewWrapper = document.createElement("div");
            (0, _bb.BB).css(previewWrapper, {
                width: "340px",
                marginLeft: "-20px",
                height: "220px",
                backgroundColor: "#9e9e9e",
                marginTop: "10px",
                boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
                overflow: "hidden",
                position: "relative",
                userSelect: "none",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                colorScheme: "only light"
            });
            let previewLayerArr = [];
            for(let i = 0; i < layers.length; i++)previewLayerArr.push({
                image: i === selectedLayerIndex ? glCanvas : layers[i].context.canvas,
                opacity: layers[i].opacity,
                mixModeStr: layers[i].mixModeStr
            });
            let klCanvasPreview = new (0, _canvasPreview.KlCanvasPreview)({
                width: parseInt("" + w),
                height: parseInt("" + h),
                layers: previewLayerArr
            });
            let previewInnerWrapper = (0, _bb.BB).el({
                css: {
                    position: "relative",
                    boxShadow: "0 0 5px rgba(0,0,0,0.5)",
                    width: parseInt("" + w) + "px",
                    height: parseInt("" + h) + "px"
                }
            });
            previewInnerWrapper.appendChild(klCanvasPreview.getElement());
            previewWrapper.appendChild(previewInnerWrapper);
            div.appendChild(previewWrapper);
            try {
                glCanvas.draw(texture).brightnessContrast(brightness, contrast).update();
                klCanvasPreview.render();
            } catch (e) {
                div.errorCallback(e);
            }
            result.destroy = ()=>{
                brightnessSlider.destroy();
                contrastSlider.destroy();
                texture.destroy();
            };
            result.getInput = function() {
                result.destroy();
                return {
                    brightness: brightness,
                    contrast: contrast
                };
            };
        }
        setTimeout(finishInit, 1); // the canvas isn't ready for some reason
        return result;
    },
    apply (params) {
        let context = params.context;
        let brightness = params.input.brightness;
        let contrast = params.input.contrast;
        let history = params.history;
        if (!context || brightness === null || contrast === null || !history) return false;
        history.pause(true);
        let glCanvas = (0, _sharedGlFx.getSharedFx)();
        if (!glCanvas) return false; // todo more specific error?
        let texture = glCanvas.texture(context.canvas);
        glCanvas.draw(texture).brightnessContrast(brightness, contrast).update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(glCanvas, 0, 0);
        texture.destroy();
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "brightnessContrast"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","../ui/base-components/kl-slider":"6YGce","./filters-consts":"7Xzbl","../canvas-ui/canvas-preview":"gRZnS","./shared-gl-fx":"4bJZi","../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7Xzbl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "eventResMs", ()=>eventResMs);
const eventResMs = 60;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4bJZi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getSharedFx", ()=>getSharedFx);
var _glfx = require("../../../script-vendor/glfx");
let fxCanvas = null;
try {
    fxCanvas = (0, _glfx.fx).canvas();
} catch (e) {}
function getSharedFx() {
    if (!fxCanvas || fxCanvas._.gl.isContextLost()) try {
        fxCanvas = (0, _glfx.fx).canvas();
    } catch (e) {}
    return fxCanvas;
}

},{"../../../script-vendor/glfx":"dTobR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dTobR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fx", ()=>fx);
// @ts-ignore
var _shaderNoiseGlsl = require("./shader-noise.glsl");
var _shaderNoiseGlslDefault = parcelHelpers.interopDefault(_shaderNoiseGlsl);
const fx = function() {
    let exports = {};
    // src/OES_texture_float_linear-polyfill.script
    // From: https://github.com/evanw/OES_texture_float_linear-polyfill
    (function() {
        // Uploads a 2x2 floating-point texture where one pixel is 2 and the other
        // three pixels are 0. Linear filtering is only supported if a sample taken
        // from the center of that texture is (2 + 0 + 0 + 0) / 4 = 0.5.
        function supportsOESTextureFloatLinear(gl) {
            // Need floating point textures in the first place
            if (!gl.getExtension("OES_texture_float")) return false;
            // Create a render target
            let framebuffer = gl.createFramebuffer();
            let byteTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, byteTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, byteTexture, 0);
            // Create a simple floating-point texture with value of 0.5 in the center
            let rgba = [
                2,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ];
            let floatTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, floatTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, gl.FLOAT, new Float32Array(rgba));
            // Create the test shader
            let program = gl.createProgram();
            let vertexShader = gl.createShader(gl.VERTEX_SHADER);
            let fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(vertexShader, "      attribute vec2 vertex;      void main() {        gl_Position = vec4(vertex, 0.0, 1.0);      }    ");
            gl.shaderSource(fragmentShader, "      uniform sampler2D texture;      void main() {        gl_FragColor = texture2D(texture, vec2(0.5));      }    ");
            gl.compileShader(vertexShader);
            gl.compileShader(fragmentShader);
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            // Create a buffer containing a single point
            let buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                0,
                0
            ]), gl.STREAM_DRAW);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
            // Render the point and read back the rendered pixel
            let pixel = new Uint8Array(4);
            gl.useProgram(program);
            gl.viewport(0, 0, 1, 1);
            gl.bindTexture(gl.TEXTURE_2D, floatTexture);
            gl.drawArrays(gl.POINTS, 0, 1);
            gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
            // The center sample will only have a value of 0.5 if linear filtering works
            return pixel[0] === 127 || pixel[0] === 128;
        }
        // The constructor for the returned extension object
        function OESTextureFloatLinear() {}
        // Cache the extension so it's specific to each context like extensions should be
        function getOESTextureFloatLinear(gl) {
            if (gl.$OES_texture_float_linear$ === void 0) Object.defineProperty(gl, "$OES_texture_float_linear$", {
                enumerable: false,
                configurable: false,
                writable: false,
                value: new OESTextureFloatLinear()
            });
            return gl.$OES_texture_float_linear$;
        }
        // This replaces the real getExtension()
        function getExtension(name) {
            return name === "OES_texture_float_linear" ? getOESTextureFloatLinear(this) : oldGetExtension.call(this, name);
        }
        // This replaces the real getSupportedExtensions()
        function getSupportedExtensions() {
            let extensions = oldGetSupportedExtensions.call(this);
            if (extensions.indexOf("OES_texture_float_linear") === -1) extensions.push("OES_texture_float_linear");
            return extensions;
        }
        // Get a WebGL context
        try {
            let gl1 = document.createElement("canvas").getContext("experimental-webgl");
        } catch (e) {}
        // Don't install the polyfill if the browser already supports it or doesn't have WebGL
        if (!gl || gl.getSupportedExtensions().indexOf("OES_texture_float_linear") !== -1) return;
        // Install the polyfill if linear filtering works with floating-point textures
        let oldGetExtension;
        let oldGetSupportedExtensions;
        if (supportsOESTextureFloatLinear(gl)) {
            oldGetExtension = WebGLRenderingContext.prototype.getExtension;
            oldGetSupportedExtensions = WebGLRenderingContext.prototype.getSupportedExtensions;
            WebGLRenderingContext.prototype.getExtension = getExtension;
            WebGLRenderingContext.prototype.getSupportedExtensions = getSupportedExtensions;
        }
    })();
    // src/core\canvas.script
    var gl;
    function clamp(lo, value, hi) {
        return Math.max(lo, Math.min(value, hi));
    }
    function wrapTexture(texture) {
        return {
            _: texture,
            loadContentsOf: function(element) {
                // Make sure that we're using the correct global WebGL context
                gl = this._.gl;
                this._.loadContentsOf(element);
            },
            destroy: function() {
                // Make sure that we're using the correct global WebGL context
                gl = this._.gl;
                this._.destroy();
            }
        };
    }
    function texture(element) {
        return wrapTexture(Texture.fromElement(element));
    }
    function initialize(width, height) {
        let type = gl.UNSIGNED_BYTE;
        // Go for floating point buffer textures if we can, it'll make the bokeh
        // filter look a lot better. Note that on Windows, ANGLE does not let you
        // render to a floating-point texture when linear filtering is enabled.
        // See http://crbug.com/172278 for more information.
        if (gl.getExtension("OES_texture_float") && gl.getExtension("OES_texture_float_linear")) {
            let testTexture = new Texture(100, 100, gl.RGBA, gl.FLOAT);
            try {
                // Only use gl.FLOAT if we can render to it
                testTexture.drawTo(function() {
                    type = gl.FLOAT;
                });
            } catch (e) {}
            testTexture.destroy();
        }
        if (this._.texture) this._.texture.destroy();
        if (this._.spareTexture) this._.spareTexture.destroy();
        this.width = width;
        this.height = height;
        this._.texture = new Texture(width, height, gl.RGBA, type);
        this._.spareTexture = new Texture(width, height, gl.RGBA, type);
        this._.extraTexture = this._.extraTexture || new Texture(0, 0, gl.RGBA, type);
        this._.flippedShader = this._.flippedShader || new Shader(null, "        uniform sampler2D texture;        varying vec2 texCoord;        void main() {            gl_FragColor = texture2D(texture, vec2(texCoord.x, 1.0 - texCoord.y));        }    ", "flippedShader");
        this._.isInitialized = true;
    }
    /*
       Draw a texture to the canvas, with an optional width and height to scale to.
       If no width and height are given then the original texture width and height
       are used.
    */ function draw(texture, width, height) {
        if (!this._.isInitialized || texture._.width != this.width || texture._.height != this.height) initialize.call(this, width ? width : texture._.width, height ? height : texture._.height);
        texture._.use();
        this._.texture.drawTo(function() {
            Shader.getDefaultShader().drawRect();
        });
        return this;
    }
    function update() {
        this._.texture.use();
        this._.flippedShader.drawRect();
        return this;
    }
    function simpleShader(shader, uniforms, textureIn, textureOut) {
        (textureIn || this._.texture).use();
        this._.spareTexture.drawTo(function() {
            shader.uniforms(uniforms).drawRect();
        });
        this._.spareTexture.swapWith(textureOut || this._.texture);
    }
    function replace(node) {
        node.parentNode.insertBefore(this, node);
        node.parentNode.removeChild(node);
        return this;
    }
    function contents() {
        let texture = new Texture(this._.texture.width, this._.texture.height, gl.RGBA, gl.UNSIGNED_BYTE);
        this._.texture.use();
        texture.drawTo(function() {
            Shader.getDefaultShader().drawRect();
        });
        return wrapTexture(texture);
    }
    /*
       Get a Uint8 array of pixel values: [r, g, b, a, r, g, b, a, ...]
       Length of the array will be width * height * 4.
    */ function getPixelArray() {
        let w = this._.texture.width;
        let h = this._.texture.height;
        let array = new Uint8Array(w * h * 4);
        this._.texture.drawTo(function() {
            gl.readPixels(0, 0, w, h, gl.RGBA, gl.UNSIGNED_BYTE, array);
        });
        return array;
    }
    function wrap(func) {
        return function() {
            // Make sure that we're using the correct global WebGL context
            gl = this._.gl;
            // Now that the context has been switched, we can call the wrapped function
            return func.apply(this, arguments);
        };
    }
    exports.canvas = function() {
        let canvas = document.createElement("canvas");
        try {
            gl = canvas.getContext("experimental-webgl", {
                premultipliedAlpha: false
            });
        } catch (e) {
            gl = null;
        }
        if (!gl) throw "This browser does not support WebGL";
        canvas._ = {
            gl: gl,
            isInitialized: false,
            texture: null,
            spareTexture: null,
            flippedShader: null
        };
        // Core methods
        canvas.texture = wrap(texture);
        canvas.draw = wrap(draw);
        canvas.update = wrap(update);
        canvas.replace = wrap(replace);
        canvas.contents = wrap(contents);
        canvas.getPixelArray = wrap(getPixelArray);
        // Filter methods
        canvas.brightnessContrast = wrap(brightnessContrast);
        canvas.hexagonalPixelate = wrap(hexagonalPixelate);
        canvas.hueSaturation = wrap(hueSaturation);
        canvas.colorHalftone = wrap(colorHalftone);
        canvas.triangleBlur = wrap(triangleBlur);
        canvas.unsharpMask = wrap(unsharpMask);
        canvas.perspective = wrap(perspective);
        canvas.matrixWarp = wrap(matrixWarp);
        canvas.bulgePinch = wrap(bulgePinch);
        canvas.tiltShift = wrap(tiltShift);
        canvas.dotScreen = wrap(dotScreen);
        canvas.edgeWork = wrap(edgeWork);
        canvas.lensBlur = wrap(lensBlur);
        canvas.zoomBlur = wrap(zoomBlur);
        canvas.noise = wrap(noise);
        canvas.denoise = wrap(denoise);
        canvas.curves = wrap(curves);
        canvas.swirl = wrap(swirl);
        canvas.ink = wrap(ink);
        canvas.vignette = wrap(vignette);
        canvas.vibrance = wrap(vibrance);
        canvas.sepia = wrap(sepia);
        canvas.invert = wrap(invert);
        canvas.multiplyAlpha = wrap(multiplyAlpha);
        canvas.unmultiplyAlpha = wrap(unmultiplyAlpha);
        canvas.toAlpha = wrap(toAlpha);
        canvas.distort = wrap(distort);
        return canvas;
    };
    exports.splineInterpolate = splineInterpolate;
    // src/core\matrix.script
    // from javax.media.jai.PerspectiveTransform
    function getSquareToQuad(x0, y0, x1, y1, x2, y2, x3, y3) {
        let dx1 = x1 - x2;
        let dy1 = y1 - y2;
        let dx2 = x3 - x2;
        let dy2 = y3 - y2;
        let dx3 = x0 - x1 + x2 - x3;
        let dy3 = y0 - y1 + y2 - y3;
        let det = dx1 * dy2 - dx2 * dy1;
        let a = (dx3 * dy2 - dx2 * dy3) / det;
        let b = (dx1 * dy3 - dx3 * dy1) / det;
        return [
            x1 - x0 + a * x1,
            y1 - y0 + a * y1,
            a,
            x3 - x0 + b * x3,
            y3 - y0 + b * y3,
            b,
            x0,
            y0,
            1
        ];
    }
    function getInverse(m) {
        let a = m[0], b = m[1], c = m[2];
        let d = m[3], e = m[4], f = m[5];
        let g = m[6], h = m[7], i = m[8];
        let det = a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
        return [
            (e * i - f * h) / det,
            (c * h - b * i) / det,
            (b * f - c * e) / det,
            (f * g - d * i) / det,
            (a * i - c * g) / det,
            (c * d - a * f) / det,
            (d * h - e * g) / det,
            (b * g - a * h) / det,
            (a * e - b * d) / det
        ];
    }
    function multiply(a, b) {
        return [
            a[0] * b[0] + a[1] * b[3] + a[2] * b[6],
            a[0] * b[1] + a[1] * b[4] + a[2] * b[7],
            a[0] * b[2] + a[1] * b[5] + a[2] * b[8],
            a[3] * b[0] + a[4] * b[3] + a[5] * b[6],
            a[3] * b[1] + a[4] * b[4] + a[5] * b[7],
            a[3] * b[2] + a[4] * b[5] + a[5] * b[8],
            a[6] * b[0] + a[7] * b[3] + a[8] * b[6],
            a[6] * b[1] + a[7] * b[4] + a[8] * b[7],
            a[6] * b[2] + a[7] * b[5] + a[8] * b[8]
        ];
    }
    // src/core\shader.script
    var Shader = function() {
        function isArray(obj) {
            return Object.prototype.toString.call(obj) == "[object Array]";
        }
        function isNumber(obj) {
            return Object.prototype.toString.call(obj) == "[object Number]";
        }
        function compileSource(type, source, nameStr) {
            let shader = gl.createShader(type);
            gl.shaderSource(shader, source.replace(/#define.*/, "")); // glslify adds a line add the beginning that breaks it
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) throw "compile error: " + nameStr + " - " + gl.getShaderInfoLog(shader);
            return shader;
        }
        let defaultVertexSource = "    attribute vec2 vertex;    attribute vec2 _texCoord;    varying vec2 texCoord;    void main() {        texCoord = _texCoord;        gl_Position = vec4(vertex * 2.0 - 1.0, 0.0, 1.0);    }";
        let defaultFragmentSource = "    uniform sampler2D texture;    varying vec2 texCoord;    void main() {        gl_FragColor = texture2D(texture, texCoord);    }";
        // added test 2020-04-27 bitbof
        let floatPrecision = null;
        function testPrecisionSupport(precisionType) {
            let format = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, precisionType);
            return format !== null && format.precision !== 0;
        }
        function Shader(vertexSource, fragmentSource, nameStr) {
            this.vertexAttribute = null;
            this.texCoordAttribute = null;
            this.program = gl.createProgram();
            vertexSource = vertexSource || defaultVertexSource;
            fragmentSource = fragmentSource || defaultFragmentSource;
            if (floatPrecision === null) floatPrecision = testPrecisionSupport(gl.HIGH_FLOAT) ? "highp" : testPrecisionSupport(gl.MEDIUM_FLOAT) ? "mediump" : "lowp";
            fragmentSource = "precision " + floatPrecision + " float;" + fragmentSource; // annoying requirement is annoying
            gl.attachShader(this.program, compileSource(gl.VERTEX_SHADER, vertexSource, nameStr + "(vertex)"));
            gl.attachShader(this.program, compileSource(gl.FRAGMENT_SHADER, fragmentSource, nameStr + "(fragment)"));
            gl.linkProgram(this.program);
            if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) throw "link error: " + gl.getProgramInfoLog(this.program);
        }
        Shader.prototype.destroy = function() {
            gl.deleteProgram(this.program);
            this.program = null;
        };
        Shader.prototype.uniforms = function(uniforms) {
            gl.useProgram(this.program);
            for(var name in uniforms){
                if (!uniforms.hasOwnProperty(name)) continue;
                let location = gl.getUniformLocation(this.program, name);
                if (location === null) continue; // will be null if the uniform isn't used in the shader
                let value = uniforms[name];
                if (isArray(value)) switch(value.length){
                    case 1:
                        gl.uniform1fv(location, new Float32Array(value));
                        break;
                    case 2:
                        gl.uniform2fv(location, new Float32Array(value));
                        break;
                    case 3:
                        gl.uniform3fv(location, new Float32Array(value));
                        break;
                    case 4:
                        gl.uniform4fv(location, new Float32Array(value));
                        break;
                    case 9:
                        gl.uniformMatrix3fv(location, false, new Float32Array(value));
                        break;
                    case 16:
                        gl.uniformMatrix4fv(location, false, new Float32Array(value));
                        break;
                    default:
                        throw "dont't know how to load uniform \"" + name + '" of length ' + value.length;
                }
                else if (isNumber(value)) gl.uniform1f(location, value);
                else throw 'attempted to set uniform "' + name + '" to invalid value ' + (value || "undefined").toString();
            }
            // allow chaining
            return this;
        };
        // textures are uniforms too but for some reason can't be specified by gl.uniform1f,
        // even though floating point numbers represent the integers 0 through 7 exactly
        Shader.prototype.textures = function(textures) {
            gl.useProgram(this.program);
            for(var name in textures){
                if (!textures.hasOwnProperty(name)) continue;
                gl.uniform1i(gl.getUniformLocation(this.program, name), textures[name]);
            }
            // allow chaining
            return this;
        };
        Shader.prototype.drawRect = function(left, top, right, bottom) {
            let undefined;
            let viewport = gl.getParameter(gl.VIEWPORT);
            top = top !== undefined ? (top - viewport[1]) / viewport[3] : 0;
            left = left !== undefined ? (left - viewport[0]) / viewport[2] : 0;
            right = right !== undefined ? (right - viewport[0]) / viewport[2] : 1;
            bottom = bottom !== undefined ? (bottom - viewport[1]) / viewport[3] : 1;
            if (gl.vertexBuffer == null) gl.vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, gl.vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                left,
                top,
                left,
                bottom,
                right,
                top,
                right,
                bottom
            ]), gl.STATIC_DRAW);
            if (gl.texCoordBuffer == null) {
                gl.texCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, gl.texCoordBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                    0,
                    0,
                    0,
                    1,
                    1,
                    0,
                    1,
                    1
                ]), gl.STATIC_DRAW);
            }
            if (this.vertexAttribute == null) {
                this.vertexAttribute = gl.getAttribLocation(this.program, "vertex");
                gl.enableVertexAttribArray(this.vertexAttribute);
            }
            if (this.texCoordAttribute == null) {
                this.texCoordAttribute = gl.getAttribLocation(this.program, "_texCoord");
                gl.enableVertexAttribArray(this.texCoordAttribute);
            }
            gl.useProgram(this.program);
            gl.bindBuffer(gl.ARRAY_BUFFER, gl.vertexBuffer);
            gl.vertexAttribPointer(this.vertexAttribute, 2, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, gl.texCoordBuffer);
            gl.vertexAttribPointer(this.texCoordAttribute, 2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        };
        Shader.getDefaultShader = function() {
            gl.defaultShader = gl.defaultShader || new Shader();
            return gl.defaultShader;
        };
        return Shader;
    }();
    // src/core\spline.script
    // from SplineInterpolator.cs in the Paint.NET source code
    function SplineInterpolator(points) {
        let n = points.length;
        this.xa = [];
        this.ya = [];
        this.u = [];
        this.y2 = [];
        points.sort(function(a, b) {
            return a[0] - b[0];
        });
        for(var i = 0; i < n; i++){
            this.xa.push(points[i][0]);
            this.ya.push(points[i][1]);
        }
        this.u[0] = 0;
        this.y2[0] = 0;
        for(var i = 1; i < n - 1; ++i){
            // This is the decomposition loop of the tridiagonal algorithm.
            // y2 and u are used for temporary storage of the decomposed factors.
            let wx = this.xa[i + 1] - this.xa[i - 1];
            let sig = (this.xa[i] - this.xa[i - 1]) / wx;
            let p = sig * this.y2[i - 1] + 2.0;
            this.y2[i] = (sig - 1.0) / p;
            let ddydx = (this.ya[i + 1] - this.ya[i]) / (this.xa[i + 1] - this.xa[i]) - (this.ya[i] - this.ya[i - 1]) / (this.xa[i] - this.xa[i - 1]);
            this.u[i] = (6.0 * ddydx / wx - sig * this.u[i - 1]) / p;
        }
        this.y2[n - 1] = 0;
        // This is the backsubstitution loop of the tridiagonal algorithm
        for(var i = n - 2; i >= 0; --i)this.y2[i] = this.y2[i] * this.y2[i + 1] + this.u[i];
    }
    SplineInterpolator.prototype.interpolate = function(x) {
        let n = this.ya.length;
        let klo = 0;
        let khi = n - 1;
        // We will find the right place in the table by means of
        // bisection. This is optimal if sequential calls to this
        // routine are at random values of x. If sequential calls
        // are in order, and closely spaced, one would do better
        // to store previous values of klo and khi.
        while(khi - klo > 1){
            let k = khi + klo >> 1;
            if (this.xa[k] > x) khi = k;
            else klo = k;
        }
        let h = this.xa[khi] - this.xa[klo];
        let a = (this.xa[khi] - x) / h;
        let b = (x - this.xa[klo]) / h;
        // Cubic spline polynomial is now evaluated.
        return a * this.ya[klo] + b * this.ya[khi] + ((a * a * a - a) * this.y2[klo] + (b * b * b - b) * this.y2[khi]) * (h * h) / 6.0;
    };
    // src/core\texture.script
    var Texture = function() {
        Texture.fromElement = function(element) {
            let texture = new Texture(0, 0, gl.RGBA, gl.UNSIGNED_BYTE);
            texture.loadContentsOf(element);
            return texture;
        };
        function Texture(width, height, format, type) {
            this.gl = gl;
            this.id = gl.createTexture();
            this.width = width;
            this.height = height;
            this.format = format;
            this.type = type;
            gl.bindTexture(gl.TEXTURE_2D, this.id);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            if (width && height) gl.texImage2D(gl.TEXTURE_2D, 0, this.format, width, height, 0, this.format, this.type, null);
        }
        Texture.prototype.loadContentsOf = function(element) {
            this.width = element.width || element.videoWidth;
            this.height = element.height || element.videoHeight;
            gl.bindTexture(gl.TEXTURE_2D, this.id);
            gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.format, this.type, element);
        };
        Texture.prototype.initFromBytes = function(width, height, data) {
            this.width = width;
            this.height = height;
            this.format = gl.RGBA;
            this.type = gl.UNSIGNED_BYTE;
            gl.bindTexture(gl.TEXTURE_2D, this.id);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, this.type, new Uint8Array(data));
        };
        Texture.prototype.destroy = function() {
            gl.deleteTexture(this.id);
            this.id = null;
        };
        Texture.prototype.use = function(unit) {
            gl.activeTexture(gl.TEXTURE0 + (unit || 0));
            gl.bindTexture(gl.TEXTURE_2D, this.id);
        };
        Texture.prototype.unuse = function(unit) {
            gl.activeTexture(gl.TEXTURE0 + (unit || 0));
            gl.bindTexture(gl.TEXTURE_2D, null);
        };
        Texture.prototype.ensureFormat = function(width, height, format, type) {
            // allow passing an existing texture instead of individual arguments
            if (arguments.length == 1) {
                let texture = arguments[0];
                width = texture.width;
                height = texture.height;
                format = texture.format;
                type = texture.type;
            }
            // change the format only if required
            if (width != this.width || height != this.height || format != this.format || type != this.type) {
                this.width = width;
                this.height = height;
                this.format = format;
                this.type = type;
                gl.bindTexture(gl.TEXTURE_2D, this.id);
                gl.texImage2D(gl.TEXTURE_2D, 0, this.format, width, height, 0, this.format, this.type, null);
            }
        };
        Texture.prototype.drawTo = function(callback) {
            // start rendering to this texture
            gl.framebuffer = gl.framebuffer || gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, gl.framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.id, 0);
            if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) throw new Error("incomplete framebuffer");
            gl.viewport(0, 0, this.width, this.height);
            // do the drawing
            callback();
            // stop rendering to this texture
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        };
        let canvas = null;
        function getCanvas(texture) {
            if (canvas == null) canvas = document.createElement("canvas");
            canvas.width = texture.width;
            canvas.height = texture.height;
            let c = canvas.getContext("2d");
            c.clearRect(0, 0, canvas.width, canvas.height);
            return c;
        }
        Texture.prototype.fillUsingCanvas = function(callback) {
            callback(getCanvas(this));
            this.format = gl.RGBA;
            this.type = gl.UNSIGNED_BYTE;
            gl.bindTexture(gl.TEXTURE_2D, this.id);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
            return this;
        };
        Texture.prototype.toImage = function(image) {
            this.use();
            Shader.getDefaultShader().drawRect();
            let size = this.width * this.height * 4;
            let pixels = new Uint8Array(size);
            let c = getCanvas(this);
            let data = c.createImageData(this.width, this.height);
            gl.readPixels(0, 0, this.width, this.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
            for(var i = 0; i < size; i++)data.data[i] = pixels[i];
            c.putImageData(data, 0, 0);
            image.src = canvas.toDataURL();
        };
        Texture.prototype.swapWith = function(other) {
            let temp;
            temp = other.id;
            other.id = this.id;
            this.id = temp;
            temp = other.width;
            other.width = this.width;
            this.width = temp;
            temp = other.height;
            other.height = this.height;
            this.height = temp;
            temp = other.format;
            other.format = this.format;
            this.format = temp;
        };
        return Texture;
    }();
    // src/filters\common.script
    function warpShader(uniforms, warp) {
        return new Shader(null, uniforms + "    uniform sampler2D texture;    uniform vec2 texSize;    varying vec2 texCoord;    void main() {        vec2 coord = texCoord * texSize;        " + warp + "        gl_FragColor = texture2D(texture, coord / texSize);        vec2 clampedCoord = clamp(coord, vec2(0.0), texSize);        if (coord != clampedCoord) {            /* fade to transparent if we are outside the image */            gl_FragColor.a *= max(0.0, 1.0 - length(coord - clampedCoord));        }    }", "warp");
    }
    // returns a random number between 0 and 1
    var randomShaderFunc = "    float random(vec3 scale, float seed) {        /* use the fragment position for a different seed per-pixel */        return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);    }";
    // src/filters\adjust\brightnesscontrast.script
    /**
     * @filter           Brightness / Contrast
     * @description      Provides additive brightness and multiplicative contrast control.
     * @param brightness -1 to 1 (-1 is solid black, 0 is no change, and 1 is solid white)
     * @param contrast   -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)
     */ function brightnessContrast(brightness, contrast) {
        gl.brightnessContrast = gl.brightnessContrast || new Shader(null, "        uniform sampler2D texture;        uniform float brightness;        uniform float contrast;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);            color.rgb += brightness;            if (contrast > 0.0) {                color.rgb = (color.rgb - 0.5) / (1.0 - contrast) + 0.5;            } else {                color.rgb = (color.rgb - 0.5) * (1.0 + contrast) + 0.5;            }            gl_FragColor = color;        }    ", "brightnessContrast");
        simpleShader.call(this, gl.brightnessContrast, {
            brightness: clamp(-1, brightness, 1),
            contrast: clamp(-1, contrast, 1)
        });
        return this;
    }
    // src/filters\adjust\curves.script
    function splineInterpolate(points) {
        let interpolator = new SplineInterpolator(points);
        let array = [];
        for(var i = 0; i < 256; i++)array.push(clamp(0, Math.floor(interpolator.interpolate(i / 255) * 256), 255));
        return array;
    }
    /**
     * @filter      Curves
     * @description A powerful mapping tool that transforms the colors in the image
     *              by an arbitrary function. The function is interpolated between
     *              a set of 2D points using splines. The curves filter can take
     *              either one or three arguments which will apply the mapping to
     *              either luminance or RGB values, respectively.
     * @param red   A list of points that define the function for the red channel.
     *              Each point is a list of two values: the value before the mapping
     *              and the value after the mapping, both in the range 0 to 1. For
     *              example, [[0,1], [1,0]] would invert the red channel while
     *              [[0,0], [1,1]] would leave the red channel unchanged. If green
     *              and blue are omitted then this argument also applies to the
     *              green and blue channels.
     * @param green (optional) A list of points that define the function for the green
     *              channel (just like for red).
     * @param blue  (optional) A list of points that define the function for the blue
     *              channel (just like for red).
     */ function curves(red, green, blue) {
        // Create the ramp texture
        red = splineInterpolate(red);
        if (arguments.length == 1) green = blue = red;
        else {
            green = splineInterpolate(green);
            blue = splineInterpolate(blue);
        }
        let array = [];
        for(var i = 0; i < 256; i++)array.splice(array.length, 0, red[i], green[i], blue[i], 255);
        this._.extraTexture.initFromBytes(256, 1, array);
        this._.extraTexture.use(1);
        gl.curves = gl.curves || new Shader(null, "        uniform sampler2D texture;        uniform sampler2D map;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);            color.r = texture2D(map, vec2(color.r)).r;            color.g = texture2D(map, vec2(color.g)).g;            color.b = texture2D(map, vec2(color.b)).b;            gl_FragColor = color;        }    ", "curves");
        gl.curves.textures({
            map: 1
        });
        simpleShader.call(this, gl.curves, {});
        return this;
    }
    // src/filters\adjust\denoise.script
    /**
     * @filter         Denoise
     * @description    Smooths over grainy noise in dark images using an 9x9 box filter
     *                 weighted by color intensity, similar to a bilateral filter.
     * @param exponent The exponent of the color intensity difference, should be greater
     *                 than zero. A value of zero just gives an 9x9 box blur and high values
     *                 give the original image, but ideal values are usually around 10-20.
     */ function denoise(exponent) {
        // Do a 9x9 bilateral box filter
        gl.denoise = gl.denoise || new Shader(null, "        uniform sampler2D texture;        uniform float exponent;        uniform float strength;        uniform vec2 texSize;        varying vec2 texCoord;        void main() {            vec4 center = texture2D(texture, texCoord);            vec4 color = vec4(0.0);            float total = 0.0;            for (float x = -4.0; x <= 4.0; x += 1.0) {                for (float y = -4.0; y <= 4.0; y += 1.0) {                    vec4 sample = texture2D(texture, texCoord + vec2(x, y) / texSize);                    float weight = 1.0 - abs(dot(sample.rgb - center.rgb, vec3(0.25)));                    weight = pow(weight, exponent);                    color += sample * weight;                    total += weight;                }            }            gl_FragColor = color / total;        }    ", "denoise");
        // Perform two iterations for stronger results
        for(var i = 0; i < 2; i++)simpleShader.call(this, gl.denoise, {
            exponent: Math.max(0, exponent),
            texSize: [
                this.width,
                this.height
            ]
        });
        return this;
    }
    // src/filters\adjust\huesaturation.script
    /**
     * @filter           Hue / Saturation
     * @description      Provides rotational hue and multiplicative saturation control. RGB color space
     *                   can be imagined as a cube where the axes are the red, green, and blue color
     *                   values. Hue changing works by rotating the color vector around the grayscale
     *                   line, which is the straight line from black (0, 0, 0) to white (1, 1, 1).
     *                   Saturation is implemented by scaling all color channel values either toward
     *                   or away from the average color channel value.
     * @param hue        -1 to 1 (-1 is 180 degree rotation in the negative direction, 0 is no change,
     *                   and 1 is 180 degree rotation in the positive direction)
     * @param saturation -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)
     */ function hueSaturation(hue, saturation) {
        gl.hueSaturation = gl.hueSaturation || new Shader(null, "        uniform sampler2D texture;        uniform float hue;        uniform float saturation;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);                        /* hue adjustment, wolfram alpha: RotationTransform[angle, {1, 1, 1}][{x, y, z}] */            float angle = hue * 3.14159265;            float s = sin(angle), c = cos(angle);            vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;            float len = length(color.rgb);            color.rgb = vec3(                dot(color.rgb, weights.xyz),                dot(color.rgb, weights.zxy),                dot(color.rgb, weights.yzx)            );                        /* saturation adjustment */            float average = (color.r + color.g + color.b) / 3.0;            if (saturation > 0.0) {                color.rgb += (average - color.rgb) * (1.0 - 1.0 / (1.001 - saturation));            } else {                color.rgb += (average - color.rgb) * (-saturation);            }                        gl_FragColor = color;        }    ", "hueSaturation");
        simpleShader.call(this, gl.hueSaturation, {
            hue: clamp(-1, hue, 1),
            saturation: clamp(-1, saturation, 1)
        });
        return this;
    }
    // src/filters\adjust\noise.script
    /**
     * @filter         Noise
     * @description    draws noise, completely replaces original image
     * @param seed
     * @param type
     * @param scale
     * @param offset
     * @param octaves
     * @param samples
     * @param peaks
     * @param brightness
     * @param contrast
     * @param isReversed
     * @param colA
     * @param colB
     * @param channels
     */ function noise(seed, type, scale, offset, octaves, samples, peaks, brightness, contrast, isReversed, colA, colB, channels) {
        gl.noise = gl.noise || new Shader(null, (0, _shaderNoiseGlslDefault.default).replace(/#define.*/, ""), "noise");
        simpleShader.call(this, gl.noise, {
            seed,
            type,
            scale: [
                scale[0],
                scale[1]
            ],
            offset,
            octaves,
            samples,
            texSize: [
                this.width,
                this.height
            ],
            peaks,
            brightness,
            contrast,
            isReversed: isReversed ? 1.0 : 0.0,
            colA: colA ? [
                colA.r / 255,
                colA.g / 255,
                colA.b / 255
            ] : [
                0,
                0,
                0
            ],
            colB: colB ? [
                colB.r / 255,
                colB.g / 255,
                colB.b / 255
            ] : [
                1,
                1,
                1
            ],
            channels: channels === "rgb" ? 0 : 1
        });
        return this;
    }
    // src/filters\adjust\sepia.script
    /**
     * @filter         Sepia
     * @description    Gives the image a reddish-brown monochrome tint that imitates an old photograph.
     * @param amount   0 to 1 (0 for no effect, 1 for full sepia coloring)
     */ function sepia(amount) {
        gl.sepia = gl.sepia || new Shader(null, "        uniform sampler2D texture;        uniform float amount;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);            float r = color.r;            float g = color.g;            float b = color.b;                        color.r = min(1.0, (r * (1.0 - (0.607 * amount))) + (g * (0.769 * amount)) + (b * (0.189 * amount)));            color.g = min(1.0, (r * 0.349 * amount) + (g * (1.0 - (0.314 * amount))) + (b * 0.168 * amount));            color.b = min(1.0, (r * 0.272 * amount) + (g * 0.534 * amount) + (b * (1.0 - (0.869 * amount))));                        gl_FragColor = color;        }    ", "sepia");
        simpleShader.call(this, gl.sepia, {
            amount: clamp(0, amount, 1)
        });
        return this;
    }
    // src/filters\adjust\unsharpmask.script
    /**
     * @filter         Unsharp Mask
     * @description    A form of image sharpening that amplifies high-frequencies in the image. It
     *                 is implemented by scaling pixels away from the average of their neighbors.
     * @param radius   The blur radius that calculates the average of the neighboring pixels.
     * @param strength A scale factor where 0 is no effect and higher values cause a stronger effect.
     */ function unsharpMask(radius, strength) {
        gl.unsharpMask = gl.unsharpMask || new Shader(null, "        uniform sampler2D blurredTexture;        uniform sampler2D originalTexture;        uniform float strength;        uniform float threshold;        varying vec2 texCoord;        void main() {            vec4 blurred = texture2D(blurredTexture, texCoord);            vec4 original = texture2D(originalTexture, texCoord);            gl_FragColor = mix(blurred, original, 1.0 + strength);        }    ", "unsharpMask");
        // Store a copy of the current texture in the second texture unit
        this._.extraTexture.ensureFormat(this._.texture);
        this._.texture.use();
        this._.extraTexture.drawTo(function() {
            Shader.getDefaultShader().drawRect();
        });
        // Blur the current texture, then use the stored texture to detect edges
        this._.extraTexture.use(1);
        this.triangleBlur(radius);
        gl.unsharpMask.textures({
            originalTexture: 1
        });
        simpleShader.call(this, gl.unsharpMask, {
            strength: strength
        });
        this._.extraTexture.unuse(1);
        return this;
    }
    // src/filters\adjust\vibrance.script
    /**
     * @filter       Vibrance
     * @description  Modifies the saturation of desaturated colors, leaving saturated colors unmodified.
     * @param amount -1 to 1 (-1 is minimum vibrance, 0 is no change, and 1 is maximum vibrance)
     */ function vibrance(amount) {
        gl.vibrance = gl.vibrance || new Shader(null, "        uniform sampler2D texture;        uniform float amount;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);            float average = (color.r + color.g + color.b) / 3.0;            float mx = max(color.r, max(color.g, color.b));            float amt = (mx - average) * (-amount * 3.0);            color.rgb = mix(color.rgb, vec3(mx), amt);            gl_FragColor = color;        }    ", "vibrance");
        simpleShader.call(this, gl.vibrance, {
            amount: clamp(-1, amount, 1)
        });
        return this;
    }
    // src/filters\adjust\vignette.script
    /**
     * @filter         Vignette
     * @description    Adds a simulated lens edge darkening effect.
     * @param size     0 to 1 (0 for center of frame, 1 for edge of frame)
     * @param amount   0 to 1 (0 for no effect, 1 for maximum lens darkening)
     */ function vignette(size, amount) {
        gl.vignette = gl.vignette || new Shader(null, "        uniform sampler2D texture;        uniform float size;        uniform float amount;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);                        float dist = distance(texCoord, vec2(0.5, 0.5));            color.rgb *= smoothstep(0.8, size * 0.799, dist * (amount + size));                        gl_FragColor = color;        }    ", "vignette");
        simpleShader.call(this, gl.vignette, {
            size: clamp(0, size, 1),
            amount: clamp(0, amount, 1)
        });
        return this;
    }
    // src/filters\blur\lensblur.script
    /**
     * @filter           Lens Blur
     * @description      Imitates a camera capturing the image out of focus by using a blur that generates
     *                   the large shapes known as bokeh. The polygonal shape of real bokeh is due to the
     *                   blades of the aperture diaphragm when it isn't fully open. This blur renders
     *                   bokeh from a 6-bladed diaphragm because the computation is more efficient. It
     *                   can be separated into three rhombi, each of which is just a skewed box blur.
     *                   This filter makes use of the floating point texture WebGL extension to implement
     *                   the brightness parameter, so there will be severe visual artifacts if brightness
     *                   is non-zero and the floating point texture extension is not available. The
     *                   idea was from John White's SIGGRAPH 2011 talk but this effect has an additional
     *                   brightness parameter that fakes what would otherwise come from a HDR source.
     * @param radius     the radius of the hexagonal disk convolved with the image
     * @param brightness -1 to 1 (the brightness of the bokeh, negative values will create dark bokeh)
     * @param angle      the rotation of the bokeh in radians
     */ function lensBlur(radius, brightness, angle) {
        // All averaging is done on values raised to a power to make more obvious bokeh
        // (we will raise the average to the inverse power at the end to compensate).
        // Without this the image looks almost like a normal blurred image. This hack is
        // obviously not realistic, but to accurately simulate this we would need a high
        // dynamic range source photograph which we don't have.
        gl.lensBlurPrePass = gl.lensBlurPrePass || new Shader(null, "        uniform sampler2D texture;        uniform float power;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);            color = pow(color, vec4(power));            gl_FragColor = vec4(color);        }    ", "lensBlurPrePass");
        let common = "        uniform sampler2D texture0;        uniform sampler2D texture1;        uniform vec2 delta0;        uniform vec2 delta1;        uniform float power;        varying vec2 texCoord;        " + randomShaderFunc + "        vec4 sample(vec2 delta) {            /* randomize the lookup values to hide the fixed number of samples */            float offset = random(vec3(delta, 151.7182), 0.0);                        vec4 color = vec4(0.0);            float total = 0.0;            for (float t = 0.0; t <= 30.0; t++) {                float percent = (t + offset) / 30.0;                color += texture2D(texture0, texCoord + delta * percent);                total += 1.0;            }            return color / total;        }    ";
        gl.lensBlur0 = gl.lensBlur0 || new Shader(null, common + "        void main() {            gl_FragColor = sample(delta0);        }    ", "lensBlur0");
        gl.lensBlur1 = gl.lensBlur1 || new Shader(null, common + "        void main() {            gl_FragColor = (sample(delta0) + sample(delta1)) * 0.5;        }    ", "lensBlur1");
        gl.lensBlur2 = gl.lensBlur2 || new Shader(null, common + "        void main() {            vec4 color = (sample(delta0) + 2.0 * texture2D(texture1, texCoord)) / 3.0;            gl_FragColor = pow(color, vec4(power));        }    ", "lensBlur2").textures({
            texture1: 1
        });
        // Generate
        let dir = [];
        for(var i = 0; i < 3; i++){
            let a = angle + i * Math.PI * 2 / 3;
            dir.push([
                radius * Math.sin(a) / this.width,
                radius * Math.cos(a) / this.height
            ]);
        }
        let power = Math.pow(10, clamp(-1, brightness, 1));
        // Remap the texture values, which will help make the bokeh effect
        simpleShader.call(this, gl.lensBlurPrePass, {
            power: power
        });
        // Blur two rhombi in parallel into extraTexture
        this._.extraTexture.ensureFormat(this._.texture);
        simpleShader.call(this, gl.lensBlur0, {
            delta0: dir[0]
        }, this._.texture, this._.extraTexture);
        simpleShader.call(this, gl.lensBlur1, {
            delta0: dir[1],
            delta1: dir[2]
        }, this._.extraTexture, this._.extraTexture);
        // Blur the last rhombus and combine with extraTexture
        simpleShader.call(this, gl.lensBlur0, {
            delta0: dir[1]
        });
        this._.extraTexture.use(1);
        simpleShader.call(this, gl.lensBlur2, {
            power: 1 / power,
            delta0: dir[2]
        });
        return this;
    }
    // src/filters\blur\tiltshift.script
    /**
     * @filter               Tilt Shift
     * @description          Simulates the shallow depth of field normally encountered in close-up
     *                       photography, which makes the scene seem much smaller than it actually
     *                       is. This filter assumes the scene is relatively planar, in which case
     *                       the part of the scene that is completely in focus can be described by
     *                       a line (the intersection of the focal plane and the scene). An example
     *                       of a planar scene might be looking at a road from above at a downward
     *                       angle. The image is then blurred with a blur radius that starts at zero
     *                       on the line and increases further from the line.
     * @param startX         The x coordinate of the start of the line segment.
     * @param startY         The y coordinate of the start of the line segment.
     * @param endX           The x coordinate of the end of the line segment.
     * @param endY           The y coordinate of the end of the line segment.
     * @param blurRadius     The maximum radius of the pyramid blur.
     * @param gradientRadius The distance from the line at which the maximum blur radius is reached.
     */ function tiltShift(startX, startY, endX, endY, blurRadius, gradientRadius) {
        gl.tiltShift = gl.tiltShift || new Shader(null, "        uniform sampler2D texture;        uniform float blurRadius;        uniform float gradientRadius;        uniform vec2 start;        uniform vec2 end;        uniform vec2 delta;        uniform vec2 texSize;        varying vec2 texCoord;        " + randomShaderFunc + "        void main() {            vec4 color = vec4(0.0);            float total = 0.0;                        /* randomize the lookup values to hide the fixed number of samples */            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);                        vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));            float radius = smoothstep(0.0, 1.0, abs(dot(texCoord * texSize - start, normal)) / gradientRadius) * blurRadius;            for (float t = -30.0; t <= 30.0; t++) {                float percent = (t + offset - 0.5) / 30.0;                float weight = 1.0 - abs(percent);                vec4 sample = texture2D(texture, texCoord + delta / texSize * percent * radius);                                /* switch to pre-multiplied alpha to correctly blur transparent images */                sample.rgb *= sample.a;                                color += sample * weight;                total += weight;            }                        gl_FragColor = color / total;                        /* switch back from pre-multiplied alpha */            gl_FragColor.rgb /= gl_FragColor.a + 0.00001;        }    ", "tiltShift");
        let dx = endX - startX;
        let dy = endY - startY;
        let d = Math.sqrt(dx * dx + dy * dy);
        simpleShader.call(this, gl.tiltShift, {
            blurRadius: blurRadius,
            gradientRadius: gradientRadius,
            start: [
                startX,
                startY
            ],
            end: [
                endX,
                endY
            ],
            delta: [
                dx / d,
                dy / d
            ],
            texSize: [
                this.width,
                this.height
            ]
        });
        simpleShader.call(this, gl.tiltShift, {
            blurRadius: blurRadius,
            gradientRadius: gradientRadius,
            start: [
                startX,
                startY
            ],
            end: [
                endX,
                endY
            ],
            delta: [
                -dy / d,
                dx / d
            ],
            texSize: [
                this.width,
                this.height
            ]
        });
        return this;
    }
    // src/filters\blur\triangleblur.script
    /**
     * @filter       Triangle Blur
     * @description  This is the most basic blur filter, which convolves the image with a
     *               pyramid filter. The pyramid filter is separable and is applied as two
     *               perpendicular triangle filters.
     * @param radius The radius of the pyramid convolved with the image.
     */ function triangleBlur(radius) {
        gl.triangleBlur = gl.triangleBlur || new Shader(null, "        uniform sampler2D texture;        uniform vec2 delta;        varying vec2 texCoord;        " + randomShaderFunc + "        void main() {            vec4 color = vec4(0.0);            float total = 0.0;                        /* randomize the lookup values to hide the fixed number of samples */            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);                        for (float t = -30.0; t <= 30.0; t++) {                float percent = (t + offset - 0.5) / 30.0;                float weight = 1.0 - abs(percent);                vec4 sample = texture2D(texture, texCoord + delta * percent);                                /* switch to pre-multiplied alpha to correctly blur transparent images */                sample.rgb *= sample.a;                                color += sample * weight;                total += weight;            }                        gl_FragColor = color / total;                        /* switch back from pre-multiplied alpha */            gl_FragColor.rgb /= gl_FragColor.a + 0.00001;        }    ", "triangleBlur");
        simpleShader.call(this, gl.triangleBlur, {
            delta: [
                radius / this.width,
                0
            ]
        });
        simpleShader.call(this, gl.triangleBlur, {
            delta: [
                0,
                radius / this.height
            ]
        });
        return this;
    }
    // src/filters\blur\zoomblur.script
    /**
     * @filter         Zoom Blur
     * @description    Blurs the image away from a certain point, which looks like radial motion blur.
     * @param centerX  The x coordinate of the blur origin.
     * @param centerY  The y coordinate of the blur origin.
     * @param strength The strength of the blur. Values in the range 0 to 1 are usually sufficient,
     *                 where 0 doesn't change the image and 1 creates a highly blurred image.
     */ function zoomBlur(centerX, centerY, strength) {
        gl.zoomBlur = gl.zoomBlur || new Shader(null, "        uniform sampler2D texture;        uniform vec2 center;        uniform float strength;        uniform vec2 texSize;        varying vec2 texCoord;        " + randomShaderFunc + "        void main() {            vec4 color = vec4(0.0);            float total = 0.0;            vec2 toCenter = center - texCoord * texSize;                        /* randomize the lookup values to hide the fixed number of samples */            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);                        for (float t = 0.0; t <= 40.0; t++) {                float percent = (t + offset) / 40.0;                float weight = 4.0 * (percent - percent * percent);                vec4 sample = texture2D(texture, texCoord + toCenter * percent * strength / texSize);                                /* switch to pre-multiplied alpha to correctly blur transparent images */                sample.rgb *= sample.a;                                color += sample * weight;                total += weight;            }                        gl_FragColor = color / total;                        /* switch back from pre-multiplied alpha */            gl_FragColor.rgb /= gl_FragColor.a + 0.00001;        }    ", "zoomBlur");
        simpleShader.call(this, gl.zoomBlur, {
            center: [
                centerX,
                centerY
            ],
            strength: strength,
            texSize: [
                this.width,
                this.height
            ]
        });
        return this;
    }
    // src/filters\fun\colorhalftone.script
    /**
     * @filter        Color Halftone
     * @description   Simulates a CMYK halftone rendering of the image by multiplying pixel values
     *                with a four rotated 2D sine wave patterns, one each for cyan, magenta, yellow,
     *                and black.
     * @param centerX The x coordinate of the pattern origin.
     * @param centerY The y coordinate of the pattern origin.
     * @param angle   The rotation of the pattern in radians.
     * @param size    The diameter of a dot in pixels.
     */ function colorHalftone(centerX, centerY, angle, size) {
        gl.colorHalftone = gl.colorHalftone || new Shader(null, "        uniform sampler2D texture;        uniform vec2 center;        uniform float angle;        uniform float scale;        uniform vec2 texSize;        varying vec2 texCoord;                float pattern(float angle) {            float s = sin(angle), c = cos(angle);            vec2 tex = texCoord * texSize - center;            vec2 point = vec2(                c * tex.x - s * tex.y,                s * tex.x + c * tex.y            ) * scale;            return (sin(point.x) * sin(point.y)) * 4.0;        }                void main() {            vec4 color = texture2D(texture, texCoord);            vec3 cmy = 1.0 - color.rgb;            float k = min(cmy.x, min(cmy.y, cmy.z));            cmy = (cmy - k) / (1.0 - k);            cmy = clamp(cmy * 10.0 - 3.0 + vec3(pattern(angle + 0.26179), pattern(angle + 1.30899), pattern(angle)), 0.0, 1.0);            k = clamp(k * 10.0 - 5.0 + pattern(angle + 0.78539), 0.0, 1.0);            gl_FragColor = vec4(1.0 - cmy - k, color.a);        }    ", "colorHalftone");
        simpleShader.call(this, gl.colorHalftone, {
            center: [
                centerX,
                centerY
            ],
            angle: angle,
            scale: Math.PI / size,
            texSize: [
                this.width,
                this.height
            ]
        });
        return this;
    }
    // src/filters\fun\dotscreen.script
    /**
     * @filter        Dot Screen
     * @description   Simulates a black and white halftone rendering of the image by multiplying
     *                pixel values with a rotated 2D sine wave pattern.
     * @param centerX The x coordinate of the pattern origin.
     * @param centerY The y coordinate of the pattern origin.
     * @param angle   The rotation of the pattern in radians.
     * @param size    The diameter of a dot in pixels.
     */ function dotScreen(centerX, centerY, angle, size) {
        gl.dotScreen = gl.dotScreen || new Shader(null, "        uniform sampler2D texture;        uniform vec2 center;        uniform float angle;        uniform float scale;        uniform vec2 texSize;        varying vec2 texCoord;                float pattern() {            float s = sin(angle), c = cos(angle);            vec2 tex = texCoord * texSize - center;            vec2 point = vec2(                c * tex.x - s * tex.y,                s * tex.x + c * tex.y            ) * scale;            return (sin(point.x) * sin(point.y)) * 4.0;        }                void main() {            vec4 color = texture2D(texture, texCoord);            float average = (color.r + color.g + color.b) / 3.0;            gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);        }    ", "dotScreen");
        simpleShader.call(this, gl.dotScreen, {
            center: [
                centerX,
                centerY
            ],
            angle: angle,
            scale: Math.PI / size,
            texSize: [
                this.width,
                this.height
            ]
        });
        return this;
    }
    // src/filters\fun\edgework.script
    /**
     * @filter       Edge Work
     * @description  Picks out different frequencies in the image by subtracting two
     *               copies of the image blurred with different radii.
     * @param radius The radius of the effect in pixels.
     */ function edgeWork(radius) {
        gl.edgeWork1 = gl.edgeWork1 || new Shader(null, "        uniform sampler2D texture;        uniform vec2 delta;        varying vec2 texCoord;        " + randomShaderFunc + "        void main() {            vec2 color = vec2(0.0);            vec2 total = vec2(0.0);                        /* randomize the lookup values to hide the fixed number of samples */            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);                        for (float t = -30.0; t <= 30.0; t++) {                float percent = (t + offset - 0.5) / 30.0;                float weight = 1.0 - abs(percent);                vec3 sample = texture2D(texture, texCoord + delta * percent).rgb;                float average = (sample.r + sample.g + sample.b) / 3.0;                color.x += average * weight;                total.x += weight;                if (abs(t) < 15.0) {                    weight = weight * 2.0 - 1.0;                    color.y += average * weight;                    total.y += weight;                }            }            gl_FragColor = vec4(color / total, 0.0, 1.0);        }    ", "edgeWork1");
        gl.edgeWork2 = gl.edgeWork2 || new Shader(null, "        uniform sampler2D texture;        uniform vec2 delta;        varying vec2 texCoord;        " + randomShaderFunc + "        void main() {            vec2 color = vec2(0.0);            vec2 total = vec2(0.0);                        /* randomize the lookup values to hide the fixed number of samples */            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);                        for (float t = -30.0; t <= 30.0; t++) {                float percent = (t + offset - 0.5) / 30.0;                float weight = 1.0 - abs(percent);                vec2 sample = texture2D(texture, texCoord + delta * percent).xy;                color.x += sample.x * weight;                total.x += weight;                if (abs(t) < 15.0) {                    weight = weight * 2.0 - 1.0;                    color.y += sample.y * weight;                    total.y += weight;                }            }            float c = clamp(10000.0 * (color.y / total.y - color.x / total.x) + 0.5, 0.0, 1.0);            gl_FragColor = vec4(c, c, c, 1.0);        }    ", "edgeWork2");
        simpleShader.call(this, gl.edgeWork1, {
            delta: [
                radius / this.width,
                0
            ]
        });
        simpleShader.call(this, gl.edgeWork2, {
            delta: [
                0,
                radius / this.height
            ]
        });
        return this;
    }
    // src/filters\fun\hexagonalpixelate.script
    /**
     * @filter        Hexagonal Pixelate
     * @description   Renders the image using a pattern of hexagonal tiles. Tile colors
     *                are nearest-neighbor sampled from the centers of the tiles.
     * @param centerX The x coordinate of the pattern center.
     * @param centerY The y coordinate of the pattern center.
     * @param scale   The width of an individual tile, in pixels.
     */ function hexagonalPixelate(centerX, centerY, scale) {
        gl.hexagonalPixelate = gl.hexagonalPixelate || new Shader(null, "        uniform sampler2D texture;        uniform vec2 center;        uniform float scale;        uniform vec2 texSize;        varying vec2 texCoord;        void main() {            vec2 tex = (texCoord * texSize - center) / scale;            tex.y /= 0.866025404;            tex.x -= tex.y * 0.5;                        vec2 a;            if (tex.x + tex.y - floor(tex.x) - floor(tex.y) < 1.0) a = vec2(floor(tex.x), floor(tex.y));            else a = vec2(ceil(tex.x), ceil(tex.y));            vec2 b = vec2(ceil(tex.x), floor(tex.y));            vec2 c = vec2(floor(tex.x), ceil(tex.y));                        vec3 TEX = vec3(tex.x, tex.y, 1.0 - tex.x - tex.y);            vec3 A = vec3(a.x, a.y, 1.0 - a.x - a.y);            vec3 B = vec3(b.x, b.y, 1.0 - b.x - b.y);            vec3 C = vec3(c.x, c.y, 1.0 - c.x - c.y);                        float alen = length(TEX - A);            float blen = length(TEX - B);            float clen = length(TEX - C);                        vec2 choice;            if (alen < blen) {                if (alen < clen) choice = a;                else choice = c;            } else {                if (blen < clen) choice = b;                else choice = c;            }                        choice.x += choice.y * 0.5;            choice.y *= 0.866025404;            choice *= scale / texSize;            gl_FragColor = texture2D(texture, choice + center / texSize);        }    ", "hexagonalPixelate");
        simpleShader.call(this, gl.hexagonalPixelate, {
            center: [
                centerX,
                centerY
            ],
            scale: scale,
            texSize: [
                this.width,
                this.height
            ]
        });
        return this;
    }
    // src/filters\fun\ink.script
    /**
     * @filter         Ink
     * @description    Simulates outlining the image in ink by darkening edges stronger than a
     *                 certain threshold. The edge detection value is the difference of two
     *                 copies of the image, each blurred using a blur of a different radius.
     * @param strength The multiplicative scale of the ink edges. Values in the range 0 to 1
     *                 are usually sufficient, where 0 doesn't change the image and 1 adds lots
     *                 of black edges. Negative strength values will create white ink edges
     *                 instead of black ones.
     */ function ink(strength) {
        gl.ink = gl.ink || new Shader(null, "        uniform sampler2D texture;        uniform float strength;        uniform vec2 texSize;        varying vec2 texCoord;        void main() {            vec2 dx = vec2(1.0 / texSize.x, 0.0);            vec2 dy = vec2(0.0, 1.0 / texSize.y);            vec4 color = texture2D(texture, texCoord);            float bigTotal = 0.0;            float smallTotal = 0.0;            vec3 bigAverage = vec3(0.0);            vec3 smallAverage = vec3(0.0);            for (float x = -2.0; x <= 2.0; x += 1.0) {                for (float y = -2.0; y <= 2.0; y += 1.0) {                    vec3 sample = texture2D(texture, texCoord + dx * x + dy * y).rgb;                    bigAverage += sample;                    bigTotal += 1.0;                    if (abs(x) + abs(y) < 2.0) {                        smallAverage += sample;                        smallTotal += 1.0;                    }                }            }            vec3 edge = max(vec3(0.0), bigAverage / bigTotal - smallAverage / smallTotal);            gl_FragColor = vec4(color.rgb - dot(edge, edge) * strength * 100000.0, color.a);        }    ", "ink");
        simpleShader.call(this, gl.ink, {
            strength: strength * strength * strength * strength * strength,
            texSize: [
                this.width,
                this.height
            ]
        });
        return this;
    }
    // src/filters\warp\bulgepinch.script
    /**
     * @filter         Bulge / Pinch
     * @description    Bulges or pinches the image in a circle.
     * @param centerX  The x coordinate of the center of the circle of effect.
     * @param centerY  The y coordinate of the center of the circle of effect.
     * @param radius   The radius of the circle of effect.
     * @param strength -1 to 1 (-1 is strong pinch, 0 is no effect, 1 is strong bulge)
     */ function bulgePinch(centerX, centerY, radius, strength) {
        gl.bulgePinch = gl.bulgePinch || warpShader("        uniform float radius;        uniform float strength;        uniform vec2 center;    ", "        coord -= center;        float distance = length(coord);        if (distance < radius) {            float percent = distance / radius;            if (strength > 0.0) {                coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);            } else {                coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);            }        }        coord += center;    ");
        simpleShader.call(this, gl.bulgePinch, {
            radius: radius,
            strength: clamp(-1, strength, 1),
            center: [
                centerX,
                centerY
            ],
            texSize: [
                this.width,
                this.height
            ]
        });
        return this;
    }
    // src/filters\warp\matrixwarp.script
    /**
     * @filter                Matrix Warp
     * @description           Transforms an image by a 2x2 or 3x3 matrix. The coordinates used in
     *                        the transformation are (x, y) for a 2x2 matrix or (x, y, 1) for a
     *                        3x3 matrix, where x and y are in units of pixels.
     * @param matrix          A 2x2 or 3x3 matrix represented as either a list or a list of lists.
     *                        For example, the 3x3 matrix [[2,0,0],[0,3,0],[0,0,1]] can also be
     *                        represented as [2,0,0,0,3,0,0,0,1] or just [2,0,0,3].
     * @param inverse         A boolean value that, when true, applies the inverse transformation
     *                        instead. (optional, defaults to false)
     * @param useTextureSpace A boolean value that, when true, uses texture-space coordinates
     *                        instead of screen-space coordinates. Texture-space coordinates range
     *                        from -1 to 1 instead of 0 to width - 1 or height - 1, and are easier
     *                        to use for simple operations like flipping and rotating.
     */ function matrixWarp(matrix, inverse, useTextureSpace) {
        gl.matrixWarp = gl.matrixWarp || warpShader("        uniform mat3 matrix;        uniform bool useTextureSpace;    ", "        if (useTextureSpace) coord = coord / texSize * 2.0 - 1.0;        vec3 warp = matrix * vec3(coord, 1.0);        coord = warp.xy / warp.z;        if (useTextureSpace) coord = (coord * 0.5 + 0.5) * texSize;    ");
        // Flatten all members of matrix into one big list
        matrix = Array.prototype.concat.apply([], matrix);
        // Extract a 3x3 matrix out of the arguments
        if (matrix.length == 4) matrix = [
            matrix[0],
            matrix[1],
            0,
            matrix[2],
            matrix[3],
            0,
            0,
            0,
            1
        ];
        else if (matrix.length != 9) throw "can only warp with 2x2 or 3x3 matrix";
        simpleShader.call(this, gl.matrixWarp, {
            matrix: inverse ? getInverse(matrix) : matrix,
            texSize: [
                this.width,
                this.height
            ],
            useTextureSpace: useTextureSpace | 0
        });
        return this;
    }
    // src/filters\warp\perspective.script
    /**
     * @filter       Perspective
     * @description  Warps one quadrangle to another with a perspective transform. This can be used to
     *               make a 2D image look 3D or to recover a 2D image captured in a 3D environment.
     * @param before The x and y coordinates of four points before the transform in a flat list. This
     *               would look like [ax, ay, bx, by, cx, cy, dx, dy] for four points (ax, ay), (bx, by),
     *               (cx, cy), and (dx, dy).
     * @param after  The x and y coordinates of four points after the transform in a flat list, just
     *               like the other argument.
     */ function perspective(before, after) {
        let a = getSquareToQuad.apply(null, after);
        let b = getSquareToQuad.apply(null, before);
        let c = multiply(getInverse(a), b);
        return this.matrixWarp(c);
    }
    // src/filters\warp\swirl.script
    /**
     * @filter        Swirl
     * @description   Warps a circular region of the image in a swirl.
     * @param centerX The x coordinate of the center of the circular region.
     * @param centerY The y coordinate of the center of the circular region.
     * @param radius  The radius of the circular region.
     * @param angle   The angle in radians that the pixels in the center of
     *                the circular region will be rotated by.
     */ function swirl(centerX, centerY, radius, angle) {
        gl.swirl = gl.swirl || warpShader("        uniform float radius;        uniform float angle;        uniform vec2 center;    ", "        coord -= center;        float distance = length(coord);        if (distance < radius) {            float percent = (radius - distance) / radius;            float theta = percent * percent * angle;            float s = sin(theta);            float c = cos(theta);            coord = vec2(                coord.x * c - coord.y * s,                coord.x * s + coord.y * c            );        }        coord += center;    ");
        simpleShader.call(this, gl.swirl, {
            radius: radius,
            center: [
                centerX,
                centerY
            ],
            angle: angle,
            texSize: [
                this.width,
                this.height
            ]
        });
        return this;
    }
    /**
     * @filter        Invert
     * @description   Inverts color of each pixel
     */ function invert() {
        gl.invert = gl.invert || new Shader(null, "    uniform sampler2D texture;    uniform vec2 texSize;    varying vec2 texCoord;        void main() {        vec4 color = texture2D(texture, texCoord);        color.rgb = 1.0 - color.rgb;        gl_FragColor = color;    }", "invert");
        simpleShader.call(this, gl.invert, {
            texSize: [
                this.width,
                this.height
            ]
        });
        return this;
    }
    /**
     * @filter        multiplyAlpha
     * @description   applies alpha multiply
     */ function multiplyAlpha() {
        gl.multiplyAlpha = gl.multiplyAlpha || new Shader(null, "    uniform sampler2D texture;    uniform vec2 texSize;    varying vec2 texCoord;        void main() {        vec4 color = texture2D(texture, texCoord);        color.rgb *= color.a;        gl_FragColor = color;    }", "multiplyAlpha");
        simpleShader.call(this, gl.multiplyAlpha, {
            texSize: [
                this.width,
                this.height
            ]
        });
        return this;
    }
    /**
     * @filter        unmultiplyAlpha
     * @description   reverses alpha multiply
     */ function unmultiplyAlpha() {
        gl.unmultiplyAlpha = gl.unmultiplyAlpha || new Shader(null, "    uniform sampler2D texture;    uniform vec2 texSize;    varying vec2 texCoord;        void main() {        vec4 color = texture2D(texture, texCoord);        if(color.a > 0.0) {            color.rgb /= color.a;        }        gl_FragColor = color;    }", "unmultiplyAlpha");
        simpleShader.call(this, gl.unmultiplyAlpha, {
            texSize: [
                this.width,
                this.height
            ]
        });
        return this;
    }
    /**
     * @filter        To Alpha
     * @description   Generates alpha channel from luminance (r+g+b)
     * @param isInverted    boolean - invert luminance
     * @param replaceRGBA    rgba - color to replace rgb with. if a = 0 -> keep orig color
     */ function toAlpha(isInverted, replaceRGBA) {
        gl.toAlpha = gl.toAlpha || new Shader(null, "    uniform bool isInverted;    uniform vec4 replace;    uniform sampler2D texture;    uniform vec2 texSize;    varying vec2 texCoord;        void main() {        vec4 color = texture2D(texture, texCoord);        float alpha = (color.r + color.g + color.b) / 3.0;        if (isInverted) alpha = 1.0 - alpha;        alpha = min(color.a, alpha);        if (replace.a > 0.0) color = replace;        gl_FragColor = vec4(color.r, color.g, color.b, alpha);    }", "toAlpha");
        simpleShader.call(this, gl.toAlpha, {
            isInverted: isInverted ? 1 : 0,
            replace: replaceRGBA ? [
                replaceRGBA.r / 255,
                replaceRGBA.g / 255,
                replaceRGBA.b / 255,
                replaceRGBA.a
            ] : [
                0,
                0,
                0,
                0
            ],
            texSize: [
                this.width,
                this.height
            ]
        });
        return this;
    }
    /**
     * @filter        Distort
     * @description   Distorts image (moves pixels around)
     */ function distort(settings) {
        gl.distort = gl.distort || warpShader("        uniform float stepSize;        uniform vec2 scale;        uniform vec2 strength;        uniform vec2 phase;        uniform float type;        ", "        const float PI = 3.14159265;        float x = coord.x;        float y = coord.y;        if (stepSize > 1.0) {            x = floor(x / stepSize) * stepSize;            y = floor(y / stepSize) * stepSize;        }        float distortX = sin((x/scale.x + phase.x) * PI * 2.0) * strength.x;        float distortY = sin((y/scale.y + phase.y) * PI * 2.0) * strength.y;        if (type == 0.0) {            coord.y += distortX;            coord.x += distortY;        } else if (type == 1.0) {            coord.x += distortX;            coord.y += distortY;        } else if (type == 2.0) {            gl_FragColor = texture2D(texture, vec2(x, y) / texSize);            coord.y += sin(gl_FragColor.r/scale.x*200.0 + phase.x * PI * 2.0) * strength.x;            coord.x += cos(gl_FragColor.g/scale.y*200.0 + phase.y * PI * 2.0) * strength.y;        }        coord.x = mod(coord.x, texSize.x);        coord.y = mod(coord.y, texSize.y);                ");
        simpleShader.call(this, gl.distort, {
            stepSize: settings.stepSize,
            type: settings.distortType,
            scale: [
                settings.scale.x,
                settings.scale.y
            ],
            strength: [
                settings.strength.x,
                settings.strength.y
            ],
            phase: [
                settings.phase.x,
                settings.phase.y
            ],
            texSize: [
                this.width,
                this.height
            ]
        });
        return this;
    }
    return exports;
}();

},{"./shader-noise.glsl":"dHmP1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dHmP1":[function(require,module,exports) {
module.exports = "#define GLSLIFY 1\nuniform sampler2D texture;\nvarying vec2 texCoord;\nuniform vec2 texSize;\n\nuniform float seed;\nuniform float type;\nuniform vec2 scale;\nuniform vec2 offset;\nuniform float octaves;\nuniform float samples;\n\nuniform float peaks;\nuniform float contrast;\nuniform float brightness;\nuniform float isReversed;\n\nuniform vec3 colA;\nuniform vec3 colB;\n\nuniform float channels; // 0 - rgb, 1 - alpha\n\n// fbm, cellular_noise based on\n// https://github.com/Gonkee/Gonkees-Shaders\n// MIT, Copyright \xa9 Gonkee\n\n// hash & simplex based on\n// https://www.shadertoy.com/view/Msf3WH\n// MIT, Copyright \xa9 2013 Inigo Quilez\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat value_noise(vec2 coord){\n    return rand(floor(coord) / 100.0);\n}\n\nfloat cellular_noise(vec2 coord) {\n    vec2 i = floor(coord);\n    vec2 f = fract(coord);\n\n    float min_dist = 99999.0;\n    for (float x = -1.0; x <= 1.0; x++) {\n        for (float y = -1.0; y <= 1.0; y++) {\n            vec2 node = rand(i + vec2(x, y)) + vec2(x, y);\n            float dist = sqrt((f - node).x * (f - node).x + (f - node).y * (f - node).y);\n            min_dist = min(min_dist, dist);\n        }\n    }\n    return min_dist;\n}\n\n// ---------- Simplex Alternative _--------------------\n\nvec3 hash(vec3 p)\n{ p=vec3(dot(p, vec3(127.1, 311.7, 74.7))\n, dot(p, vec3(269.5, 183.3, 246.1))\n, dot(p, vec3(113.5, 271.9, 124.6)))\n;return fract(sin(p)*43758.5453123)*2.-1.; }\n\nmat3 hash(mat3 p)\n{ return mat3(hash(p[0]), hash(p[1]), hash(p[2])); }\n\nvec3 dots(mat3 a, vec3 w, mat3 b){ return vec3\n(dot(a[0], w-b[0]), dot(a[1], w-b[1]), dot(a[2], w-b[2])); }\n\n//return noiseGra13dx as .x, and its derivatives as .yzw\n// https://www.shadertoy.com/view/llByD1\nvec3 noiseGra13dx(in vec3 x) {\n    vec3 p=floor(x), w=fract(x)\n    #if 1\n    , u=w*w*w*(w*(w*6.-15.)+10.), v=30.*w*w*(w*(w-2.)+1.)//quintic hermite\n    #else\n    , u=w*w*(3.-2.*w), v=6.*w*(1.-w)//cubic hermite\n    #endif\n    //gradients\n    , G=hash(p+vec3(0)), F=hash(p+vec3(1))\n    ;mat3 D=hash(mat3(p, p, p)+mat3(1)), E=hash(mat3(p, p, p)+1.-mat3(1));\n    //projections\n    vec3 d=dots(D, w, mat3(1)), e=dots(E, w, 1.-mat3(1));\n    //interpolations\n    float g=dot(G, w), f=dot(F, w-vec3(1));\n    vec3 h=u.yzx*(g-d.xyx-d.yzz+e.zxy)+d-g, U=u*h, a=d-e;\n    mat3 S=D-mat3(G, G, G), W=D-E;\n    a.x=(a.x+a.y+a.z)+f-g;\n    ;float b=u.x*u.y*u.z;\n\n    vec4 result = vec4(g+U.x+U.y+U.z+a.x*b// value\n    , G*(1.-b)+b*(W[0]+W[1]+W[2]+F)//https://www.shadertoy.com/view/llByD1\n    +u.x*(S[0]+u.y*(G-D[0]-D[1]+E[2]))// derivatives\n    +u.y*(S[1]+u.z*(G-D[1]-D[2]+E[0]))\n    +u.z*(S[2]+u.x*(G-D[0]-D[2]+E[1]))\n    +v*(u.zxy*(g-d.xxy-d.zyz+e.yzx)+h+u.yzx*u.zxy*a.x));\n    return 0.5 + 0.5 * result.xxx;\n}\n\nfloat fbm(vec2 coord) {\n    float normalize_factor = 0.0;\n    float value = 0.0;\n    float scale = 0.5;\n\n    for (float i = 0.0; i < 7.0; i++){\n        if (i < octaves) {\n            if (type == 0.0) {\n                value += value_noise(coord) * scale;\n            } else if (type == 1.0) {\n                value += noiseGra13dx(vec3(coord.x, coord.y, 0.0)).r * scale;\n            } else if (type == 2.0) {\n                value += cellular_noise(coord) * scale;\n            }\n            normalize_factor += scale;\n            coord *= 2.0;\n            scale *= 0.5;\n        }\n    }\n    return value / normalize_factor;\n}\n\nfloat render (vec2 pos) {\n    float result = fbm(pos);\n    //\n\n    if (peaks > 0.0) {\n        result = abs(mod(result * peaks - 0.5, 1.0) - 0.5) * 2.0;// triangle\n        //result = mod(result * (peaks + 1.0), 1.0); // sawtooth\n    }\n\n    result += brightness;\n    if (contrast > 0.0) {\n        result = clamp((result - 0.5) / (1.0 - contrast) + 0.5, 0.0, 1.0);\n    } else if (contrast < 0.0) {\n        result = clamp((result - 0.5) * (1.0 + contrast) + 0.5, 0.0, 1.0);\n    }\n\n    if (isReversed == 1.0) {\n        result = 1.0 - result;\n    }\n    return result;\n}\n\nvoid main() {\n    vec4 color;\n\n    vec2 seedOffset;\n    seedOffset.x = (rand(vec2(seed, 0.0)) * 100.0 - 50.0);\n    seedOffset.y = (rand(vec2(0.0, seed)) * 100.0 - 50.0);\n\n    float val = 0.0;\n    vec2 basePos = texCoord * texSize / scale - offset / scale + seedOffset;\n\n    if (samples == 1.0) {\n        val = render(basePos);\n\n    }/* else if (samples == 4.0) {\n        for (float i = 0.0; i < 2.0; i++) {\n            for (float e = 0.0; e < 2.0; e++) {\n                val += render(basePos + (vec2(i, e) - 0.5) * 0.5 / scale);\n            }\n        }\n        val /= 4.0;\n\n    }*/ else if (samples == 16.0) {\n        for (float i = 0.0; i < 4.0; i++) {\n            for (float e = 0.0; e < 4.0; e++) {\n                val += render(basePos + (vec2(i, e) - 0.25) * 0.25 / scale);\n            }\n        }\n        val /= 16.0;\n    }\n\n    if (channels == 0.0) {\n        gl_FragColor = vec4(vec3(mix(colA, colB, val)), 1.0);\n    } else {\n        gl_FragColor = vec4(vec3(1.0), val);\n    }\n}";

},{}],"46o4U":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterCropExtend", ()=>filterCropExtend);
var _bb = require("../../bb/bb");
var _input = require("../ui/base-components/input");
var _checkbox = require("../ui/base-components/checkbox");
var _colorOptions = require("../ui/base-components/color-options");
var _cropper = require("../ui/components/cropper");
var _language = require("../../language/language");
const filterCropExtend = {
    getDialog (params) {
        const klCanvas = params.klCanvas;
        if (!klCanvas) return false;
        const tempCanvas = (0, _bb.BB).canvas();
        {
            let fit = (0, _bb.BB).fitInto(klCanvas.getWidth(), klCanvas.getHeight(), 560, 400, 1);
            let w = parseInt("" + fit.width), h = parseInt("" + fit.height);
            let previewFactor = w / klCanvas.getWidth();
            tempCanvas.width = w;
            tempCanvas.height = h;
            tempCanvas.style.display = "block";
            tempCanvas.getContext("2d").drawImage(klCanvas.getCompleteCanvas(previewFactor), 0, 0, w, h);
        }
        const div = document.createElement("div");
        const result = {
            element: div
        };
        div.innerHTML = (0, _language.LANG)("filter-crop-description") + "<br/><br/>";
        let left = 0, right = 0, top = 0, bottom = 0;
        let leftChanged = false, rightChanged = false, topChanged = false, bottomChanged = false;
        const maxWidth = params.maxWidth, maxHeight = params.maxHeight;
        let scale;
        // --- input elements ---
        const lrWrapper = (0, _bb.BB).el({
            css: {
                lineHeight: "30px",
                height: "35px"
            }
        });
        const tbWrapper = (0, _bb.BB).el({
            css: {
                lineHeight: "30px",
                height: "35px"
            }
        });
        div.appendChild(lrWrapper);
        div.appendChild(tbWrapper);
        const leftInput = (0, _input.input)({
            init: 0,
            type: "number",
            min: -klCanvas.getWidth(),
            max: maxWidth,
            css: {
                width: "75px",
                marginRight: "20px"
            },
            callback: function(v) {
                leftChanged = true;
                updateInput();
            }
        });
        const rightInput = (0, _input.input)({
            init: 0,
            type: "number",
            min: -klCanvas.getWidth(),
            max: maxWidth,
            css: {
                width: "75px"
            },
            callback: function(v) {
                rightChanged = true;
                updateInput();
            }
        });
        const topInput = (0, _input.input)({
            init: 0,
            type: "number",
            min: -klCanvas.getHeight(),
            max: maxHeight,
            css: {
                width: "75px",
                marginRight: "20px"
            },
            callback: function(v) {
                topChanged = true;
                updateInput();
            }
        });
        const bottomInput = (0, _input.input)({
            init: 0,
            type: "number",
            min: -klCanvas.getHeight(),
            max: maxHeight,
            css: {
                width: "75px"
            },
            callback: function(v) {
                bottomChanged = true;
                updateInput();
            }
        });
        const labelStyle = {
            display: "inline-block",
            width: "60px"
        };
        lrWrapper.append((0, _bb.BB).el({
            content: (0, _language.LANG)("filter-crop-left") + ":",
            css: labelStyle
        }), leftInput, (0, _bb.BB).el({
            content: (0, _language.LANG)("filter-crop-right") + ":",
            css: labelStyle
        }), rightInput);
        tbWrapper.append((0, _bb.BB).el({
            content: (0, _language.LANG)("filter-crop-top") + ":",
            css: labelStyle
        }), topInput, (0, _bb.BB).el({
            content: (0, _language.LANG)("filter-crop-bottom") + ":",
            css: labelStyle
        }), bottomInput);
        function updateInput() {
            left = parseInt(leftInput.value);
            right = parseInt(rightInput.value);
            top = parseInt(topInput.value);
            bottom = parseInt(bottomInput.value);
            let newWidth = klCanvas.getWidth() + left + right;
            let newHeight = klCanvas.getHeight() + top + bottom;
            if (newWidth <= 0) {
                if (leftChanged) {
                    left = -klCanvas.getWidth() - right + 1;
                    leftInput.value = "" + left;
                }
                if (rightChanged) {
                    right = -klCanvas.getWidth() - left + 1;
                    rightInput.value = "" + right;
                }
                newWidth = 1;
            }
            if (newWidth > maxWidth) {
                if (leftChanged) {
                    left = -klCanvas.getWidth() - right + maxWidth;
                    leftInput.value = "" + left;
                }
                if (rightChanged) {
                    right = -klCanvas.getWidth() - left + maxWidth;
                    rightInput.value = "" + right;
                }
                newWidth = maxWidth;
            }
            if (newHeight <= 0) {
                if (topChanged) {
                    top = -klCanvas.getHeight() - bottom + 1;
                    topInput.value = "" + top;
                }
                if (bottomChanged) {
                    bottom = -klCanvas.getHeight() - top + 1;
                    bottomInput.value = "" + bottom;
                }
                newHeight = 1;
            }
            if (newHeight > maxHeight) {
                if (topChanged) {
                    top = -klCanvas.getHeight() - bottom + maxHeight;
                    topInput.value = "" + top;
                }
                if (bottomChanged) {
                    bottom = -klCanvas.getHeight() - top + maxHeight;
                    bottomInput.value = "" + bottom;
                }
                newHeight = maxHeight;
            }
            cropper.setTransform({
                x: -left,
                y: -top,
                width: newWidth,
                height: newHeight
            });
            leftChanged = false;
            rightChanged = false;
            topChanged = false;
            bottomChanged = false;
        }
        let useRuleOfThirds = true;
        let ruleOThirdsCheckbox = new (0, _checkbox.Checkbox)({
            init: true,
            label: (0, _language.LANG)("filter-crop-rule-thirds"),
            allowTab: true,
            callback: function(b) {
                useRuleOfThirds = b;
                cropper.showThirds(useRuleOfThirds);
            }
        });
        div.appendChild((0, _bb.BB).el({
            css: {
                clear: "both"
            }
        }));
        let selectedRgbaObj = {
            r: 0,
            g: 0,
            b: 0,
            a: 0
        };
        const colorOptionsArr = [
            {
                r: 0,
                g: 0,
                b: 0,
                a: 0
            },
            {
                r: 255,
                g: 255,
                b: 255,
                a: 1
            },
            {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            }
        ];
        colorOptionsArr.push({
            r: params.currentColorRgb.r,
            g: params.currentColorRgb.g,
            b: params.currentColorRgb.b,
            a: 1
        });
        colorOptionsArr.push({
            r: params.secondaryColorRgb.r,
            g: params.secondaryColorRgb.g,
            b: params.secondaryColorRgb.b,
            a: 1
        });
        const colorOptions = new (0, _colorOptions.ColorOptions)({
            label: (0, _language.LANG)("filter-crop-fill"),
            colorArr: colorOptionsArr,
            onChange: function(rgbaObj) {
                selectedRgbaObj = rgbaObj;
                updateBg(rgbaObj);
            }
        });
        const flexRow = (0, _bb.BB).el({
            css: {
                display: "flex",
                justifyContent: "space-between"
            }
        });
        div.appendChild(flexRow);
        flexRow.appendChild(ruleOThirdsCheckbox.getElement());
        flexRow.appendChild(colorOptions.getElement());
        // when input field changed, or dragging in preview finished
        // adjusts the zoom
        function update(transform) {
            const fit = (0, _bb.BB).fitInto(transform.width, transform.height, 260, 180, 1);
            scale = fit.width / transform.width;
            const offset = (0, _bb.BB).centerWithin(340, 220, fit.width, fit.height);
            tempCanvas.style.width = klCanvas.getWidth() * scale + "px";
            tempCanvas.style.height = klCanvas.getHeight() * scale + "px";
            offsetWrapper.style.left = offset.x - transform.x * scale + "px";
            offsetWrapper.style.top = offset.y - transform.y * scale + "px";
            left = parseInt("" + -transform.x);
            top = parseInt("" + -transform.y);
            right = parseInt("" + (transform.x + transform.width - klCanvas.getWidth()));
            bottom = parseInt("" + (transform.y + transform.height - klCanvas.getHeight()));
            leftInput.value = "" + left;
            topInput.value = "" + top;
            rightInput.value = "" + right;
            bottomInput.value = "" + bottom;
            (0, _bb.BB).createCheckerDataUrl(parseInt("" + 50 * scale), function(url) {
                previewWrapper.style.background = "url(" + url + ")";
                if (selectedRgbaObj.a !== 0) tempCanvas.style.background = "url(" + url + ")";
            });
            previewWrapper.style.backgroundPosition = offset.x + "px " + offset.y + "px";
            cropper.setScale(scale);
        }
        const previewWrapper = (0, _bb.BB).el({
            css: {
                width: "340px",
                marginTop: "10px",
                marginLeft: "-20px",
                height: "220px",
                backgroundColor: "#9e9e9e",
                position: "relative",
                boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
                overflow: "hidden",
                userSelect: "none",
                colorScheme: "only light",
                touchAction: "none"
            }
        });
        previewWrapper.oncontextmenu = function() {
            return false;
        };
        const bgColorOverlay = (0, _bb.BB).el({
            css: {
                position: "absolute",
                left: "0",
                top: "0",
                bottom: "0",
                right: "0"
            }
        });
        previewWrapper.appendChild(bgColorOverlay);
        const offsetWrapper = document.createElement("div");
        offsetWrapper.style.position = "absolute";
        offsetWrapper.style.left = "0px";
        offsetWrapper.style.top = "0px";
        previewWrapper.appendChild(offsetWrapper);
        const canvasWrapper = (0, _bb.BB).appendTextDiv(offsetWrapper, "");
        canvasWrapper.appendChild(tempCanvas);
        //tempCanvas.style.width = w + "px";
        //tempCanvas.style.height = h + "px";
        tempCanvas.style.boxShadow = "0 0 3px 1px rgba(0,0,0,0.5)";
        tempCanvas.style.position = "absolute";
        tempCanvas.style.left = "0px";
        tempCanvas.style.top = "0px";
        div.appendChild(previewWrapper);
        const cropper = new (0, _cropper.Cropper)({
            x: 0,
            y: 0,
            width: klCanvas.getWidth(),
            height: klCanvas.getHeight(),
            scale: scale,
            callback: update,
            maxW: maxWidth,
            maxH: maxHeight
        });
        update(cropper.getTransform());
        offsetWrapper.appendChild(cropper.getElement());
        function updateBg(rgbaObj) {
            let borderColor;
            if (rgbaObj.a === 0) {
                borderColor = "rgba(0,0,0,0.5)";
                bgColorOverlay.style.background = "";
                tempCanvas.style.background = "";
            } else {
                borderColor = rgbaObj.r + rgbaObj.g + rgbaObj.b < 382.5 ? "rgba(255,255,255,0.5)" : "rgba(0,0,0,0.5)";
                bgColorOverlay.style.background = (0, _bb.BB).ColorConverter.toRgbStr(rgbaObj);
                (0, _bb.BB).createCheckerDataUrl(parseInt("" + 50 * scale), function(url) {
                    tempCanvas.style.background = "url(" + url + ")";
                });
            }
            tempCanvas.style.boxShadow = "0 0 3px 1px " + borderColor;
        }
        result.destroy = ()=>{
            cropper.destroy();
            ruleOThirdsCheckbox.destroy();
        };
        result.getInput = function() {
            result.destroy();
            return {
                left: left,
                right: right,
                top: top,
                bottom: bottom,
                fillColor: selectedRgbaObj.a === 0 ? null : selectedRgbaObj
            };
        };
        return result;
    },
    apply (params) {
        const klCanvas = params.klCanvas;
        const history = params.history;
        if (!klCanvas || !history || isNaN(params.input.left) || isNaN(params.input.right) || isNaN(params.input.top) || isNaN(params.input.bottom)) return false;
        history.pause(true);
        klCanvas.resizeCanvas(params.input);
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "cropExtend"
            ],
            action: "apply",
            params: [
                {
                    input: JSON.parse(JSON.stringify(params.input))
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","../ui/base-components/input":"bsfIT","../ui/base-components/checkbox":"kPAwM","../ui/base-components/color-options":"e85vi","../ui/components/cropper":"bajkn","../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gJs7S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterCurves", ()=>filterCurves);
var _bb = require("../../bb/bb");
var _options = require("../ui/base-components/options");
var _canvasPreview = require("../canvas-ui/canvas-preview");
var _sharedGlFx = require("./shared-gl-fx");
var _language = require("../../language/language");
const filterCurves = {
    getDialog (params) {
        let context = params.context;
        let klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        let layers = klCanvas.getLayers();
        let selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        let fit = (0, _bb.BB).fitInto(context.canvas.width, context.canvas.height, 280, 200, 1);
        let w = parseInt("" + fit.width), h = parseInt("" + fit.height);
        let tempCanvas = (0, _bb.BB).canvas(w, h);
        {
            const ctx = tempCanvas.getContext("2d");
            ctx.save();
            if (tempCanvas.width > context.canvas.width) ctx.imageSmoothingEnabled = false;
            ctx.drawImage(context.canvas, 0, 0, w, h);
            ctx.restore();
        }
        let div = document.createElement("div");
        let result = {
            element: div
        };
        let klCanvasPreview;
        function finishInit() {
            let previewFactor = w / context.canvas.width;
            let brightness = 0, contrast = 0;
            div.innerHTML = (0, _language.LANG)("filter-curves-description") + "<br/><br/>";
            let curves = {
                r: [
                    [
                        0,
                        0
                    ],
                    [
                        1 / 3,
                        1 / 3
                    ],
                    [
                        2 / 3,
                        2 / 3
                    ],
                    [
                        1,
                        1
                    ]
                ],
                g: [
                    [
                        0,
                        0
                    ],
                    [
                        1 / 3,
                        1 / 3
                    ],
                    [
                        2 / 3,
                        2 / 3
                    ],
                    [
                        1,
                        1
                    ]
                ],
                b: [
                    [
                        0,
                        0
                    ],
                    [
                        1 / 3,
                        1 / 3
                    ],
                    [
                        2 / 3,
                        2 / 3
                    ],
                    [
                        1,
                        1
                    ]
                ]
            };
            let glCanvas = (0, _sharedGlFx.getSharedFx)();
            if (!glCanvas) return; // todo throw?
            let texture = glCanvas.texture(tempCanvas);
            glCanvas.draw(texture).update(); // update glCanvas size
            function update() {
                try {
                    glCanvas.draw(texture).curves(curves.r, curves.g, curves.b).update();
                    if (klCanvasPreview) klCanvasPreview.render();
                } catch (e) {
                    div.errorCallback(e);
                }
            }
            let modeButtons;
            function CurvesInput(p) {
                let div = document.createElement("div");
                div.oncontextmenu = function() {
                    return false;
                };
                div.style.position = "relative";
                div.style.marginBottom = "10px";
                let mode = "All";
                let curves = p.curves;
                modeButtons = new (0, _options.Options)({
                    optionArr: [
                        {
                            id: "All",
                            label: (0, _language.LANG)("filter-curves-all")
                        },
                        {
                            id: "Red",
                            label: (0, _language.LANG)("red")
                        },
                        {
                            id: "Green",
                            label: (0, _language.LANG)("green")
                        },
                        {
                            id: "Blue",
                            label: (0, _language.LANG)("blue")
                        }, 
                    ],
                    initialId: "All",
                    onChange: function(id) {
                        mode = id;
                        if (mode === "All") curves = {
                            r: [
                                [
                                    0,
                                    0
                                ],
                                [
                                    1 / 3,
                                    1 / 3
                                ],
                                [
                                    2 / 3,
                                    2 / 3
                                ],
                                [
                                    1,
                                    1
                                ]
                            ],
                            g: [
                                [
                                    0,
                                    0
                                ],
                                [
                                    1 / 3,
                                    1 / 3
                                ],
                                [
                                    2 / 3,
                                    2 / 3
                                ],
                                [
                                    1,
                                    1
                                ]
                            ],
                            b: [
                                [
                                    0,
                                    0
                                ],
                                [
                                    1 / 3,
                                    1 / 3
                                ],
                                [
                                    2 / 3,
                                    2 / 3
                                ],
                                [
                                    1,
                                    1
                                ]
                            ]
                        };
                        let curve = curves.r;
                        if (mode === "Green") curve = curves.g;
                        if (mode === "Blue") curve = curves.b;
                        p0.setPos(0, areah - curve[0][1] * areah);
                        p1.setPos(curve[1][0] * areaw, areah - curve[1][1] * areah);
                        p2.setPos(curve[2][0] * areaw, areah - curve[2][1] * areah);
                        p3.setPos(areaw, areah - curve[3][1] * areah);
                        update();
                    }
                });
                div.appendChild(modeButtons.getElement());
                let curveArea = document.createElement("div");
                (0, _bb.BB).css(curveArea, {
                    position: "relative",
                    marginTop: "10px",
                    colorScheme: "only light"
                });
                div.appendChild(curveArea);
                let areaw = 300, areah = 100;
                let canvas = (0, _bb.BB).canvas(areaw, areah);
                (0, _bb.BB).css(canvas, {
                    background: "#c6c6c6",
                    boxShadow: "0 0 0 1px rgba(0,0,0,0.3)"
                });
                let ctx = canvas.getContext("2d");
                curveArea.appendChild(canvas);
                let points = {
                    r: [],
                    g: [],
                    b: []
                };
                function fit(v) {
                    return Math.max(0, Math.min(1, v));
                }
                function createPoint(x, y, callback, lock) {
                    let gripSize = 14;
                    let internalY = y, internalX = x;
                    let point = document.createElement("div");
                    (0, _bb.BB).css(point, {
                        position: "absolute",
                        left: x - gripSize / 2 + "px",
                        top: y - gripSize / 2 + "px",
                        width: gripSize + "px",
                        height: gripSize + "px",
                        background: "#fff",
                        cursor: "move",
                        borderRadius: gripSize + "px",
                        boxShadow: "inset 0 0 0 2px #000",
                        userSelect: "none",
                        touchAction: "none"
                    });
                    function update() {
                        (0, _bb.BB).css(point, {
                            left: x - gripSize / 2 + "px",
                            top: y - gripSize / 2 + "px"
                        });
                    }
                    point.pointerListener = new (0, _bb.BB).PointerListener({
                        target: point,
                        maxPointers: 1,
                        onPointer: function(event) {
                            event.eventPreventDefault();
                            if (event.type === "pointerdown") {
                                internalX = x;
                                internalY = y;
                            }
                            if (event.button === "left" && event.type === "pointermove") {
                                if (!lock) internalX += event.dX;
                                x = Math.max(0, Math.min(areaw, internalX));
                                internalY += event.dY;
                                y = Math.max(0, Math.min(areah, internalY));
                                update();
                                callback({
                                    x: x,
                                    y: y
                                });
                            }
                        }
                    });
                    curveArea.appendChild(point);
                    point.setPos = function(newX, newY) {
                        x = newX;
                        y = newY;
                        internalY = y;
                        internalX = x;
                        (0, _bb.BB).css(point, {
                            left: x - gripSize / 2 + "px",
                            top: y - gripSize / 2 + "px"
                        });
                    };
                    return point;
                }
                function updateControl(i, x, y) {
                    if (mode === "All") {
                        curves.r[i] = [
                            fit(x / areaw),
                            fit(1 - y / areah)
                        ];
                        curves.g[i] = [
                            fit(x / areaw),
                            fit(1 - y / areah)
                        ];
                        curves.b[i] = [
                            fit(x / areaw),
                            fit(1 - y / areah)
                        ];
                    }
                    if (mode === "Red") curves.r[i] = [
                        fit(x / areaw),
                        fit(1 - y / areah)
                    ];
                    if (mode === "Green") curves.g[i] = [
                        fit(x / areaw),
                        fit(1 - y / areah)
                    ];
                    if (mode === "Blue") curves.b[i] = [
                        fit(x / areaw),
                        fit(1 - y / areah)
                    ];
                }
                let p0 = createPoint(0, areah, function(val) {
                    updateControl(0, val.x, val.y);
                    update();
                }, true);
                let p1 = createPoint(areaw / 3, areah / 3 * 2, function(val) {
                    updateControl(1, val.x, val.y);
                    update();
                });
                let p2 = createPoint(areaw / 3 * 2, areah / 3, function(val) {
                    updateControl(2, val.x, val.y);
                    update();
                });
                let p3 = createPoint(areaw, 0, function(val) {
                    updateControl(3, val.x, val.y);
                    update();
                }, true);
                function update() {
                    canvas.width = canvas.width;
                    ctx = canvas.getContext("2d");
                    let outCurves = {
                        r: [],
                        g: [],
                        b: []
                    };
                    for(let i = 0; i < curves.r.length; i++){
                        outCurves.r.push(curves.r[i]);
                        outCurves.g.push(curves.g[i]);
                        outCurves.b.push(curves.b[i]);
                    }
                    function drawCurve(curve) {
                        ctx.beginPath();
                        let spline = new (0, _bb.BB).SplineInterpolator(curve);
                        for(let i = 0; i < 100; i++){
                            let y = spline.interpolate(i / 100);
                            y = Math.max(0, Math.min(1, y));
                            if (i === 0) ctx.moveTo(i / 100 * areaw, areah - y * areah);
                            else ctx.lineTo(i / 100 * areaw, areah - y * areah);
                        }
                        ctx.stroke();
                    }
                    ctx.save();
                    if (mode === "All") {
                        ctx.strokeStyle = "black";
                        drawCurve(outCurves.r);
                    } else {
                        ctx.globalAlpha = 0.5;
                        ctx.strokeStyle = "red";
                        drawCurve(outCurves.r);
                        ctx.strokeStyle = "green";
                        drawCurve(outCurves.g);
                        ctx.strokeStyle = "blue";
                        drawCurve(outCurves.b);
                    }
                    ctx.restore();
                    p.callback(outCurves);
                }
                update();
                this.getDiv = function() {
                    return div;
                };
                this.destroy = function() {
                    p0.pointerListener.destroy();
                    p1.pointerListener.destroy();
                    p2.pointerListener.destroy();
                    p3.pointerListener.destroy();
                };
            }
            let input = new CurvesInput({
                curves: curves,
                callback: function(val) {
                    curves = val;
                    update();
                }
            });
            div.appendChild(input.getDiv());
            let previewWrapper = document.createElement("div");
            (0, _bb.BB).css(previewWrapper, {
                width: "340px",
                marginLeft: "-20px",
                height: "220px",
                backgroundColor: "#9e9e9e",
                marginTop: "10px",
                boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
                overflow: "hidden",
                position: "relative",
                userSelect: "none",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                colorScheme: "only light"
            });
            let previewLayerArr = [];
            for(let i = 0; i < layers.length; i++)previewLayerArr.push({
                image: i === selectedLayerIndex ? glCanvas : layers[i].context.canvas,
                opacity: layers[i].opacity,
                mixModeStr: layers[i].mixModeStr
            });
            klCanvasPreview = new (0, _canvasPreview.KlCanvasPreview)({
                width: parseInt("" + w),
                height: parseInt("" + h),
                layers: previewLayerArr
            });
            let previewInnerWrapper = (0, _bb.BB).el({
                css: {
                    position: "relative",
                    boxShadow: "0 0 5px rgba(0,0,0,0.5)",
                    width: parseInt("" + w) + "px",
                    height: parseInt("" + h) + "px"
                }
            });
            previewInnerWrapper.appendChild(klCanvasPreview.getElement());
            previewWrapper.appendChild(previewInnerWrapper);
            div.appendChild(previewWrapper);
            result.destroy = ()=>{
                input.destroy();
                texture.destroy();
                modeButtons.destroy();
            };
            result.getInput = function() {
                result.destroy();
                return {
                    curves: curves
                };
            };
        }
        setTimeout(finishInit, 1);
        return result;
    },
    apply (params) {
        let context = params.context;
        let curves = params.input.curves;
        let history = params.history;
        if (!context || curves === null || !history) return false;
        history.pause(true);
        let glCanvas = (0, _sharedGlFx.getSharedFx)();
        if (!glCanvas) return false; // todo more specific error?
        let texture = glCanvas.texture(context.canvas);
        glCanvas.draw(texture).curves(curves.r, curves.g, curves.b).update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(glCanvas, 0, 0);
        texture.destroy();
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "curves"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","../ui/base-components/options":"huqRY","../canvas-ui/canvas-preview":"gRZnS","./shared-gl-fx":"4bJZi","../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4eiAA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterFlip", ()=>filterFlip);
var _bb = require("../../bb/bb");
var _checkbox = require("../ui/base-components/checkbox");
var _canvasPreview = require("../canvas-ui/canvas-preview");
// @ts-ignore
var _checkmarkSvg = require("url:~/src/app/img/ui/checkmark.svg");
var _checkmarkSvgDefault = parcelHelpers.interopDefault(_checkmarkSvg);
var _language = require("../../language/language");
const filterFlip = {
    getDialog (params) {
        let context = params.context;
        let klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        let layers = klCanvas.getLayers();
        let selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        let fit = (0, _bb.BB).fitInto(context.canvas.width, context.canvas.height, 280, 200, 1);
        let w = parseInt("" + fit.width), h = parseInt("" + fit.height);
        let div = document.createElement("div");
        let result = {
            element: div
        };
        let isHorizontal = true;
        let isVertical = false;
        let doFlipCanvas = true;
        div.innerHTML = (0, _language.LANG)("filter-flip-description") + "<br/><br/>";
        let horizontalCheckbox = new (0, _checkbox.Checkbox)({
            init: isHorizontal,
            label: (0, _language.LANG)("filter-flip-horizontal") + " ‚ü∑",
            allowTab: true,
            callback: function(v) {
                isHorizontal = v;
                updatePreview();
            },
            css: {
                marginBottom: "10px"
            }
        });
        let verticalCheckbox = new (0, _checkbox.Checkbox)({
            init: isVertical,
            label: (0, _language.LANG)("filter-flip-vertical") + " ‚Üï",
            allowTab: true,
            callback: function(v) {
                isVertical = v;
                updatePreview();
            },
            css: {
                marginBottom: "10px"
            }
        });
        div.appendChild(horizontalCheckbox.getElement());
        div.appendChild(verticalCheckbox.getElement());
        let fcOption = document.createElement("div");
        (0, _bb.BB).setEventListener(fcOption, "onpointerdown", function() {
            return false;
        });
        fcOption.textContent = (0, _language.LANG)("filter-flip-image");
        fcOption.style.width = "150px";
        fcOption.style.height = "30px";
        fcOption.style.paddingTop = "10px";
        fcOption.style.textAlign = "center";
        fcOption.style.cssFloat = "left";
        fcOption.style.paddingBottom = "0px";
        fcOption.style.borderTopLeftRadius = "10px";
        fcOption.style.boxShadow = "inset 0px 5px 10px rgba(0,0,0,0.5)";
        fcOption.style.background = "url(" + (0, _checkmarkSvgDefault.default) + ") no-repeat 12px 16px";
        fcOption.style.backgroundSize = "8%";
        fcOption.style.backgroundColor = "#9e9e9e";
        let flOption = document.createElement("div");
        (0, _bb.BB).setEventListener(flOption, "onpointerdown", function() {
            return false;
        });
        flOption.textContent = (0, _language.LANG)("filter-flip-layer");
        flOption.style.width = "150px";
        flOption.style.height = "30px";
        flOption.style.paddingTop = "10px";
        flOption.style.textAlign = "center";
        flOption.style.cssFloat = "left";
        flOption.style.paddingBottom = "0px";
        flOption.style.borderTopRightRadius = "10px";
        flOption.style.cursor = "pointer";
        flOption.style.backgroundColor = "rgba(0, 0, 0, 0.1)";
        flOption.style.backgroundSize = "8%";
        (0, _bb.BB).setEventListener(fcOption, "onpointerover", function() {
            if (doFlipCanvas === false) fcOption.style.backgroundColor = "#ccc";
        });
        (0, _bb.BB).setEventListener(fcOption, "onpointerout", function() {
            if (doFlipCanvas === false) fcOption.style.backgroundColor = "rgba(0, 0, 0, 0.1)";
        });
        (0, _bb.BB).setEventListener(flOption, "onpointerover", function() {
            if (doFlipCanvas === true) flOption.style.backgroundColor = "#ccc";
        });
        (0, _bb.BB).setEventListener(flOption, "onpointerout", function() {
            if (doFlipCanvas === true) flOption.style.backgroundColor = "rgba(0, 0, 0, 0.1)";
        });
        fcOption.onclick = function() {
            doFlipCanvas = true;
            flOption.style.background = "";
            flOption.style.backgroundColor = "rgba(0, 0, 0, 0.1)";
            flOption.style.boxShadow = "";
            flOption.style.cursor = "pointer";
            fcOption.style.background = "url(" + (0, _checkmarkSvgDefault.default) + ") no-repeat 12px 16px";
            fcOption.style.backgroundSize = "8%";
            fcOption.style.backgroundColor = "#9e9e9e";
            fcOption.style.cursor = "default";
            fcOption.style.boxShadow = "inset 0px 5px 10px rgba(0,0,0,0.5)";
            updatePreview();
        };
        flOption.onclick = function() {
            doFlipCanvas = false;
            fcOption.style.background = "";
            fcOption.style.backgroundColor = "rgba(0, 0, 0, 0.1)";
            fcOption.style.boxShadow = "";
            fcOption.style.cursor = "pointer";
            flOption.style.background = "url(" + (0, _checkmarkSvgDefault.default) + ") no-repeat 12px 16px";
            flOption.style.backgroundSize = "8%";
            flOption.style.backgroundColor = "#9e9e9e";
            flOption.style.cursor = "default";
            flOption.style.boxShadow = "inset 0px 5px 10px rgba(0,0,0,0.5)";
            updatePreview();
        };
        let optionWrapper = document.createElement("div");
        optionWrapper.appendChild(fcOption);
        optionWrapper.appendChild(flOption);
        div.appendChild(optionWrapper);
        let previewWrapper = document.createElement("div");
        (0, _bb.BB).css(previewWrapper, {
            width: "340px",
            marginLeft: "-20px",
            height: "220px",
            backgroundColor: "#9e9e9e",
            marginTop: "10px",
            boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
            overflow: "hidden",
            position: "relative",
            userSelect: "none",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            colorScheme: "only light"
        });
        let previewLayer = {
            image: (0, _bb.BB).canvas(Math.round(w), Math.round(h)),
            opacity: 1,
            mixModeStr: "source-over"
        };
        let klCanvasPreview = new (0, _canvasPreview.KlCanvasPreview)({
            width: Math.round(w),
            height: Math.round(h),
            layers: [
                previewLayer
            ]
        });
        let previewInnerWrapper = (0, _bb.BB).el({
            css: {
                position: "relative",
                boxShadow: "0 0 5px rgba(0,0,0,0.5)",
                width: parseInt("" + w) + "px",
                height: parseInt("" + h) + "px"
            }
        });
        previewInnerWrapper.appendChild(klCanvasPreview.getElement());
        previewWrapper.appendChild(previewInnerWrapper);
        function updatePreview() {
            let ctx = previewLayer.image.getContext("2d");
            ctx.save();
            ctx.clearRect(0, 0, previewLayer.image.width, previewLayer.image.height);
            if (doFlipCanvas) {
                if (isHorizontal) {
                    ctx.translate(previewLayer.image.width, 0);
                    ctx.scale(-1, 1);
                }
                if (isVertical) {
                    ctx.translate(0, previewLayer.image.height);
                    ctx.scale(1, -1);
                }
            }
            for(let i = 0; i < layers.length; i++){
                ctx.save();
                if (!doFlipCanvas && selectedLayerIndex === i) {
                    if (isHorizontal) {
                        ctx.translate(previewLayer.image.width, 0);
                        ctx.scale(-1, 1);
                    }
                    if (isVertical) {
                        ctx.translate(0, previewLayer.image.height);
                        ctx.scale(1, -1);
                    }
                }
                if (ctx.canvas.width > layers[i].context.canvas.width) ctx.imageSmoothingEnabled = false;
                ctx.globalAlpha = layers[i].opacity;
                ctx.globalCompositeOperation = layers[i].mixModeStr;
                ctx.drawImage(layers[i].context.canvas, 0, 0, previewLayer.image.width, previewLayer.image.height);
                ctx.restore();
            }
            klCanvasPreview.render();
            ctx.restore();
        }
        setTimeout(updatePreview, 0);
        div.appendChild(previewWrapper);
        result.destroy = ()=>{
            horizontalCheckbox.destroy();
            verticalCheckbox.destroy();
        };
        result.getInput = function() {
            result.destroy();
            return {
                horizontal: isHorizontal,
                vertical: isVertical,
                flipCanvas: doFlipCanvas
            };
        };
        return result;
    },
    apply (params) {
        let context = params.context;
        let klCanvas = params.klCanvas;
        let history = params.history;
        let horizontal = params.input.horizontal;
        let vertical = params.input.vertical;
        let flipCanvas = params.input.flipCanvas;
        if (!context || !klCanvas || !history) return false;
        history.pause(true);
        klCanvas.flip(horizontal, vertical, flipCanvas ? null : klCanvas.getLayerIndex(context.canvas));
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "flip"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","../ui/base-components/checkbox":"kPAwM","../canvas-ui/canvas-preview":"gRZnS","url:~/src/app/img/ui/checkmark.svg":"c3hrK","../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c3hrK":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "checkmark.285d62a3.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"kj8ue":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterHueSaturation", ()=>filterHueSaturation);
var _bb = require("../../bb/bb");
var _filtersConsts = require("./filters-consts");
var _klSlider = require("../ui/base-components/kl-slider");
var _canvasPreview = require("../canvas-ui/canvas-preview");
var _sharedGlFx = require("./shared-gl-fx");
var _language = require("../../language/language");
const filterHueSaturation = {
    getDialog (params) {
        let context = params.context;
        let klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        let layers = klCanvas.getLayers();
        let selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        let fit = (0, _bb.BB).fitInto(context.canvas.width, context.canvas.height, 280, 200, 1);
        let w = parseInt("" + fit.width), h = parseInt("" + fit.height);
        let tempCanvas = (0, _bb.BB).canvas(w, h);
        {
            const ctx = tempCanvas.getContext("2d");
            ctx.save();
            if (tempCanvas.width > context.canvas.width) ctx.imageSmoothingEnabled = false;
            ctx.drawImage(context.canvas, 0, 0, w, h);
            ctx.restore();
        }
        let div = document.createElement("div");
        let result = {
            element: div
        };
        function finishInit() {
            let hue = 0, saturation = 0;
            div.innerHTML = (0, _language.LANG)("filter-hue-sat-description") + "<br/><br/>";
            let glCanvas = (0, _sharedGlFx.getSharedFx)();
            if (!glCanvas) return; // todo throw?
            let texture = glCanvas.texture(tempCanvas);
            glCanvas.draw(texture).update(); // update glCanvas size
            let hueSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("filter-hue-sat-hue"),
                width: 300,
                height: 30,
                min: -100,
                max: 100,
                value: hue * 100,
                eventResMs: (0, _filtersConsts.eventResMs),
                onChange: function(val) {
                    hue = val / 100;
                    glCanvas.draw(texture).hueSaturation(hue, saturation).update();
                    klCanvasPreview.render();
                }
            });
            let saturationSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("filter-hue-sat-saturation"),
                width: 300,
                height: 30,
                min: 0,
                max: 100,
                value: (saturation + 1) * 50,
                eventResMs: (0, _filtersConsts.eventResMs),
                onChange: function(val) {
                    saturation = val / 50 - 1;
                    glCanvas.draw(texture).hueSaturation(hue, saturation).update();
                    klCanvasPreview.render();
                }
            });
            hueSlider.getElement().style.marginBottom = "10px";
            div.appendChild(hueSlider.getElement());
            div.appendChild(saturationSlider.getElement());
            let previewWrapper = document.createElement("div");
            (0, _bb.BB).css(previewWrapper, {
                width: "340px",
                marginLeft: "-20px",
                height: "220px",
                backgroundColor: "#9e9e9e",
                marginTop: "10px",
                boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
                overflow: "hidden",
                position: "relative",
                userSelect: "none",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                colorScheme: "only light"
            });
            let previewLayerArr = [];
            for(let i = 0; i < layers.length; i++)previewLayerArr.push({
                image: i === selectedLayerIndex ? glCanvas : layers[i].context.canvas,
                opacity: layers[i].opacity,
                mixModeStr: layers[i].mixModeStr
            });
            let klCanvasPreview = new (0, _canvasPreview.KlCanvasPreview)({
                width: parseInt("" + w),
                height: parseInt("" + h),
                layers: previewLayerArr
            });
            let previewInnerWrapper = (0, _bb.BB).el({
                css: {
                    position: "relative",
                    boxShadow: "0 0 5px rgba(0,0,0,0.5)",
                    width: parseInt("" + w) + "px",
                    height: parseInt("" + h) + "px"
                }
            });
            previewInnerWrapper.appendChild(klCanvasPreview.getElement());
            previewWrapper.appendChild(previewInnerWrapper);
            div.appendChild(previewWrapper);
            try {
                glCanvas.draw(texture).hueSaturation(hue, saturation).update();
                klCanvasPreview.render();
            } catch (e) {
                div.errorCallback(e);
            }
            result.destroy = ()=>{
                hueSlider.destroy();
                saturationSlider.destroy();
                texture.destroy();
            };
            result.getInput = function() {
                result.destroy();
                return {
                    hue: hue,
                    Saturation: saturation
                };
            };
        }
        setTimeout(finishInit, 1);
        return result;
    },
    apply (params) {
        let context = params.context;
        let hue = params.input.hue;
        let history = params.history;
        let Saturation = params.input.Saturation;
        if (!context || hue === null || Saturation === null || !history) return false;
        history.pause(true);
        let glCanvas = (0, _sharedGlFx.getSharedFx)();
        if (!glCanvas) return false; // todo more specific error?
        let texture = glCanvas.texture(context.canvas);
        glCanvas.draw(texture).hueSaturation(hue, Saturation).update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(glCanvas, 0, 0);
        texture.destroy();
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "hueSaturation"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","./filters-consts":"7Xzbl","../ui/base-components/kl-slider":"6YGce","../canvas-ui/canvas-preview":"gRZnS","./shared-gl-fx":"4bJZi","../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1YJog":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterInvert", ()=>filterInvert);
var _sharedGlFx = require("./shared-gl-fx");
const filterInvert = {
    apply (params) {
        let context = params.context;
        let history = params.history;
        if (!context || !history) return false;
        history.pause(true);
        let glCanvas = (0, _sharedGlFx.getSharedFx)();
        if (!glCanvas) return false;
        let texture = glCanvas.texture(context.canvas);
        glCanvas.draw(texture).invert().update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(glCanvas, 0, 0);
        texture.destroy();
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "invert"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"./shared-gl-fx":"4bJZi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3vxXl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterPerspective", ()=>filterPerspective);
var _bb = require("../../bb/bb");
var _canvasPreview = require("../canvas-ui/canvas-preview");
var _sharedGlFx = require("./shared-gl-fx");
var _language = require("../../language/language");
var _twoTabs = require("../ui/components/two-tabs");
const filterPerspective = {
    getDialog (params) {
        let context = params.context;
        let klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        let isSmall = window.innerWidth < 550;
        let layers = klCanvas.getLayers();
        let selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        let fit = (0, _bb.BB).fitInto(context.canvas.width, context.canvas.height, isSmall ? 280 : 490, isSmall ? 200 : 240, 1);
        let displayW = parseInt("" + fit.width), displayH = parseInt("" + fit.height);
        let w = Math.min(displayW, context.canvas.width);
        let h = Math.min(displayH, context.canvas.height);
        let tempCanvas = (0, _bb.BB).canvas(w, h);
        {
            const ctx = tempCanvas.getContext("2d");
            ctx.save();
            if (w > context.canvas.width) ctx.imageSmoothingEnabled = false;
            ctx.drawImage(context.canvas, 0, 0, w, h);
            ctx.restore();
        }
        let displayPreviewFactor = displayW / context.canvas.width;
        let div = document.createElement("div");
        let result = {
            element: div
        };
        if (!isSmall) result.width = 500;
        let pointerListenerArr = [];
        function finishInit() {
            div.innerHTML = (0, _language.LANG)("filter-perspective-description") + "<br/><br/>";
            let glCanvas = (0, _sharedGlFx.getSharedFx)();
            if (!glCanvas) return; // todo throw?
            let texture = glCanvas.texture(tempCanvas);
            glCanvas.draw(texture).update(); // update glCanvas size
            let ba, bb, bc, bd; //before
            let aa, ab, ac, ad; //after
            function update() {
                try {
                    glCanvas.draw(texture).multiplyAlpha().perspective([
                        ba.x,
                        ba.y,
                        bb.x,
                        bb.y,
                        bc.x,
                        bc.y,
                        bd.x,
                        bd.y
                    ].map((item, i)=>{
                        if (i % 2 === 0) return item / displayW * w;
                        else return item / displayH * h;
                    }), [
                        aa.x,
                        aa.y,
                        ab.x,
                        ab.y,
                        ac.x,
                        ac.y,
                        ad.x,
                        ad.y
                    ].map((item, i)=>{
                        if (i % 2 === 0) return item / displayW * w;
                        else return item / displayH * h;
                    })).unmultiplyAlpha().update();
                    klCanvasPreview.render();
                } catch (e) {
                    div.errorCallback(e);
                }
            }
            function nob(x, y, callback) {
                let nobSize = 14;
                let div = document.createElement("div");
                div.x = x;
                div.y = y;
                (0, _bb.BB).css(div, {
                    width: nobSize + "px",
                    height: nobSize + "px",
                    backgroundColor: "#fff",
                    boxShadow: "inset 0 0 0 2px #000",
                    borderRadius: nobSize + "px",
                    position: "absolute",
                    cursor: "move",
                    left: div.x - nobSize / 2 + "px",
                    top: div.y - nobSize / 2 + "px",
                    userSelect: "none",
                    touchAction: "none"
                });
                let pointerListener = new (0, _bb.BB).PointerListener({
                    target: div,
                    maxPointers: 1,
                    onPointer: function(event) {
                        event.eventPreventDefault();
                        if (event.button === "left" && event.type === "pointermove") {
                            div.x += event.dX;
                            div.y += event.dY;
                            div.style.left = div.x - nobSize / 2 + "px";
                            div.style.top = div.y - nobSize / 2 + "px";
                            if (callback) callback();
                            update();
                        }
                    }
                });
                div.copy = function(p) {
                    div.x = p.x;
                    div.y = p.y;
                    div.style.left = div.x - nobSize / 2 + "px";
                    div.style.top = div.y - nobSize / 2 + "px";
                };
                pointerListenerArr.push(pointerListener);
                return div;
            }
            function updateAfter() {
                aa.copy(ba);
                ab.copy(bb);
                ac.copy(bc);
                ad.copy(bd);
            }
            ba = nob(0, 0, updateAfter);
            bb = nob(displayW, 0, updateAfter);
            bc = nob(displayW, displayH, updateAfter);
            bd = nob(0, displayH, updateAfter);
            aa = nob(0, 0);
            ab = nob(displayW, 0);
            ac = nob(displayW, displayH);
            ad = nob(0, displayH);
            let before = false;
            const beforeAfterTabs = new (0, _twoTabs.TwoTabs)({
                left: (0, _language.LANG)("compare-before"),
                right: (0, _language.LANG)("compare-after"),
                init: 1,
                onChange: (val)=>{
                    before = val === 0;
                    if (before) {
                        aa.style.display = "none";
                        ab.style.display = "none";
                        ac.style.display = "none";
                        ad.style.display = "none";
                        ba.style.display = "block";
                        bb.style.display = "block";
                        bc.style.display = "block";
                        bd.style.display = "block";
                        ba.copy(aa);
                        bb.copy(ab);
                        bc.copy(ac);
                        bd.copy(ad);
                    } else {
                        ba.style.display = "none";
                        bb.style.display = "none";
                        bc.style.display = "none";
                        bd.style.display = "none";
                        aa.style.display = "block";
                        ab.style.display = "block";
                        ac.style.display = "block";
                        ad.style.display = "block";
                        aa.copy(ba);
                        ab.copy(bb);
                        ac.copy(bc);
                        ad.copy(bd);
                    }
                    update();
                }
            });
            div.append(beforeAfterTabs.getElement());
            let previewWrapper = document.createElement("div");
            previewWrapper.oncontextmenu = function() {
                return false;
            };
            (0, _bb.BB).css(previewWrapper, {
                width: isSmall ? "340px" : "540px",
                marginLeft: "-20px",
                height: isSmall ? "260px" : "300px",
                backgroundColor: "#9e9e9e",
                boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
                overflow: "hidden",
                position: "relative",
                userSelect: "none",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                colorScheme: "only light"
            });
            let previewLayerArr = [];
            for(let i = 0; i < layers.length; i++){
                let canvas = i === selectedLayerIndex ? glCanvas : layers[i].context.canvas;
                previewLayerArr.push({
                    image: canvas,
                    opacity: layers[i].opacity,
                    mixModeStr: layers[i].mixModeStr
                });
            }
            let klCanvasPreview = new (0, _canvasPreview.KlCanvasPreview)({
                width: parseInt("" + displayW),
                height: parseInt("" + displayH),
                layers: previewLayerArr
            });
            let previewInnerWrapper = (0, _bb.BB).el({
                css: {
                    position: "relative",
                    boxShadow: "0 0 5px rgba(0,0,0,0.5)",
                    width: parseInt("" + displayW) + "px",
                    height: parseInt("" + displayH) + "px"
                }
            });
            previewInnerWrapper.appendChild(klCanvasPreview.getElement());
            previewWrapper.appendChild(previewInnerWrapper);
            previewInnerWrapper.appendChild(aa);
            previewInnerWrapper.appendChild(ab);
            previewInnerWrapper.appendChild(ac);
            previewInnerWrapper.appendChild(ad);
            ba.style.display = "none";
            bb.style.display = "none";
            bc.style.display = "none";
            bd.style.display = "none";
            previewInnerWrapper.appendChild(ba);
            previewInnerWrapper.appendChild(bb);
            previewInnerWrapper.appendChild(bc);
            previewInnerWrapper.appendChild(bd);
            div.appendChild(previewWrapper);
            update();
            result.destroy = ()=>{
                for(let i = 0; i < pointerListenerArr.length; i++)pointerListenerArr[i].destroy();
                texture.destroy();
            };
            result.getInput = function() {
                result.destroy();
                return {
                    before: [
                        ba.x / displayPreviewFactor,
                        ba.y / displayPreviewFactor,
                        bb.x / displayPreviewFactor,
                        bb.y / displayPreviewFactor,
                        bc.x / displayPreviewFactor,
                        bc.y / displayPreviewFactor,
                        bd.x / displayPreviewFactor,
                        bd.y / displayPreviewFactor, 
                    ],
                    after: [
                        aa.x / displayPreviewFactor,
                        aa.y / displayPreviewFactor,
                        ab.x / displayPreviewFactor,
                        ab.y / displayPreviewFactor,
                        ac.x / displayPreviewFactor,
                        ac.y / displayPreviewFactor,
                        ad.x / displayPreviewFactor,
                        ad.y / displayPreviewFactor, 
                    ]
                };
            };
        }
        setTimeout(finishInit, 1);
        return result;
    },
    apply (params) {
        let context = params.context;
        let history = params.history;
        let before = params.input.before;
        let after = params.input.after;
        if (!context || !before || !after || !history) return false;
        history.pause(true);
        let glCanvas = (0, _sharedGlFx.getSharedFx)();
        if (!glCanvas) return false; // todo more specific error?
        let texture = glCanvas.texture(context.canvas);
        glCanvas.draw(texture).multiplyAlpha().perspective(before, after).unmultiplyAlpha().update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(glCanvas, 0, 0);
        texture.destroy();
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "perspective"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","../canvas-ui/canvas-preview":"gRZnS","./shared-gl-fx":"4bJZi","../../language/language":"iiYGN","../ui/components/two-tabs":"edCwK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"edCwK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TwoTabs", ()=>TwoTabs);
var _bb = require("../../../bb/bb");
// @ts-ignore
var _checkmarkSvg = require("url:~/src/app/img/ui/checkmark.svg");
var _checkmarkSvgDefault = parcelHelpers.interopDefault(_checkmarkSvg);
const activeColor = "#9e9e9e";
const inactiveColor = "rgba(0,0,0,0.1)";
const hoverColor = "#ccc";
class TwoTabs {
    update() {
        if (this.value === 0) {
            (0, _bb.BB).css(this.leftTab, {
                background: "url(" + (0, _checkmarkSvgDefault.default) + ") no-repeat 12px 16px",
                backgroundColor: activeColor,
                backgroundSize: "8%",
                boxShadow: "inset 0px 5px 10px rgba(0,0,0,0.5)",
                cursor: "default"
            });
            (0, _bb.BB).css(this.rightTab, {
                background: "",
                backgroundColor: inactiveColor,
                backgroundSize: "8%",
                boxShadow: "",
                cursor: "pointer"
            });
        } else {
            (0, _bb.BB).css(this.rightTab, {
                background: "url(" + (0, _checkmarkSvgDefault.default) + ") no-repeat 12px 16px",
                backgroundColor: activeColor,
                backgroundSize: "8%",
                boxShadow: "inset 0px 5px 10px rgba(0,0,0,0.5)",
                cursor: "default"
            });
            (0, _bb.BB).css(this.leftTab, {
                background: "",
                backgroundColor: inactiveColor,
                backgroundSize: "8%",
                boxShadow: "",
                cursor: "pointer"
            });
        }
    }
    // ---- public ----
    constructor(params){
        this.value = params.init;
        this.rootEl = (0, _bb.BB).el({
            css: {
                display: "flex",
                justifyContent: "center"
            }
        });
        this.leftTab = (0, _bb.BB).el({
            parent: this.rootEl,
            content: params.left,
            css: {
                width: "150px",
                height: "30px",
                paddingTop: "10px",
                textAlign: "center",
                paddingBottom: "0",
                borderTopLeftRadius: "10px",
                backgroundSize: "8%"
            }
        });
        (0, _bb.BB).setEventListener(this.leftTab, "onpointerdown", function() {
            return false;
        });
        this.rightTab = (0, _bb.BB).el({
            parent: this.rootEl,
            content: params.right,
            css: {
                width: "150px",
                height: "30px",
                paddingTop: "10px",
                textAlign: "center",
                paddingBottom: "0",
                borderTopRightRadius: "10px",
                backgroundSize: "8%"
            }
        });
        (0, _bb.BB).setEventListener(this.rightTab, "onpointerdown", ()=>{
            return false;
        });
        this.update();
        (0, _bb.BB).setEventListener(this.leftTab, "onpointerover", ()=>{
            if (this.value !== 0) this.leftTab.style.backgroundColor = hoverColor;
        });
        (0, _bb.BB).setEventListener(this.leftTab, "onpointerout", ()=>{
            if (this.value !== 0) this.leftTab.style.backgroundColor = inactiveColor;
        });
        (0, _bb.BB).setEventListener(this.rightTab, "onpointerover", ()=>{
            if (this.value !== 1) this.rightTab.style.backgroundColor = hoverColor;
        });
        (0, _bb.BB).setEventListener(this.rightTab, "onpointerout", ()=>{
            if (this.value !== 1) this.rightTab.style.backgroundColor = inactiveColor;
        });
        this.leftTab.onclick = ()=>{
            if (this.value === 0) return;
            this.value = 0;
            this.update();
            params.onChange(this.value);
        };
        this.rightTab.onclick = ()=>{
            if (this.value === 1) return;
            this.value = 1;
            this.update();
            params.onChange(this.value);
        };
    }
    getElement() {
        return this.rootEl;
    }
}

},{"../../../bb/bb":"dcQKo","url:~/src/app/img/ui/checkmark.svg":"c3hrK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kqYtn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterResize", ()=>filterResize);
var _bb = require("../../bb/bb");
var _checkbox = require("../ui/base-components/checkbox");
var _select = require("../ui/base-components/select");
// @ts-ignore
var _constrainSvg = require("url:~/src/app/img/ui/constrain.svg");
var _constrainSvgDefault = parcelHelpers.interopDefault(_constrainSvg);
var _language = require("../../language/language");
const filterResize = {
    getDialog (params) {
        //BB.centerWithin
        let klCanvas = params.klCanvas;
        if (!klCanvas) return false;
        let fit = (0, _bb.BB).fitInto(klCanvas.getWidth(), klCanvas.getHeight(), 280, 200, 1);
        let w = parseInt("" + fit.width), h = parseInt("" + fit.height);
        let previewFactor = w / klCanvas.getWidth();
        let tempCanvas = klCanvas.getCompleteCanvas(1);
        let div = document.createElement("div");
        let result = {
            element: div
        };
        let newWidth = klCanvas.getWidth(), newHeight = klCanvas.getHeight();
        div.innerHTML = (0, _language.LANG)("filter-resize-description") + "<br/><br/>";
        let maxWidth = params.maxWidth, maxHeight = params.maxHeight;
        let widthWrapper = (0, _bb.BB).el({
            css: {
                width: "150px",
                height: "35px",
                lineHeight: "30px"
            }
        });
        let heightWrapper = (0, _bb.BB).el({
            css: {
                width: "150px",
                height: "35px",
                lineHeight: "30px"
            }
        });
        let widthInput = (0, _bb.BB).el({
            tagName: "input",
            css: {
                cssFloat: "right",
                width: "90px"
            },
            custom: {
                type: "number",
                min: "1",
                max: "" + maxWidth,
                value: "" + klCanvas.getWidth()
            }
        });
        let heightInput = (0, _bb.BB).el({
            tagName: "input",
            css: {
                cssFloat: "right",
                width: "90px"
            },
            custom: {
                type: "number",
                min: "1",
                max: "" + maxHeight,
                value: "" + klCanvas.getHeight()
            }
        });
        widthInput.onclick = function() {
            this.focus();
            widthChanged = true;
            update();
        };
        heightInput.onclick = function() {
            this.focus();
            heightChanged = true;
            update();
        };
        widthInput.onchange = function() {
            widthChanged = true;
            update();
        };
        heightInput.onchange = function() {
            heightChanged = true;
            update();
        };
        widthWrapper.append((0, _language.LANG)("width") + ": ", widthInput);
        heightWrapper.append((0, _language.LANG)("height") + ": ", heightInput);
        let inputWrapper = (0, _bb.BB).el({
            css: {
                background: "url(" + (0, _constrainSvgDefault.default) + ") no-repeat 140px 5px",
                backgroundSize: "50px 52px"
            }
        });
        inputWrapper.append(widthWrapper, heightWrapper);
        div.appendChild(inputWrapper);
        //contrain checkbox
        let heightChanged = false, widthChanged = false;
        let ratio = klCanvas.getWidth() / klCanvas.getHeight();
        function updateConstrain() {
            if (isConstrained) {
                widthInput.value = "" + klCanvas.getWidth();
                heightInput.value = "" + klCanvas.getHeight();
                inputWrapper.style.background = "url(" + (0, _constrainSvgDefault.default) + ") no-repeat 140px 5px";
                inputWrapper.style.backgroundSize = "50px 52px";
                update();
            } else inputWrapper.style.background = "";
        }
        let isConstrained = true;
        let constrainCheckbox = new (0, _checkbox.Checkbox)({
            init: true,
            label: (0, _language.LANG)("constrain-proportions"),
            allowTab: true,
            callback: function(b) {
                isConstrained = b;
                updateConstrain();
            }
        });
        div.appendChild((0, _bb.BB).el({
            css: {
                clear: "both"
            }
        }));
        let algorithmSelect = new (0, _select.Select)({
            isFocusable: true,
            optionArr: [
                [
                    "smooth",
                    (0, _language.LANG)("algorithm-smooth")
                ],
                [
                    "pixelated",
                    (0, _language.LANG)("algorithm-pixelated")
                ]
            ],
            title: (0, _language.LANG)("scaling-algorithm"),
            initValue: "smooth",
            onChange: function() {
                update();
            }
        });
        let secondRowElement = (0, _bb.BB).el({
            parent: div,
            css: {
                display: "flex",
                justifyContent: "space-between"
            }
        });
        secondRowElement.appendChild(constrainCheckbox.getElement());
        secondRowElement.appendChild(algorithmSelect.getElement());
        let previewCanvas = (0, _bb.BB).canvas(w, h);
        previewCanvas.style.imageRendering = "pixelated";
        let previewCtx = previewCanvas.getContext("2d");
        function draw() {
            if (algorithmSelect.getValue() === "smooth") {
                previewCanvas.style.imageRendering = previewFactor > 1 ? "pixelated" : "";
                previewCanvas.width = klCanvas.getWidth();
                previewCanvas.height = klCanvas.getHeight();
                previewCtx.save();
                previewCtx.imageSmoothingQuality = "high";
                previewCtx.drawImage(tempCanvas, 0, 0);
                (0, _bb.BB).resizeCanvas(previewCanvas, newWidth, newHeight);
                previewCtx.restore();
            } else {
                previewCanvas.style.imageRendering = "pixelated";
                previewCanvas.width = newWidth;
                previewCanvas.height = newHeight;
                previewCtx.save();
                previewCtx.imageSmoothingEnabled = false;
                previewCtx.drawImage(tempCanvas, 0, 0, previewCanvas.width, previewCanvas.height);
                previewCtx.restore();
            }
        }
        function update() {
            if (widthInput.value.length === 0 && widthChanged || heightInput.value.length === 0 && heightChanged) {
                heightChanged = false;
                widthChanged = false;
                return;
            }
            widthInput.value = "" + Math.max(1, parseInt(widthInput.value));
            heightInput.value = "" + Math.max(1, parseInt(heightInput.value));
            if (isConstrained) {
                if (heightChanged) widthInput.value = "" + parseInt("" + parseInt(heightInput.value) * ratio);
                if (widthChanged) heightInput.value = "" + parseInt("" + parseInt(widthInput.value) / ratio);
                if (parseInt(widthInput.value) > maxWidth || parseInt(heightInput.value) > maxHeight) {
                    let fit = (0, _bb.BB).fitInto(parseInt(widthInput.value), parseInt(heightInput.value), maxWidth, maxHeight, 1);
                    widthInput.value = "" + parseInt("" + fit.width);
                    heightInput.value = "" + parseInt("" + fit.height);
                }
            }
            if (parseInt(widthInput.value) > maxWidth) widthInput.value = "" + maxWidth;
            if (parseInt(heightInput.value) > maxHeight) heightInput.value = "" + maxHeight;
            heightChanged = false;
            widthChanged = false;
            newWidth = parseInt(widthInput.value);
            newHeight = parseInt(heightInput.value);
            let preview = (0, _bb.BB).fitInto(newWidth, newHeight, 280, 200, 1);
            let previewW = parseInt("" + preview.width), previewH = parseInt("" + preview.height);
            previewFactor = previewW / newWidth;
            let offset = (0, _bb.BB).centerWithin(340, 220, previewW, previewH);
            draw();
            previewCanvas.style.width = Math.max(1, previewW) + "px";
            previewCanvas.style.height = Math.max(1, previewH) + "px";
            canvasWrapper.style.left = offset.x + "px";
            canvasWrapper.style.top = offset.y + "px";
            canvasWrapper.style.width = Math.max(1, previewW) + "px";
            canvasWrapper.style.height = Math.max(1, previewH) + "px";
        }
        let previewWrapper = document.createElement("div");
        (0, _bb.BB).css(previewWrapper, {
            width: "340px",
            marginLeft: "-20px",
            height: "220px",
            display: "table",
            backgroundColor: "#9e9e9e",
            marginTop: "10px",
            boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
            position: "relative",
            userSelect: "none",
            colorScheme: "only light"
        });
        let canvasWrapper = (0, _bb.BB).appendTextDiv(previewWrapper, "");
        canvasWrapper.appendChild(previewCanvas);
        canvasWrapper.style.width = w + "px";
        canvasWrapper.style.height = h + "px";
        canvasWrapper.style.position = "absolute";
        canvasWrapper.style.overflow = "hidden";
        canvasWrapper.style.boxShadow = "0 0 5px rgba(0,0,0,0.8)";
        canvasWrapper.style.overflow = "hidden";
        (0, _bb.BB).createCheckerDataUrl(8, function(url) {
            previewWrapper.style.background = "url(" + url + ")";
        });
        div.appendChild(previewWrapper);
        update();
        result.destroy = ()=>{
            constrainCheckbox.destroy();
        };
        result.getInput = function() {
            result.destroy();
            return {
                width: newWidth,
                height: newHeight,
                algorithm: algorithmSelect.getValue()
            };
        };
        return result;
    },
    apply (params) {
        let klCanvas = params.klCanvas;
        let history = params.history;
        let width = params.input.width;
        let height = params.input.height;
        let algorithm = params.input.algorithm;
        if (!klCanvas || !history) return false;
        history.pause(true);
        klCanvas.resize(width, height, algorithm);
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "resize"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","../ui/base-components/checkbox":"kPAwM","../ui/base-components/select":"7mzRU","url:~/src/app/img/ui/constrain.svg":"8Ru2Q","../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8Ru2Q":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "constrain.6950789f.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"8CV7p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterRotate", ()=>filterRotate);
var _bb = require("../../bb/bb");
var _language = require("../../language/language");
const filterRotate = {
    getDialog (params) {
        let klCanvas = params.klCanvas;
        if (!klCanvas) return false;
        let fit = (0, _bb.BB).fitInto(klCanvas.getWidth(), klCanvas.getHeight(), 280, 200, 1);
        let w = parseInt("" + fit.width), h = parseInt("" + fit.height);
        let previewFactor = w / klCanvas.getWidth();
        let tempCanvas = (0, _bb.BB).canvas(w, h);
        tempCanvas.style.display = "block";
        tempCanvas.getContext("2d").drawImage(klCanvas.getCompleteCanvas(previewFactor), 0, 0, w, h);
        let div = document.createElement("div");
        let result = {
            element: div
        };
        let deg = 0;
        div.innerHTML = (0, _language.LANG)("filter-rotate-description") + "<br/><br/>";
        let first = true;
        function update() {
            canvasWrapper.style.WebkitTransform = "rotate(" + deg + "deg)";
            canvasWrapper.style.MozTransform = "rotate(" + deg + "deg)";
            canvasWrapper.style.OTransform = "rotate(" + deg + "deg)";
            canvasWrapper.style.msTransform = "rotate(" + deg + "deg)";
            if (Math.abs(deg % 180) === 90) {
                //height has to fit width because of rotation
                let fit = (0, _bb.BB).fitInto(h, w, 280, 200, 1);
                let scale = parseInt("" + fit.height) / w;
                canvasWrapper.style.WebkitTransform = "rotate(" + deg + "deg) scale(" + scale + ")";
                canvasWrapper.style.MozTransform = "rotate(" + deg + "deg) scale(" + scale + ")";
                canvasWrapper.style.OTransform = "rotate(" + deg + "deg) scale(" + scale + ")";
                canvasWrapper.style.msTransform = "rotate(" + deg + "deg) scale(" + scale + ")";
            }
        }
        let btnPlus = document.createElement("button");
        btnPlus.innerHTML = "<span style='font-size: 1.3em'>‚ü≥</span> 90\xb0";
        let btnMinus = document.createElement("button");
        btnMinus.innerHTML = "<span style='font-size: 1.3em'>‚ü≤</span> 90\xb0";
        btnMinus.style.marginRight = "5px";
        btnPlus.onclick = function() {
            deg += 90;
            update();
        };
        btnMinus.onclick = function() {
            deg -= 90;
            update();
        };
        div.appendChild(btnMinus);
        div.appendChild(btnPlus);
        let previewWrapper = document.createElement("div");
        (0, _bb.BB).css(previewWrapper, {
            width: "340px",
            marginLeft: "-20px",
            height: "220px",
            display: "table",
            backgroundColor: "#9e9e9e",
            marginTop: "10px",
            boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
            overflow: "hidden",
            position: "relative",
            userSelect: "none",
            colorScheme: "only light"
        });
        let previewcell = document.createElement("div");
        previewcell.style.display = "table-cell";
        previewcell.style.verticalAlign = "middle";
        let canvasWrapper = (0, _bb.BB).appendTextDiv(previewcell, "");
        canvasWrapper.appendChild(tempCanvas);
        previewWrapper.appendChild(previewcell);
        canvasWrapper.style.width = w + "px";
        canvasWrapper.style.height = h + "px";
        canvasWrapper.style.marginLeft = "auto";
        canvasWrapper.style.marginRight = "auto";
        canvasWrapper.style.boxShadow = "0 0 5px rgba(0,0,0,0.8)";
        canvasWrapper.style.overflow = "hidden";
        (0, _bb.BB).createCheckerDataUrl(4, function(url) {
            canvasWrapper.style.background = "url(" + url + ")";
        });
        canvasWrapper.style.transition = "all 0.2s ease-out";
        div.appendChild(previewWrapper);
        update();
        result.getInput = function() {
            return {
                deg: deg
            };
        };
        return result;
    },
    apply (params) {
        let klCanvas = params.klCanvas;
        let history = params.history;
        let deg = params.input.deg;
        if (!klCanvas || !history) return false;
        history.pause(true);
        klCanvas.rotate(deg);
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "rotate"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5Dznd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterTiltShift", ()=>filterTiltShift);
var _bb = require("../../bb/bb");
var _filtersConsts = require("./filters-consts");
var _klSlider = require("../ui/base-components/kl-slider");
var _canvasPreview = require("../canvas-ui/canvas-preview");
var _sharedGlFx = require("./shared-gl-fx");
var _language = require("../../language/language");
const filterTiltShift = {
    getDialog (params) {
        let context = params.context;
        let klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        let layers = klCanvas.getLayers();
        let selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        let fit = (0, _bb.BB).fitInto(context.canvas.width, context.canvas.height, 280, 200, 1);
        let displayW = parseInt("" + fit.width), displayH = parseInt("" + fit.height);
        let w = Math.min(displayW, context.canvas.width);
        let h = Math.min(displayH, context.canvas.height);
        let tempCanvas = (0, _bb.BB).canvas(w, h);
        {
            const ctx = tempCanvas.getContext("2d");
            ctx.save();
            if (w > context.canvas.width) ctx.imageSmoothingEnabled = false;
            ctx.drawImage(context.canvas, 0, 0, w, h);
            ctx.restore();
        }
        let previewFactor = w / context.canvas.width;
        let displayPreviewFactor = displayW / context.canvas.width;
        let div = document.createElement("div");
        let result = {
            element: div
        };
        let pointerListenerArr = [];
        function finishInit() {
            let blur = 20, gradient = 200;
            div.innerHTML = (0, _language.LANG)("filter-tilt-shift-description") + "<br/><br/>";
            let glCanvas = (0, _sharedGlFx.getSharedFx)();
            if (!glCanvas) return; // todo throw?
            let texture = glCanvas.texture(tempCanvas);
            glCanvas.draw(texture).update(); // update glCanvas size
            let fa, fb; // focus line
            function update() {
                try {
                    glCanvas.draw(texture).tiltShift(fa.x / displayPreviewFactor * previewFactor, fa.y / displayPreviewFactor * previewFactor, fb.x / displayPreviewFactor * previewFactor, fb.y / displayPreviewFactor * previewFactor, blur * previewFactor, gradient * previewFactor).update();
                    klCanvasPreview.render();
                } catch (e) {
                    div.errorCallback(e);
                }
            }
            function nob(x, y) {
                let nobSize = 14;
                let div = (0, _bb.BB).el({
                    css: {
                        width: nobSize + "px",
                        height: nobSize + "px",
                        backgroundColor: "#fff",
                        boxShadow: "inset 0 0 0 2px #000",
                        borderRadius: nobSize + "px",
                        position: "absolute",
                        cursor: "move",
                        left: x - nobSize / 2 + "px",
                        top: y - nobSize / 2 + "px",
                        userSelect: "none",
                        touchAction: "none"
                    }
                });
                div.x = x;
                div.y = y;
                let pointerListener = new (0, _bb.BB).PointerListener({
                    target: div,
                    maxPointers: 1,
                    onPointer: function(event) {
                        event.eventPreventDefault();
                        if (event.button === "left" && event.type === "pointermove") {
                            div.x += event.dX;
                            div.y += event.dY;
                            div.style.left = div.x - nobSize / 2 + "px";
                            div.style.top = div.y - nobSize / 2 + "px";
                            update();
                        }
                    }
                });
                pointerListenerArr.push(pointerListener);
                return div;
            }
            fa = nob(parseInt("" + displayW / 6), parseInt("" + displayH / 2));
            fb = nob(parseInt("" + (displayW - displayW / 6)), parseInt("" + (displayH - displayH / 3)));
            let blurSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("filter-tilt-shift-blur"),
                width: 300,
                height: 30,
                min: 0,
                max: 200,
                value: blur,
                eventResMs: (0, _filtersConsts.eventResMs),
                onChange: function(val) {
                    blur = val;
                    update();
                }
            });
            blurSlider.getElement().style.marginBottom = "10px";
            div.appendChild(blurSlider.getElement());
            let gradientSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("filter-tilt-shift-gradient"),
                width: 300,
                height: 30,
                min: 0,
                max: 1000,
                value: gradient,
                eventResMs: (0, _filtersConsts.eventResMs),
                onChange: function(val) {
                    gradient = val;
                    update();
                }
            });
            div.appendChild(gradientSlider.getElement());
            let previewWrapper = document.createElement("div");
            previewWrapper.oncontextmenu = function() {
                return false;
            };
            (0, _bb.BB).css(previewWrapper, {
                width: "340px",
                marginLeft: "-20px",
                height: "220px",
                backgroundColor: "#9e9e9e",
                marginTop: "10px",
                boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
                overflow: "hidden",
                position: "relative",
                userSelect: "none",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                colorScheme: "only light"
            });
            let previewLayerArr = [];
            for(let i = 0; i < layers.length; i++)previewLayerArr.push({
                image: i === selectedLayerIndex ? glCanvas : layers[i].context.canvas,
                opacity: layers[i].opacity,
                mixModeStr: layers[i].mixModeStr
            });
            let klCanvasPreview = new (0, _canvasPreview.KlCanvasPreview)({
                width: parseInt("" + displayW),
                height: parseInt("" + displayH),
                layers: previewLayerArr
            });
            let previewInnerWrapper = (0, _bb.BB).el({
                css: {
                    position: "relative",
                    boxShadow: "0 0 5px rgba(0,0,0,0.5)",
                    width: parseInt("" + displayW) + "px",
                    height: parseInt("" + displayH) + "px"
                }
            });
            previewInnerWrapper.appendChild(klCanvasPreview.getElement());
            previewWrapper.appendChild(previewInnerWrapper);
            previewInnerWrapper.appendChild(fa);
            previewInnerWrapper.appendChild(fb);
            div.appendChild(previewWrapper);
            update();
            result.destroy = ()=>{
                for(let i = 0; i < pointerListenerArr.length; i++)pointerListenerArr[i].destroy();
                blurSlider.destroy();
                gradientSlider.destroy();
                texture.destroy();
            };
            result.getInput = function() {
                result.destroy();
                return {
                    a: {
                        x: fa.x / displayPreviewFactor,
                        y: fa.y / displayPreviewFactor
                    },
                    b: {
                        x: fb.x / displayPreviewFactor,
                        y: fb.y / displayPreviewFactor
                    },
                    blur: blur,
                    gradient: gradient
                };
            };
        }
        setTimeout(finishInit, 1);
        return result;
    },
    apply (params) {
        let context = params.context;
        let history = params.history;
        let a = params.input.a;
        let b = params.input.b;
        let blur = params.input.blur;
        let gradient = params.input.gradient;
        if (!context || !history) return false;
        history.pause(true);
        let glCanvas = (0, _sharedGlFx.getSharedFx)();
        if (!glCanvas) return false; // todo more specific error?
        let texture = glCanvas.texture(context.canvas);
        glCanvas.draw(texture).tiltShift(a.x, a.y, b.x, b.y, blur, gradient).update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(glCanvas, 0, 0);
        texture.destroy();
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "tiltShift"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","./filters-consts":"7Xzbl","../ui/base-components/kl-slider":"6YGce","../canvas-ui/canvas-preview":"gRZnS","./shared-gl-fx":"4bJZi","../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7kdP4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterTransform", ()=>filterTransform);
var _bb = require("../../bb/bb");
var _checkbox = require("../ui/base-components/checkbox");
var _canvasPreview = require("../canvas-ui/canvas-preview");
var _freeTransform = require("../ui/components/free-transform");
var _select = require("../ui/base-components/select");
var _language = require("../../language/language");
const filterTransform = {
    getDialog (params) {
        let context = params.context;
        let klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        let isSmall = window.innerWidth < 550;
        let layers = klCanvas.getLayers();
        let selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        let fit = (0, _bb.BB).fitInto(context.canvas.width, context.canvas.height, isSmall ? 280 : 490, isSmall ? 200 : 240, 1);
        let displayW = parseInt("" + fit.width), displayH = parseInt("" + fit.height);
        let w = Math.min(displayW, context.canvas.width);
        let h = Math.min(displayH, context.canvas.height);
        let freeTransform;
        let displayPreviewFactor = displayW / context.canvas.width;
        // determine bounds and initial transformation
        const boundsObj = (0, _bb.BB).canvasBounds(context);
        if (boundsObj === null) {
            alert((0, _language.LANG)("filter-transform-empty"));
            return false;
        }
        const initTransform = {
            x: boundsObj.x + boundsObj.width / 2,
            y: boundsObj.y + boundsObj.height / 2,
            width: boundsObj.width,
            height: boundsObj.height,
            angleDeg: 0
        };
        let div = document.createElement("div");
        let result = {
            element: div
        };
        if (!isSmall) result.width = 500;
        div.innerHTML = (0, _language.LANG)("filter-transform-description");
        let keyListener = new (0, _bb.BB).KeyListener({
            onDown: function(keyStr) {
                if ((0, _bb.BB).isInputFocused(true)) return;
                if (keyStr === "left") {
                    inputX.value = "" + (parseFloat(inputX.value) - 1);
                    onInputsChanged();
                }
                if (keyStr === "right") {
                    inputX.value = "" + (parseFloat(inputX.value) + 1);
                    onInputsChanged();
                }
                if (keyStr === "up") {
                    inputY.value = "" + (parseFloat(inputY.value) - 1);
                    onInputsChanged();
                }
                if (keyStr === "down") {
                    inputY.value = "" + (parseFloat(inputY.value) + 1);
                    onInputsChanged();
                }
            }
        });
        let leftWrapper = document.createElement("div");
        let rightWrapper = document.createElement("div");
        let rotWrapper = document.createElement("div");
        let inputY = document.createElement("input");
        let inputX = document.createElement("input");
        let inputR = document.createElement("input");
        leftWrapper.style.width = "100px";
        leftWrapper.style.height = "30px";
        rightWrapper.style.width = "100px";
        rightWrapper.style.height = "30px";
        rightWrapper.style.display = "inline-block";
        leftWrapper.style.display = "inline-block";
        rotWrapper.style.display = "inline-block";
        rotWrapper.style.width = "150px";
        rotWrapper.style.height = "30px";
        inputY.type = "number";
        inputX.type = "number";
        inputR.type = "number";
        inputX.style.width = "70px";
        inputY.style.width = "70px";
        inputR.style.width = "70px";
        inputY.value = "0";
        inputX.value = "0";
        inputR.value = "0";
        inputY.onclick = function() {
            this.focus();
            onInputsChanged();
        };
        inputX.onclick = function() {
            this.focus();
            onInputsChanged();
        };
        inputR.onclick = function() {
            this.focus();
            onInputsChanged();
        };
        inputY.onchange = function() {
            onInputsChanged();
        };
        inputX.onchange = function() {
            onInputsChanged();
        };
        inputR.onchange = function() {
            onInputsChanged();
        };
        inputY.onkeyup = function() {
            onInputsChanged();
        };
        inputX.onkeyup = function() {
            onInputsChanged();
        };
        inputR.onkeyup = function() {
            onInputsChanged();
        };
        leftWrapper.append("X: ", inputX);
        rightWrapper.append("Y: ", inputY);
        rotWrapper.append((0, _language.LANG)("filter-transform-rotation") + ": ", inputR);
        if (!isSmall) {
            const inputRow = (0, _bb.BB).el({
                parent: div,
                css: {
                    marginTop: "10px"
                }
            });
            inputRow.append(leftWrapper, rightWrapper, rotWrapper);
        }
        // buttons
        const actionBtnCss = {
            marginLeft: "10px",
            marginTop: "10px"
        };
        const buttonRow = (0, _bb.BB).el({
            parent: div,
            css: {
                display: "flex",
                flexWrap: "wrap",
                marginLeft: "-10px"
            }
        });
        const flipXBtn = (0, _bb.BB).el({
            parent: buttonRow,
            tagName: "button",
            content: (0, _language.LANG)("filter-transform-flip") + " X",
            onClick: ()=>{
                const t = freeTransform.getTransform();
                freeTransform.setSize(-t.width, t.height);
            },
            css: actionBtnCss
        });
        const flipYBtn = (0, _bb.BB).el({
            parent: buttonRow,
            tagName: "button",
            content: (0, _language.LANG)("filter-transform-flip") + " Y",
            onClick: ()=>{
                const t = freeTransform.getTransform();
                freeTransform.setSize(t.width, -t.height);
            },
            css: actionBtnCss
        });
        const scaleRotLeftBtn = (0, _bb.BB).el({
            parent: buttonRow,
            tagName: "button",
            content: "-90\xb0",
            onClick: ()=>{
                const t = freeTransform.getTransform();
                t.angleDeg -= 90;
                t.angleDeg %= 360;
                freeTransform.setAngleDeg(t.angleDeg);
                inputR.value = "" + Math.round(t.angleDeg);
                updatePreview();
            },
            css: actionBtnCss
        });
        const scaleRotRightBtn = (0, _bb.BB).el({
            parent: buttonRow,
            tagName: "button",
            content: "+90\xb0",
            onClick: ()=>{
                const t = freeTransform.getTransform();
                t.angleDeg += 90;
                t.angleDeg %= 360;
                freeTransform.setAngleDeg(t.angleDeg);
                inputR.value = "" + Math.round(t.angleDeg);
                updatePreview();
            },
            css: actionBtnCss
        });
        const scaleDoubleBtn = (0, _bb.BB).el({
            parent: buttonRow,
            tagName: "button",
            content: "2x",
            onClick: ()=>{
                const t = freeTransform.getTransform();
                if (constrainCheckbox.getValue()) freeTransform.setSize(freeTransform.getRatio() * t.height * 2, t.height * 2);
                else freeTransform.setSize(t.width * 2, t.height * 2);
            },
            css: actionBtnCss
        });
        const scaleHalfBtn = (0, _bb.BB).el({
            parent: buttonRow,
            tagName: "button",
            content: "1/2x",
            onClick: ()=>{
                const t = freeTransform.getTransform();
                freeTransform.setSize(Math.round(t.width / 2), Math.round(t.height / 2));
            },
            css: actionBtnCss
        });
        const centerBtn = (0, _bb.BB).el({
            parent: buttonRow,
            tagName: "button",
            content: (0, _language.LANG)("center"),
            onClick: ()=>{
                const t = freeTransform.getTransform();
                freeTransform.setPos({
                    x: context.canvas.width / 2,
                    y: context.canvas.height / 2
                });
                freeTransform.setAngleDeg(t.angleDeg);
                updatePreview();
            },
            css: actionBtnCss
        });
        let isConstrained = true;
        let constrainCheckbox = new (0, _checkbox.Checkbox)({
            init: true,
            label: (0, _language.LANG)("filter-transform-constrain"),
            title: (0, _language.LANG)("constrain-proportions"),
            allowTab: true,
            callback: function(b) {
                isConstrained = b;
                freeTransform.setConstrained(isConstrained);
            },
            css: {
                display: "inline-block"
            }
        });
        let isSnapping = false;
        let snappingCheckbox = new (0, _checkbox.Checkbox)({
            init: true,
            label: (0, _language.LANG)("filter-transform-snap"),
            title: (0, _language.LANG)("filter-transform-snap-title"),
            allowTab: true,
            callback: function(b) {
                isSnapping = b;
                freeTransform.setSnapping(isSnapping);
            },
            css: {
                display: "inline-block",
                marginLeft: "10px"
            }
        });
        const checkboxWrapper = (0, _bb.BB).el({});
        checkboxWrapper.append(constrainCheckbox.getElement(), snappingCheckbox.getElement());
        div.appendChild((0, _bb.BB).el({
            css: {
                clear: "both",
                height: "10px"
            }
        }));
        const bottomRow = (0, _bb.BB).el({
            parent: div,
            css: {
                display: "flex",
                justifyContent: "space-between"
            }
        });
        let algorithmSelect = new (0, _select.Select)({
            isFocusable: true,
            optionArr: [
                [
                    "smooth",
                    (0, _language.LANG)("algorithm-smooth")
                ],
                [
                    "pixelated",
                    (0, _language.LANG)("algorithm-pixelated")
                ]
            ],
            initValue: "smooth",
            title: (0, _language.LANG)("scaling-algorithm"),
            onChange: function() {
                updatePreview(true);
            }
        });
        bottomRow.append(checkboxWrapper, algorithmSelect.getElement());
        let previewWrapper = document.createElement("div");
        previewWrapper.oncontextmenu = function() {
            return false;
        };
        (0, _bb.BB).css(previewWrapper, {
            width: isSmall ? "340px" : "540px",
            marginLeft: "-20px",
            height: isSmall ? "260px" : "300px",
            backgroundColor: "#9e9e9e",
            marginTop: "10px",
            boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
            overflow: "hidden",
            position: "relative",
            userSelect: "none",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            colorScheme: "only light"
        });
        let previewLayerArr = [];
        for(let i = 0; i < layers.length; i++){
            let canvas;
            if (i === selectedLayerIndex) {
                canvas = (0, _bb.BB).canvas(parseInt("" + w), parseInt("" + h));
                let ctx = canvas.getContext("2d");
                ctx.drawImage(layers[i].context.canvas, 0, 0, canvas.width, canvas.height);
            } else canvas = layers[i].context.canvas;
            previewLayerArr.push({
                image: canvas,
                opacity: layers[i].opacity,
                mixModeStr: layers[i].mixModeStr
            });
        }
        let klCanvasPreview = new (0, _canvasPreview.KlCanvasPreview)({
            width: parseInt("" + displayW),
            height: parseInt("" + displayH),
            layers: previewLayerArr
        });
        let previewInnerWrapper = (0, _bb.BB).el({
            css: {
                position: "relative",
                boxShadow: "0 0 5px rgba(0,0,0,0.5)",
                width: parseInt("" + displayW) + "px",
                height: parseInt("" + displayH) + "px"
            }
        });
        previewInnerWrapper.appendChild(klCanvasPreview.getElement());
        previewWrapper.appendChild(previewInnerWrapper);
        let lastDrawnTransformStr;
        function updatePreview(doForce = false) {
            if (!freeTransform) return;
            let transform = freeTransform.getTransform();
            if (JSON.stringify(transform) === lastDrawnTransformStr && !doForce) return;
            lastDrawnTransformStr = JSON.stringify(transform);
            if (displayPreviewFactor < 1) {
                transform.x *= displayPreviewFactor;
                transform.y *= displayPreviewFactor;
                transform.width *= displayPreviewFactor;
                transform.height *= displayPreviewFactor;
            }
            let transformLayerCanvas = previewLayerArr[selectedLayerIndex].image;
            let ctx = transformLayerCanvas.getContext("2d");
            ctx.save();
            ctx.clearRect(0, 0, transformLayerCanvas.width, transformLayerCanvas.height);
            (0, _bb.BB).drawTransformedImageWithBounds(ctx, layers[selectedLayerIndex].context.canvas, transform, boundsObj, algorithmSelect.getValue() === "pixelated" || (0, _bb.BB).testShouldPixelate(transform, transform.width / initTransform.width, transform.height / initTransform.height));
            ctx.restore();
            klCanvasPreview.render();
        }
        freeTransform = new (0, _freeTransform.FreeTransform)({
            x: initTransform.x,
            y: initTransform.y,
            width: initTransform.width,
            height: initTransform.height,
            angleDeg: initTransform.angleDeg,
            isConstrained: true,
            snapX: [
                0,
                context.canvas.width
            ],
            snapY: [
                0,
                context.canvas.height
            ],
            callback: function(t) {
                inputX.value = "" + Math.round(t.x - initTransform.x);
                inputY.value = "" + Math.round(t.y - initTransform.y);
                inputR.value = "" + Math.round(t.angleDeg);
                updatePreview();
            },
            scale: displayPreviewFactor
        });
        (0, _bb.BB).css(freeTransform.getElement(), {
            position: "absolute",
            left: "0",
            top: "0"
        });
        previewInnerWrapper.appendChild(freeTransform.getElement());
        function onInputsChanged() {
            freeTransform.setPos({
                x: parseInt(inputX.value) + initTransform.x,
                y: parseInt(inputY.value) + initTransform.y
            });
            freeTransform.setAngleDeg(parseInt(inputR.value));
            updatePreview();
        }
        updatePreview();
        div.appendChild(previewWrapper);
        result.destroy = ()=>{
            keyListener.destroy();
            freeTransform.destroy();
            constrainCheckbox.destroy();
            snappingCheckbox.destroy();
            (0, _bb.BB).destroyEl(flipXBtn);
            (0, _bb.BB).destroyEl(flipYBtn);
            (0, _bb.BB).destroyEl(scaleRotLeftBtn);
            (0, _bb.BB).destroyEl(scaleRotRightBtn);
            (0, _bb.BB).destroyEl(scaleDoubleBtn);
            (0, _bb.BB).destroyEl(scaleHalfBtn);
            (0, _bb.BB).destroyEl(centerBtn);
        };
        result.getInput = function() {
            const transform = freeTransform.getTransform();
            let input = {
                transform,
                bounds: boundsObj,
                isPixelated: algorithmSelect.getValue() === "pixelated" || (0, _bb.BB).testShouldPixelate(transform, transform.width / initTransform.width, transform.height / initTransform.height)
            };
            result.destroy();
            return JSON.parse(JSON.stringify(input));
        };
        return result;
    },
    apply (params) {
        const context = params.context;
        const history = params.history;
        if (!context || !history) return false;
        history.pause(true);
        const input = params.input;
        let copyCanvas = (0, _bb.BB).copyCanvas(context.canvas);
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        (0, _bb.BB).drawTransformedImageWithBounds(context, copyCanvas, input.transform, input.bounds, input.isPixelated);
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "transform"
            ],
            action: "apply",
            params: [
                {
                    input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","../ui/base-components/checkbox":"kPAwM","../canvas-ui/canvas-preview":"gRZnS","../ui/components/free-transform":"izcGJ","../ui/base-components/select":"7mzRU","../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5iOmO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterBlur", ()=>filterBlur);
var _bb = require("../../bb/bb");
var _klSlider = require("../ui/base-components/kl-slider");
var _filtersConsts = require("./filters-consts");
var _canvasPreview = require("../canvas-ui/canvas-preview");
var _sharedGlFx = require("./shared-gl-fx");
var _language = require("../../language/language");
const filterBlur = {
    getDialog (params) {
        let klCanvas = params.klCanvas;
        let context = params.context;
        if (!klCanvas || !context) return false;
        let layers = klCanvas.getLayers();
        let selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        let fit = (0, _bb.BB).fitInto(context.canvas.width, context.canvas.height, 280, 200, 1);
        let displayW = parseInt("" + fit.width), displayH = parseInt("" + fit.height);
        let w = Math.min(displayW, context.canvas.width);
        let h = Math.min(displayH, context.canvas.height);
        let tempCanvas = (0, _bb.BB).canvas(w, h);
        {
            const ctx = tempCanvas.getContext("2d");
            ctx.save();
            if (w > context.canvas.width) ctx.imageSmoothingEnabled = false;
            ctx.drawImage(context.canvas, 0, 0, w, h);
            ctx.restore();
        }
        let previewFactor = w / context.canvas.width;
        let div = document.createElement("div");
        let result = {
            element: div
        };
        function finishInit() {
            let radius = 10;
            div.innerHTML = (0, _language.LANG)("filter-triangle-blur-description") + "<br/><br/>";
            let glCanvas = (0, _sharedGlFx.getSharedFx)();
            if (!glCanvas) return; // todo throw?
            let texture = glCanvas.texture(tempCanvas);
            glCanvas.draw(texture).update(); // update glCanvas size
            let radiusSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("radius"),
                width: 300,
                height: 30,
                min: 1,
                max: 200,
                value: radius,
                eventResMs: (0, _filtersConsts.eventResMs),
                onChange: function(val) {
                    radius = val;
                    glCanvas.draw(texture).triangleBlur(radius * previewFactor).update();
                    klCanvasPreview.render();
                }
            });
            div.appendChild(radiusSlider.getElement());
            let previewWrapper = document.createElement("div");
            (0, _bb.BB).css(previewWrapper, {
                width: "340px",
                marginLeft: "-20px",
                height: "220px",
                backgroundColor: "#9e9e9e",
                marginTop: "10px",
                boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
                overflow: "hidden",
                position: "relative",
                userSelect: "none",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                colorScheme: "only light"
            });
            let previewLayerArr = [];
            for(let i = 0; i < layers.length; i++)previewLayerArr.push({
                image: i === selectedLayerIndex ? glCanvas : layers[i].context.canvas,
                opacity: layers[i].opacity,
                mixModeStr: layers[i].mixModeStr
            });
            let klCanvasPreview = new (0, _canvasPreview.KlCanvasPreview)({
                width: parseInt("" + displayW),
                height: parseInt("" + displayH),
                layers: previewLayerArr
            });
            let previewInnerWrapper = (0, _bb.BB).el({
                css: {
                    position: "relative",
                    boxShadow: "0 0 5px rgba(0,0,0,0.5)",
                    width: parseInt("" + displayW) + "px",
                    height: parseInt("" + displayH) + "px"
                }
            });
            previewInnerWrapper.appendChild(klCanvasPreview.getElement());
            previewWrapper.appendChild(previewInnerWrapper);
            div.appendChild(previewWrapper);
            try {
                glCanvas.draw(texture).triangleBlur(radius * previewFactor).update();
                klCanvasPreview.render();
            } catch (e) {
                div.errorCallback(e);
            }
            result.destroy = ()=>{
                texture.destroy();
                radiusSlider.destroy();
            };
            result.getInput = function() {
                result.destroy();
                return {
                    radius: radius
                };
            };
        }
        setTimeout(finishInit, 1);
        return result;
    },
    apply (params) {
        let context = params.context;
        let history = params.history;
        let radius = params.input.radius;
        if (!context || !radius || !history) return false;
        history.pause(true);
        let glCanvas = (0, _sharedGlFx.getSharedFx)();
        if (!glCanvas) return false; // todo more specific error?
        let texture = glCanvas.texture(context.canvas);
        glCanvas.draw(texture).triangleBlur(radius).update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(glCanvas, 0, 0);
        texture.destroy();
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "blur"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","../ui/base-components/kl-slider":"6YGce","./filters-consts":"7Xzbl","../canvas-ui/canvas-preview":"gRZnS","./shared-gl-fx":"4bJZi","../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1fHVB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterUnsharpMask", ()=>filterUnsharpMask);
var _bb = require("../../bb/bb");
var _filtersConsts = require("./filters-consts");
var _klSlider = require("../ui/base-components/kl-slider");
var _canvasPreview = require("../canvas-ui/canvas-preview");
var _sharedGlFx = require("./shared-gl-fx");
var _language = require("../../language/language");
const filterUnsharpMask = {
    getDialog (params) {
        let context = params.context;
        let klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        let layers = klCanvas.getLayers();
        let selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        let fit = (0, _bb.BB).fitInto(context.canvas.width, context.canvas.height, 280, 200, 1);
        let displayW = parseInt("" + fit.width), displayH = parseInt("" + fit.height);
        let w = Math.min(displayW, context.canvas.width);
        let h = Math.min(displayH, context.canvas.height);
        let tempCanvas = (0, _bb.BB).canvas(w, h);
        {
            const ctx = tempCanvas.getContext("2d");
            ctx.save();
            if (w > context.canvas.width) ctx.imageSmoothingEnabled = false;
            ctx.drawImage(context.canvas, 0, 0, w, h);
            ctx.restore();
        }
        let previewFactor = w / context.canvas.width;
        let div = document.createElement("div");
        let result = {
            element: div
        };
        function finishInit() {
            let radius = 2, strength = 0.51;
            div.innerHTML = (0, _language.LANG)("filter-unsharp-mask-description") + "<br/><br/>";
            let glCanvas = (0, _sharedGlFx.getSharedFx)();
            if (!glCanvas) return; // todo throw?
            let texture = glCanvas.texture(tempCanvas);
            glCanvas.draw(texture).update(); // update glCanvas size
            let radiusSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("radius"),
                width: 300,
                height: 30,
                min: 0,
                max: 200,
                value: 2,
                eventResMs: (0, _filtersConsts.eventResMs),
                onChange: function(val) {
                    radius = val;
                    glCanvas.draw(texture).unsharpMask(radius * previewFactor, strength).update();
                    klCanvasPreview.render();
                },
                curve: [
                    [
                        0,
                        0
                    ],
                    [
                        0.1,
                        2
                    ],
                    [
                        0.5,
                        50
                    ],
                    [
                        1,
                        200
                    ]
                ]
            });
            let strengthSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("filter-unsharp-mask-strength"),
                width: 300,
                height: 30,
                min: 0,
                max: 50,
                value: 5.1,
                eventResMs: (0, _filtersConsts.eventResMs),
                onChange: function(val) {
                    strength = val / 10;
                    glCanvas.draw(texture).unsharpMask(radius * previewFactor, strength).update();
                    klCanvasPreview.render();
                },
                curve: [
                    [
                        0,
                        0
                    ],
                    [
                        0.1,
                        2
                    ],
                    [
                        0.5,
                        10
                    ],
                    [
                        1,
                        50
                    ]
                ]
            });
            radiusSlider.getElement().style.marginBottom = "10px";
            div.appendChild(radiusSlider.getElement());
            div.appendChild(strengthSlider.getElement());
            let previewWrapper = document.createElement("div");
            (0, _bb.BB).css(previewWrapper, {
                width: "340px",
                marginLeft: "-20px",
                height: "220px",
                backgroundColor: "#9e9e9e",
                marginTop: "10px",
                boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
                overflow: "hidden",
                position: "relative",
                userSelect: "none",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                colorScheme: "only light"
            });
            let previewLayerArr = [];
            for(let i = 0; i < layers.length; i++)previewLayerArr.push({
                image: i === selectedLayerIndex ? glCanvas : layers[i].context.canvas,
                opacity: layers[i].opacity,
                mixModeStr: layers[i].mixModeStr
            });
            let klCanvasPreview = new (0, _canvasPreview.KlCanvasPreview)({
                width: parseInt("" + displayW),
                height: parseInt("" + displayH),
                layers: previewLayerArr
            });
            let previewInnerWrapper = (0, _bb.BB).el({
                css: {
                    position: "relative",
                    boxShadow: "0 0 5px rgba(0,0,0,0.5)",
                    width: parseInt("" + displayW) + "px",
                    height: parseInt("" + displayH) + "px"
                }
            });
            previewInnerWrapper.appendChild(klCanvasPreview.getElement());
            previewWrapper.appendChild(previewInnerWrapper);
            div.appendChild(previewWrapper);
            try {
                glCanvas.draw(texture).unsharpMask(radius * previewFactor, strength).update();
                klCanvasPreview.render();
            } catch (e) {
                div.errorCallback(e);
            }
            result.destroy = ()=>{
                radiusSlider.destroy();
                strengthSlider.destroy();
                texture.destroy();
            };
            result.getInput = function() {
                result.destroy();
                return {
                    radius: radius,
                    strength: strength
                };
            };
        }
        setTimeout(finishInit, 1);
        return result;
    },
    apply (params) {
        let context = params.context;
        let history = params.history;
        let radius = params.input.radius;
        let strength = params.input.strength;
        if (!context || radius === null || strength === null || !history) return false;
        history.pause(true);
        let glCanvas = (0, _sharedGlFx.getSharedFx)();
        if (!glCanvas) return false; // todo more specific error?
        let texture = glCanvas.texture(context.canvas);
        glCanvas.draw(texture).unsharpMask(radius, strength).update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(glCanvas, 0, 0);
        texture.destroy();
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "unsharpMask"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","./filters-consts":"7Xzbl","../ui/base-components/kl-slider":"6YGce","../canvas-ui/canvas-preview":"gRZnS","./shared-gl-fx":"4bJZi","../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iGpbg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterToAlpha", ()=>filterToAlpha);
var _bb = require("../../bb/bb");
var _options = require("../ui/base-components/options");
var _colorOptions = require("../ui/base-components/color-options");
var _canvasPreview = require("../canvas-ui/canvas-preview");
var _sharedGlFx = require("./shared-gl-fx");
var _language = require("../../language/language");
const filterToAlpha = {
    getDialog (params) {
        let context = params.context;
        let klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        let layers = klCanvas.getLayers();
        let selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        let fit = (0, _bb.BB).fitInto(context.canvas.width, context.canvas.height, 280, 200, 1);
        let w = parseInt("" + fit.width), h = parseInt("" + fit.height);
        let tempCanvas = (0, _bb.BB).canvas(w, h);
        {
            const ctx = tempCanvas.getContext("2d");
            ctx.save();
            if (tempCanvas.width > context.canvas.width) ctx.imageSmoothingEnabled = false;
            ctx.drawImage(context.canvas, 0, 0, w, h);
            ctx.restore();
        }
        let div = document.createElement("div");
        let result = {
            element: div
        };
        function finishInit() {
            let radius = 2, strength = 0.51;
            div.appendChild((0, _bb.BB).el({
                content: (0, _language.LANG)("filter-to-alpha-description"),
                css: {
                    marginBottom: "5px"
                }
            }));
            let glCanvas = (0, _sharedGlFx.getSharedFx)();
            if (!glCanvas) return; // todo throw?
            let texture = glCanvas.texture(tempCanvas);
            glCanvas.draw(texture).update(); // update glCanvas size
            function updatePreview() {
                glCanvas.draw(texture).toAlpha(sourceId === "inverted-luminance", selectedRgbaObj).update();
                klCanvasPreview.render();
            }
            // source
            let sourceId = "inverted-luminance";
            let sourceOptions = new (0, _options.Options)({
                optionArr: [
                    {
                        id: "inverted-luminance",
                        label: (0, _language.LANG)("filter-to-alpha-inverted-lum")
                    },
                    {
                        id: "luminance",
                        label: (0, _language.LANG)("filter-to-alpha-lum")
                    }
                ],
                initialId: sourceId,
                onChange: function(id) {
                    sourceId = id;
                    updatePreview();
                }
            });
            div.appendChild(sourceOptions.getElement());
            // color
            let selectedRgbaObj = {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            };
            let colorOptionsArr = [
                null,
                {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 1
                },
                {
                    r: 255,
                    g: 255,
                    b: 255,
                    a: 1
                }
            ];
            colorOptionsArr.push({
                r: params.currentColorRgb.r,
                g: params.currentColorRgb.g,
                b: params.currentColorRgb.b,
                a: 1
            });
            colorOptionsArr.push({
                r: params.secondaryColorRgb.r,
                g: params.secondaryColorRgb.g,
                b: params.secondaryColorRgb.b,
                a: 1
            });
            let colorOptions = new (0, _colorOptions.ColorOptions)({
                label: (0, _language.LANG)("filter-to-alpha-replace"),
                colorArr: colorOptionsArr,
                initialIndex: 1,
                onChange: function(rgbaObj) {
                    selectedRgbaObj = rgbaObj;
                    updatePreview();
                }
            });
            colorOptions.getElement().style.marginTop = "10px";
            div.appendChild(colorOptions.getElement());
            let previewWrapper = document.createElement("div");
            (0, _bb.BB).css(previewWrapper, {
                width: "340px",
                marginLeft: "-20px",
                height: "220px",
                backgroundColor: "#9e9e9e",
                marginTop: "10px",
                boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
                overflow: "hidden",
                position: "relative",
                userSelect: "none",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                colorScheme: "only light"
            });
            let previewLayerArr = [];
            for(let i = 0; i < layers.length; i++)previewLayerArr.push({
                image: i === selectedLayerIndex ? glCanvas : layers[i].context.canvas,
                opacity: layers[i].opacity,
                mixModeStr: layers[i].mixModeStr
            });
            let klCanvasPreview = new (0, _canvasPreview.KlCanvasPreview)({
                width: parseInt("" + w),
                height: parseInt("" + h),
                layers: previewLayerArr
            });
            let previewInnerWrapper = (0, _bb.BB).el({
                css: {
                    position: "relative",
                    boxShadow: "0 0 5px rgba(0,0,0,0.5)",
                    width: parseInt("" + w) + "px",
                    height: parseInt("" + h) + "px"
                }
            });
            previewInnerWrapper.appendChild(klCanvasPreview.getElement());
            previewWrapper.appendChild(previewInnerWrapper);
            div.appendChild(previewWrapper);
            setTimeout(function() {
                try {
                    updatePreview();
                } catch (e) {
                    div.errorCallback(e);
                }
            }, 1);
            result.destroy = ()=>{
                texture.destroy();
                sourceOptions.destroy();
            };
            result.getInput = function() {
                result.destroy();
                return {
                    sourceId: sourceId,
                    selectedRgbaObj: selectedRgbaObj
                };
            };
        }
        setTimeout(finishInit, 1);
        return result;
    },
    apply (params) {
        let context = params.context;
        let history = params.history;
        let sourceId = params.input.sourceId;
        let selectedRgbaObj = params.input.selectedRgbaObj;
        if (!context || !sourceId || !history) return false;
        history.pause(true);
        let glCanvas = (0, _sharedGlFx.getSharedFx)();
        if (!glCanvas) return false; // todo more specific error?
        let texture = glCanvas.texture(context.canvas);
        glCanvas.draw(texture).toAlpha(sourceId === "inverted-luminance", selectedRgbaObj).update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(glCanvas, 0, 0);
        texture.destroy();
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "toAlpha"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","../ui/base-components/options":"huqRY","../ui/base-components/color-options":"e85vi","../canvas-ui/canvas-preview":"gRZnS","./shared-gl-fx":"4bJZi","../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bN7Vm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterGrid", ()=>filterGrid);
var _bb = require("../../bb/bb");
var _canvasPreview = require("../canvas-ui/canvas-preview");
var _language = require("../../language/language");
var _input = require("../ui/base-components/input");
var _colorOptions = require("../ui/base-components/color-options");
var _drawGrid = require("../image-operations/draw-grid");
const filterGrid = {
    getDialog (params) {
        let context = params.context;
        let klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        let layers = klCanvas.getLayers();
        let selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        let fit = (0, _bb.BB).fitInto(context.canvas.width, context.canvas.height, 280, 200, 1);
        let w = parseInt("" + fit.width), h = parseInt("" + fit.height);
        const renderW = Math.min(w, context.canvas.width);
        const renderH = Math.min(h, context.canvas.height);
        const renderFactor = renderW / context.canvas.width;
        let div = document.createElement("div");
        let result = {
            element: div
        };
        div.innerHTML = (0, _language.LANG)("filter-grid-description") + "<br/><br/>";
        const settingsObj = {
            x: 2,
            y: 2,
            thickness: 2,
            color: "#000",
            opacity: 1
        };
        let line1 = (0, _bb.BB).el({
            parent: div,
            css: {
                display: "flex",
                alignItems: "center"
            }
        });
        let line2 = (0, _bb.BB).el({
            parent: div,
            css: {
                display: "flex",
                alignItems: "center",
                marginTop: "10px"
            }
        });
        const xInput = (0, _input.input)({
            init: 2,
            type: "number",
            min: 1,
            css: {
                width: "75px",
                marginRight: "20px"
            },
            callback: function(v) {
                settingsObj.x = parseFloat(v);
                updatePreview();
            }
        });
        const yInput = (0, _input.input)({
            init: 2,
            type: "number",
            min: 1,
            css: {
                width: "75px",
                marginRight: "20px"
            },
            callback: function(v) {
                settingsObj.y = parseFloat(v);
                updatePreview();
            }
        });
        const thicknessInput = (0, _input.input)({
            init: 2,
            type: "number",
            min: 1,
            css: {
                width: "75px",
                marginRight: "20px"
            },
            callback: function(v) {
                settingsObj.thickness = parseFloat(v);
                updatePreview();
            }
        });
        let selectedRgbaObj = {
            r: 0,
            g: 0,
            b: 0,
            a: 1
        };
        const colorOptionsArr = [
            {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            },
            {
                r: 255,
                g: 255,
                b: 255,
                a: 1
            }, 
        ];
        colorOptionsArr.push({
            r: params.currentColorRgb.r,
            g: params.currentColorRgb.g,
            b: params.currentColorRgb.b,
            a: 1
        });
        colorOptionsArr.push({
            r: params.secondaryColorRgb.r,
            g: params.secondaryColorRgb.g,
            b: params.secondaryColorRgb.b,
            a: 1
        });
        settingsObj.color = (0, _bb.BB).ColorConverter.toRgbStr(selectedRgbaObj);
        const colorOptions = new (0, _colorOptions.ColorOptions)({
            label: (0, _language.LANG)("shape-stroke"),
            colorArr: colorOptionsArr,
            onChange: function(rgbaObj) {
                selectedRgbaObj = rgbaObj;
                settingsObj.color = (0, _bb.BB).ColorConverter.toRgbStr(selectedRgbaObj);
                updatePreview();
            }
        });
        const labelStyle = {
            display: "inline-block",
            marginRight: "5px"
        };
        line1.append((0, _bb.BB).el({
            content: "X:",
            css: labelStyle
        }), xInput, (0, _bb.BB).el({
            content: "Y:",
            css: labelStyle
        }), yInput);
        line2.append((0, _bb.BB).el({
            content: (0, _language.LANG)("shape-line-width") + ":",
            css: labelStyle
        }), thicknessInput, (0, _bb.BB).el({
            css: {
                flexGrow: "1"
            }
        }), colorOptions.getElement());
        let previewWrapper = document.createElement("div");
        (0, _bb.BB).css(previewWrapper, {
            width: "340px",
            marginLeft: "-20px",
            height: "220px",
            backgroundColor: "#9e9e9e",
            marginTop: "10px",
            boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
            overflow: "hidden",
            position: "relative",
            userSelect: "none",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            colorScheme: "only light"
        });
        let previewLayer = {
            image: (0, _bb.BB).canvas(renderW, renderH),
            opacity: layers[selectedLayerIndex].opacity,
            mixModeStr: layers[selectedLayerIndex].mixModeStr
        };
        let klCanvasPreview = new (0, _canvasPreview.KlCanvasPreview)({
            width: Math.round(w),
            height: Math.round(h),
            layers: layers.map((item, i)=>{
                if (i === selectedLayerIndex) return previewLayer;
                else return {
                    image: item.context.canvas,
                    opacity: item.opacity,
                    mixModeStr: item.mixModeStr
                };
            })
        });
        let previewInnerWrapper = (0, _bb.BB).el({
            css: {
                position: "relative",
                boxShadow: "0 0 5px rgba(0,0,0,0.5)",
                width: parseInt("" + w) + "px",
                height: parseInt("" + h) + "px"
            }
        });
        previewInnerWrapper.appendChild(klCanvasPreview.getElement());
        previewWrapper.appendChild(previewInnerWrapper);
        function updatePreview() {
            let ctx = previewLayer.image.getContext("2d");
            ctx.save();
            ctx.clearRect(0, 0, renderW, renderH);
            ctx.drawImage(context.canvas, 0, 0, renderW, renderH);
            (0, _drawGrid.drawGrid)(ctx, settingsObj.x, settingsObj.y, Math.max(settingsObj.thickness * renderFactor, 1), settingsObj.color, settingsObj.opacity);
            ctx.restore();
            klCanvasPreview.render();
        }
        setTimeout(updatePreview, 0);
        div.appendChild(previewWrapper);
        result.destroy = ()=>{};
        result.getInput = function() {
            result.destroy();
            return (0, _bb.BB).copyObj(settingsObj);
        };
        return result;
    },
    apply (params) {
        let context = params.context;
        let klCanvas = params.klCanvas;
        let history = params.history;
        if (!context || !klCanvas || !history) return false;
        history.pause(true);
        (0, _drawGrid.drawGrid)(context, params.input.x, params.input.y, params.input.thickness, params.input.color, params.input.opacity);
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "grid"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","../canvas-ui/canvas-preview":"gRZnS","../../language/language":"iiYGN","../ui/base-components/input":"bsfIT","../ui/base-components/color-options":"e85vi","../image-operations/draw-grid":"iJ0f6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iJ0f6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// ideas: padding, gutter, other shapes
parcelHelpers.export(exports, "drawGrid", ()=>drawGrid);
function drawGrid(ctx, cellsX, cellsY, thickness, color, opacity) {
    ctx.save();
    const w = ctx.canvas.width;
    const h = ctx.canvas.height;
    thickness = Math.round(thickness);
    const thickIsRound = thickness % 2 === 0;
    ctx.beginPath();
    ctx.lineWidth = thickness;
    ctx.strokeStyle = color;
    ctx.globalAlpha = opacity;
    for(let i = 0; i < cellsX - 1; i++){
        const cw = w / cellsX;
        let pos = cw * (i + 1);
        if (thickIsRound) pos = Math.round(pos);
        else pos = Math.round(pos + 0.5) - 0.5;
        ctx.moveTo(pos, 0);
        ctx.lineTo(pos, h);
    }
    for(let i1 = 0; i1 < cellsY - 1; i1++){
        const ch = h / cellsY;
        let pos1 = ch * (i1 + 1);
        if (thickIsRound) pos1 = Math.round(pos1);
        else pos1 = Math.round(pos1 + 0.5) - 0.5;
        ctx.moveTo(0, pos1);
        ctx.lineTo(w, pos1);
    }
    ctx.stroke();
    ctx.restore();
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eLTh7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterNoise", ()=>filterNoise);
var _bb = require("../../bb/bb");
var _canvasPreview = require("../canvas-ui/canvas-preview");
var _language = require("../../language/language");
var _klSlider = require("../ui/base-components/kl-slider");
var _sharedGlFx = require("./shared-gl-fx");
var _options = require("../ui/base-components/options");
var _filtersConsts = require("./filters-consts");
var _select = require("../ui/base-components/select");
var _translateBlending = require("../canvas/translate-blending");
var _kl = require("../kl");
var _color = require("../../bb/color/color");
var _checkbox = require("../ui/base-components/checkbox");
const presetArr = [
    // each pixel random value
    {
        type: 0,
        scaleX: 1,
        scaleY: 1,
        offsetX: 0,
        offsetY: 0,
        octaves: 1,
        samples: 1,
        peaks: 0,
        brightness: 0,
        contrast: 0,
        isReversed: true
    },
    // cloud
    {
        type: 1,
        scaleX: 166,
        scaleY: 164,
        offsetX: 105,
        offsetY: 30,
        octaves: 6,
        samples: 1,
        peaks: 0,
        brightness: 0.055,
        contrast: 0.23,
        isReversed: true
    },
    // thin lines
    {
        type: 1,
        scaleX: 235,
        scaleY: 190,
        offsetX: 3227,
        offsetY: 2156,
        octaves: 4,
        samples: 16,
        peaks: 22,
        brightness: -0.375,
        contrast: 1,
        isReversed: false
    },
    // soft large simplex, only 1 octave
    {
        type: 1,
        scaleX: 40,
        scaleY: 40,
        offsetX: 0,
        offsetY: 0,
        octaves: 1,
        samples: 1,
        peaks: 0,
        brightness: 0,
        contrast: 0,
        isReversed: false
    },
    // two value large pixels
    {
        type: 0,
        scaleX: 26,
        scaleY: 26,
        offsetX: 557,
        offsetY: 365,
        octaves: 1,
        samples: 1,
        peaks: 0,
        brightness: 0.02,
        contrast: 1,
        isReversed: true
    },
    // zebra
    {
        type: 1,
        scaleX: 1500,
        scaleY: 1500,
        offsetX: 745,
        offsetY: 2871,
        octaves: 5,
        samples: 16,
        peaks: 156.02,
        brightness: 0.03,
        contrast: 1,
        isReversed: true
    },
    // sparse dots / stars
    {
        type: 1,
        scaleX: 11,
        scaleY: 11,
        offsetX: 2940,
        offsetY: 2045,
        octaves: 1,
        samples: 16,
        peaks: 1,
        brightness: -0.045,
        contrast: 1,
        isReversed: true
    },
    // pseudo marble
    {
        type: 2,
        scaleX: 74,
        scaleY: 74,
        offsetX: 4816,
        offsetY: 1304,
        octaves: 3,
        samples: 1,
        peaks: 2.78,
        brightness: 0,
        contrast: 0,
        isReversed: false
    }, 
];
function drawNoise(glCanvas, settings) {
    glCanvas.noise(settings.seed ? settings.seed : 0, settings.type, [
        settings.scaleX,
        settings.scaleY
    ], [
        glCanvas.width / 2,
        glCanvas.height / 2
    ], settings.octaves, settings.samples, settings.peaks, settings.brightness, settings.contrast, settings.isReversed, settings.colA, settings.colB, settings.channels ? settings.channels : "rgb").update();
}
const filterNoise = {
    getDialog (params) {
        let context = params.context;
        let klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        let layers = klCanvas.getLayers();
        let selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        let fit = (0, _bb.BB).fitInto(context.canvas.width, context.canvas.height, 280, 200, 1);
        let w = parseInt("" + fit.width), h = parseInt("" + fit.height);
        const renderW = Math.min(w, context.canvas.width);
        const renderH = Math.min(h, context.canvas.height);
        const renderFactor = renderW / context.canvas.width;
        let glCanvas = (0, _sharedGlFx.getSharedFx)();
        if (!glCanvas) return; // todo throw?
        let texture;
        const thumbImgArr = [];
        const thumbSize = 32;
        {
            const canvas = (0, _bb.BB).canvas(thumbSize, thumbSize);
            const ctx = canvas.getContext("2d");
            texture = glCanvas.texture(canvas);
            glCanvas.draw(texture).update(); // update glCanvas size
            texture.destroy();
            presetArr.forEach((preset, index)=>{
                const thumbImg = new Image();
                const presetCopy = (0, _bb.BB).copyObj(preset);
                presetCopy.scaleX /= 10;
                presetCopy.scaleY /= 10;
                drawNoise(glCanvas, presetCopy);
                ctx.drawImage(glCanvas, 0, 0);
                thumbImg.src = canvas.toDataURL("image/png");
                thumbImgArr.push(thumbImg);
            });
        }
        let tempCanvas = (0, _bb.BB).canvas(renderW, renderH);
        texture = glCanvas.texture(tempCanvas);
        glCanvas.draw(texture).update(); // update glCanvas size
        tempCanvas = null;
        let div = document.createElement("div");
        let result = {
            element: div
        };
        div.innerHTML = (0, _language.LANG)("filter-noise-description") + "<br/><br/>";
        const settingsObj = {
            seed: Math.random() * 300,
            presetIndex: 0,
            scale: 50,
            opacity: 0.5,
            isReversed: false,
            channels: "rgb",
            mixModeStr: "source-over",
            colA: {
                r: 0,
                g: 0,
                b: 0
            },
            colB: {
                r: 255,
                g: 255,
                b: 255
            }
        };
        const presetOptions = new (0, _options.Options)({
            optionArr: thumbImgArr.map((img, index)=>{
                (0, _bb.BB).css(img, {
                    margin: "1px",
                    borderRadius: "3px",
                    transition: "all 0.1s ease-in-out"
                });
                return {
                    id: "" + index,
                    label: img
                };
            }),
            initialId: "0",
            onChange: (id)=>{
                settingsObj.presetIndex = Number(id);
                updatePreview();
            }
        });
        presetOptions.getElement().style.marginBottom = "10px";
        div.append(presetOptions.getElement());
        const scaleSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)("filter-noise-scale"),
            width: 300,
            height: 30,
            min: 1,
            max: 1000,
            value: settingsObj.scale,
            eventResMs: (0, _filtersConsts.eventResMs),
            curve: (0, _bb.BB).quadraticSplineInput(1, 1000, 0.1),
            onChange: (value)=>{
                settingsObj.scale = value;
                updatePreview();
            }
        });
        scaleSlider.getElement().style.marginBottom = "10px";
        const opacitySlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)("opacity"),
            width: 300,
            height: 30,
            min: 0.01,
            max: 1,
            value: settingsObj.opacity,
            eventResMs: (0, _filtersConsts.eventResMs),
            toValue: (displayValue)=>displayValue / 100,
            toDisplayValue: (value)=>value * 100,
            onChange: (value)=>{
                settingsObj.opacity = value;
                updatePreview();
            }
        });
        opacitySlider.getElement().style.marginBottom = "10px";
        const row1El = (0, _bb.BB).el({
            css: {
                display: "flex",
                alignItems: "center",
                marginBottom: "10px"
            }
        });
        const row2El = (0, _bb.BB).el({
            css: {
                display: "flex"
            }
        });
        const channelsOptions = new (0, _options.Options)({
            optionArr: [
                {
                    id: "rgb",
                    label: "RGB"
                },
                {
                    id: "alpha",
                    label: (0, _language.LANG)("filter-noise-alpha")
                }, 
            ],
            initialId: "rgb",
            onChange: (id)=>{
                settingsObj.channels = id;
                if (id === "rgb") row2El.style.visibility = "";
                else row2El.style.visibility = "hidden";
                updatePreview();
            }
        });
        const reverseToggle = new (0, _checkbox.Checkbox)({
            label: (0, _language.LANG)("reverse"),
            callback: (val)=>{
                settingsObj.isReversed = val;
                updatePreview();
            },
            allowTab: true
        });
        const blendSelect = new (0, _select.Select)({
            isFocusable: true,
            optionArr: [
                "source-over",
                null,
                "darken",
                "multiply",
                "color-burn",
                null,
                "lighten",
                "screen",
                "color-dodge",
                null,
                "overlay",
                "soft-light",
                "hard-light",
                null,
                "difference",
                "exclusion",
                null,
                "hue",
                "saturation",
                "color",
                "luminosity", 
            ].map((item)=>{
                return item ? [
                    item,
                    (0, _translateBlending.translateBlending)(item)
                ] : null;
            }),
            initValue: settingsObj.mixModeStr,
            onChange: (val)=>{
                settingsObj.mixModeStr = val;
                updatePreview();
            }
        });
        blendSelect.getElement().title = (0, _language.LANG)("layers-blending");
        const colorWrapper = (0, _bb.BB).el({
            css: {
                display: "flex"
            }
        });
        const colInputStyle = {
            width: "34px",
            height: "34px",
            marginRight: "5px"
        };
        const colAInput = (0, _kl.KL).input({
            type: "color",
            init: "#" + (0, _color.ColorConverter).toHexString(settingsObj.colA),
            callback: (val)=>{
                settingsObj.colA = (0, _color.ColorConverter).hexToRGB(val);
                updatePreview();
            },
            css: colInputStyle
        });
        const colBInput = (0, _kl.KL).input({
            type: "color",
            init: "#" + (0, _color.ColorConverter).toHexString(settingsObj.colB),
            callback: (val)=>{
                settingsObj.colB = (0, _color.ColorConverter).hexToRGB(val);
                updatePreview();
            },
            css: colInputStyle
        });
        colorWrapper.append(colAInput, colBInput);
        row1El.append(channelsOptions.getElement(), (0, _bb.BB).el({
            css: {
                flexGrow: "1"
            }
        }), reverseToggle.getElement());
        row2El.append(blendSelect.getElement(), (0, _bb.BB).el({
            css: {
                flexGrow: "1"
            }
        }), colorWrapper);
        div.append(scaleSlider.getElement(), opacitySlider.getElement(), row1El, row2El);
        let previewWrapper = document.createElement("div");
        (0, _bb.BB).css(previewWrapper, {
            width: "340px",
            marginLeft: "-20px",
            height: "220px",
            backgroundColor: "#9e9e9e",
            marginTop: "10px",
            boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
            overflow: "hidden",
            position: "relative",
            userSelect: "none",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            colorScheme: "only light"
        });
        let previewLayer = {
            image: (0, _bb.BB).canvas(renderW, renderH),
            opacity: layers[selectedLayerIndex].opacity,
            mixModeStr: layers[selectedLayerIndex].mixModeStr
        };
        let klCanvasPreview = new (0, _canvasPreview.KlCanvasPreview)({
            width: Math.round(w),
            height: Math.round(h),
            layers: layers.map((item, i)=>{
                if (i === selectedLayerIndex) return previewLayer;
                else return {
                    image: item.context.canvas,
                    opacity: item.opacity,
                    mixModeStr: item.mixModeStr
                };
            })
        });
        let previewInnerWrapper = (0, _bb.BB).el({
            css: {
                position: "relative",
                boxShadow: "0 0 5px rgba(0,0,0,0.5)",
                width: parseInt("" + w) + "px",
                height: parseInt("" + h) + "px"
            }
        });
        previewInnerWrapper.appendChild(klCanvasPreview.getElement());
        previewWrapper.appendChild(previewInnerWrapper);
        function updatePreview() {
            let ctx = previewLayer.image.getContext("2d");
            ctx.save();
            ctx.clearRect(0, 0, renderW, renderH);
            ctx.drawImage(context.canvas, 0, 0, renderW, renderH);
            ctx.globalAlpha = settingsObj.opacity;
            const presetCopy = (0, _bb.BB).copyObj(presetArr[settingsObj.presetIndex]);
            presetCopy.seed = settingsObj.seed;
            presetCopy.scaleX = presetCopy.scaleX * settingsObj.scale / 50 * renderFactor;
            presetCopy.scaleY = presetCopy.scaleY * settingsObj.scale / 50 * renderFactor;
            presetCopy.colA = settingsObj.colA;
            presetCopy.colB = settingsObj.colB;
            presetCopy.isReversed = settingsObj.isReversed ? !presetCopy.isReversed : presetCopy.isReversed;
            presetCopy.channels = settingsObj.channels;
            drawNoise(glCanvas, presetCopy);
            if (settingsObj.channels === "alpha") ctx.globalCompositeOperation = "destination-out";
            else ctx.globalCompositeOperation = settingsObj.mixModeStr;
            ctx.drawImage(glCanvas, 0, 0);
            ctx.restore();
            klCanvasPreview.render();
        }
        setTimeout(updatePreview, 0);
        div.appendChild(previewWrapper);
        result.destroy = ()=>{
            presetOptions.destroy();
            scaleSlider.destroy();
            opacitySlider.destroy();
            reverseToggle.destroy();
            channelsOptions.destroy();
            texture.destroy();
            blendSelect.destroy();
        };
        result.getInput = function() {
            result.destroy();
            return (0, _bb.BB).copyObj(settingsObj);
        };
        return result;
    },
    apply (params) {
        let context = params.context;
        let klCanvas = params.klCanvas;
        let history = params.history;
        if (!context || !klCanvas || !history) return false;
        history.pause(true);
        let glCanvas = (0, _sharedGlFx.getSharedFx)();
        if (!glCanvas) return false; // todo more specific error?
        let texture = glCanvas.texture(context.canvas);
        glCanvas.draw(texture).update();
        texture.destroy();
        const input = params.input;
        const presetCopy = (0, _bb.BB).copyObj(presetArr[input.presetIndex]);
        presetCopy.seed = input.seed;
        presetCopy.scaleX = presetCopy.scaleX * input.scale / 50;
        presetCopy.scaleY = presetCopy.scaleY * input.scale / 50;
        presetCopy.colA = input.colA;
        presetCopy.colB = input.colB;
        presetCopy.isReversed = input.isReversed ? !presetCopy.isReversed : presetCopy.isReversed;
        presetCopy.channels = input.channels;
        drawNoise(glCanvas, presetCopy);
        context.save();
        context.globalAlpha = input.opacity;
        if (input.channels === "alpha") context.globalCompositeOperation = "destination-out";
        else context.globalCompositeOperation = input.mixModeStr;
        context.drawImage(glCanvas, 0, 0);
        context.restore();
        history.pause(false);
        history.push({
            tool: [
                "canvas"
            ],
            action: "replaceLayer",
            params: [
                klCanvas.getLayerIndex(context.canvas),
                context.getImageData(0, 0, context.canvas.width, context.canvas.height), 
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","../canvas-ui/canvas-preview":"gRZnS","../../language/language":"iiYGN","../ui/base-components/kl-slider":"6YGce","./shared-gl-fx":"4bJZi","../ui/base-components/options":"huqRY","./filters-consts":"7Xzbl","../ui/base-components/select":"7mzRU","../canvas/translate-blending":"6hHQR","../kl":"8nmWp","../../bb/color/color":"iVNo9","../ui/base-components/checkbox":"kPAwM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ltDe9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterPattern", ()=>filterPattern);
var _bb = require("../../bb/bb");
var _input = require("../ui/base-components/input");
var _klSlider = require("../ui/base-components/kl-slider");
var _language = require("../../language/language");
var _filtersConsts = require("./filters-consts");
var _canvasPreview = require("../canvas-ui/canvas-preview");
var _twoTabs = require("../ui/components/two-tabs");
/**
 * Draws pattern onto context. Pattern generated from context.
 * Can use blending for smoother transition. Will use area outside of bounds for blending.
 *
 * @param context
 * @param settings
 */ function drawPattern(context, settings) {
    // keep bounds in center via offset
    // because blending done towards bottom right
    const blendOffsetX = settings.blend ? Math.round(settings.blend * settings.width / 2) : 0;
    const blendOffsetY = settings.blend ? Math.round(settings.blend * settings.height / 2) : 0;
    const finalPatternCanvas = (0, _bb.BB).canvas(settings.width, settings.height);
    if (settings.blend) {
        // construct pattern via linear blending
        const blendCanvas = (0, _bb.BB).canvas(settings.width * 2, settings.height * 2);
        const blendCtx = blendCanvas.getContext("2d");
        const colTransparent = "#0000";
        const colOpaque = "#000";
        // transfer source to blendCanvas
        blendCtx.drawImage(context.canvas, -settings.x + blendOffsetX, -settings.y + blendOffsetY);
        // --- 1 cross-fade vertical ------------------------
        // erase vertical gradient bottom half
        blendCtx.save();
        let blendGradient = blendCtx.createLinearGradient(0, settings.height, 0, settings.height * 2);
        blendGradient.addColorStop(0, colOpaque);
        blendGradient.addColorStop(settings.blend, colTransparent);
        blendCtx.globalCompositeOperation = "destination-in";
        blendCtx.fillStyle = blendGradient;
        blendCtx.fillRect(0, 0, blendCanvas.width, blendCanvas.height);
        blendCtx.restore();
        // erase vertical gradient top half
        blendCtx.save();
        blendGradient = blendCtx.createLinearGradient(0, 0, 0, settings.height);
        blendGradient.addColorStop(0, colTransparent);
        blendGradient.addColorStop(settings.blend, colOpaque);
        blendCtx.globalCompositeOperation = "destination-in";
        blendCtx.fillStyle = blendGradient;
        blendCtx.fillRect(0, 0, settings.width * 2, settings.height * 2);
        blendCtx.restore();
        // draw bottom half over top half
        blendCtx.save();
        // lighter needed for accurate cross-fade
        blendCtx.globalCompositeOperation = "lighter";
        blendCtx.drawImage(blendCanvas, 0, -settings.height);
        blendCtx.restore();
        // --- 2 cross-fade horizontal ------------------------
        // erase horizontal gradient right half
        blendCtx.save();
        blendGradient = blendCtx.createLinearGradient(settings.width, 0, settings.width * 2, 0);
        blendGradient.addColorStop(0, colOpaque);
        blendGradient.addColorStop(settings.blend, colTransparent);
        blendCtx.globalCompositeOperation = "destination-in";
        blendCtx.fillStyle = blendGradient;
        blendCtx.fillRect(0, 0, blendCanvas.width, blendCanvas.height);
        blendCtx.restore();
        // erase horizontal gradient left half
        blendCtx.save();
        blendGradient = blendCtx.createLinearGradient(0, 0, settings.width, 0);
        blendGradient.addColorStop(0, colTransparent);
        blendGradient.addColorStop(settings.blend, colOpaque);
        blendCtx.globalCompositeOperation = "destination-in";
        blendCtx.fillStyle = blendGradient;
        blendCtx.fillRect(0, 0, settings.width * 2, settings.height * 2);
        blendCtx.restore();
        // draw right half over left half
        blendCtx.save();
        // lighter needed for accurate cross-fade
        blendCtx.globalCompositeOperation = "lighter";
        blendCtx.drawImage(blendCanvas, -settings.width, 0);
        blendCtx.restore();
        // transfer to pattern canvas
        finalPatternCanvas.getContext("2d").drawImage(blendCanvas, 0, 0);
    } else finalPatternCanvas.getContext("2d").drawImage(context.canvas, -settings.x, -settings.y);
    context.save();
    context.clearRect(0, 0, context.canvas.width, context.canvas.height);
    context.translate(settings.offsetX - blendOffsetX, settings.offsetY - blendOffsetY);
    context.fillStyle = context.createPattern(finalPatternCanvas, "repeat");
    context.fillRect(-settings.offsetX + blendOffsetX, -settings.offsetY + blendOffsetY, context.canvas.width, context.canvas.height);
    context.restore();
}
const filterPattern = {
    getDialog (params) {
        const isSmall = window.innerWidth < 550;
        const maxSize = 1024;
        const rootEl = (0, _bb.BB).el({
            content: (0, _language.LANG)("filter-pattern-description") + "<br><br>"
        });
        const context = params.context;
        const width = context.canvas.width;
        const height = context.canvas.height;
        let settings = {
            x: 0,
            y: 0,
            width: width <= 250 ? Math.round(width / 4) : 200,
            height: height <= 250 ? Math.round(height / 4) : 200,
            blend: 0,
            offsetX: 0,
            offsetY: 0
        };
        let lastDrawnSettings = null;
        // determine bounds
        const bounds = (0, _bb.BB).canvasBounds(context);
        // adjust settings according to bounds
        if (bounds && bounds.width <= maxSize && bounds.height <= maxSize && (bounds.width < width * 0.75 || bounds.height < height * 0.75 // aren't too large (heuristic)
        )) {
            settings.x = bounds.x;
            settings.y = bounds.y;
            settings.width = bounds.width;
            settings.height = bounds.height;
        } else {
            settings.x = Math.round(width / 2 - settings.width / 2);
            settings.y = Math.round(height / 2 - settings.height / 2);
        }
        // ---- controls ----
        const xInput = (0, _input.input)({
            init: settings.x,
            type: "number",
            min: 0,
            max: width,
            css: {
                width: "100%"
            },
            callback: function(v) {
                settings.x = Number(v);
                updatePreview();
            }
        });
        const yInput = (0, _input.input)({
            init: settings.y,
            type: "number",
            min: 0,
            max: height,
            css: {
                width: "100%"
            },
            callback: function(v) {
                settings.y = Number(v);
                updatePreview();
            }
        });
        const widthInput = (0, _input.input)({
            init: settings.width,
            type: "number",
            min: 1,
            max: Math.min(maxSize, width),
            css: {
                width: "100%"
            },
            callback: function(v) {
                settings.width = Number(v);
                updatePreview();
            }
        });
        const heightInput = (0, _input.input)({
            init: settings.height,
            type: "number",
            min: 1,
            max: Math.min(maxSize, height),
            css: {
                width: "100%"
            },
            callback: function(v) {
                settings.height = Number(v);
                updatePreview();
            }
        });
        const inputStyle = {
            marginLeft: "5px",
            flex: "1"
        };
        rootEl.append((0, _bb.BB).el({
            content: [
                (0, _bb.BB).el({
                    tagName: "label",
                    content: [
                        "X:",
                        xInput, 
                    ],
                    css: inputStyle
                }),
                (0, _bb.BB).el({
                    tagName: "label",
                    content: [
                        "Y:",
                        yInput, 
                    ],
                    css: inputStyle
                }),
                (0, _bb.BB).el({
                    tagName: "label",
                    content: [
                        (0, _language.LANG)("width") + ":",
                        widthInput, 
                    ],
                    css: inputStyle
                }),
                (0, _bb.BB).el({
                    tagName: "label",
                    content: [
                        (0, _language.LANG)("height") + ":",
                        heightInput, 
                    ],
                    css: inputStyle
                }), 
            ],
            css: {
                display: "flex",
                marginLeft: "-5px"
            }
        }));
        const blendSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)("brush-blending"),
            width: 300,
            height: 30,
            min: 0,
            max: 1,
            value: settings.blend,
            eventResMs: (0, _filtersConsts.eventResMs),
            onChange: function(val) {
                settings.blend = val;
                updatePreview();
            },
            formatFunc: (val)=>{
                return (0, _bb.BB).round(val, 2);
            },
            manualInputRoundDigits: 2
        });
        (0, _bb.BB).css(blendSlider.getElement(), {
            margin: "10px 0"
        });
        rootEl.append(blendSlider.getElement());
        // ---- preview tabs ----
        let previewMode = 1; // 0 before, 1 after
        const beforeAfterTabs = new (0, _twoTabs.TwoTabs)({
            left: (0, _language.LANG)("compare-before"),
            right: (0, _language.LANG)("compare-after"),
            init: previewMode,
            onChange: (val)=>{
                previewMode = val;
                overlayCanvas.style.display = val === 0 ? "block" : "none";
                updatePreview(true);
            }
        });
        rootEl.append(beforeAfterTabs.getElement());
        // ---- previews ----
        const klCanvas = params.klCanvas;
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        const fit = (0, _bb.BB).fitInto(context.canvas.width, context.canvas.height, isSmall ? 280 : 490, isSmall ? 200 : 240, 1);
        const w = parseInt("" + fit.width), h = parseInt("" + fit.height);
        const renderW = Math.min(w, context.canvas.width);
        const renderH = Math.min(h, context.canvas.height);
        const renderFactor = renderW / context.canvas.width;
        const previewFactor = w / context.canvas.width;
        const previewWrapper = (0, _bb.BB).el({
            css: {
                width: isSmall ? "340px" : "540px",
                marginLeft: "-20px",
                height: isSmall ? "260px" : "300px",
                backgroundColor: "#9e9e9e",
                boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
                overflow: "hidden",
                position: "relative",
                userSelect: "none",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                colorScheme: "only light"
            }
        });
        const previewLayer = {
            image: (0, _bb.BB).canvas(renderW, renderH),
            opacity: layers[selectedLayerIndex].opacity,
            mixModeStr: layers[selectedLayerIndex].mixModeStr
        };
        const previewLayerArr = layers.map((item, i)=>{
            if (i === selectedLayerIndex) return previewLayer;
            else return {
                image: item.context.canvas,
                opacity: item.opacity,
                mixModeStr: item.mixModeStr
            };
        });
        const klCanvasPreview = new (0, _canvasPreview.KlCanvasPreview)({
            width: Math.round(w),
            height: Math.round(h),
            layers: previewLayerArr
        });
        const overlayCanvas = (0, _bb.BB).canvas(w, h);
        (0, _bb.BB).css(overlayCanvas, {
            position: "absolute",
            left: "0",
            top: "0",
            mixBlendMode: "difference",
            imageRendering: "pixelated"
        });
        const previewInnerWrapper = (0, _bb.BB).el({
            css: {
                position: "relative",
                boxShadow: "0 0 5px rgba(0,0,0,0.5)",
                width: parseInt("" + w) + "px",
                height: parseInt("" + h) + "px"
            }
        });
        previewInnerWrapper.append(klCanvasPreview.getElement(), overlayCanvas);
        previewWrapper.append(previewInnerWrapper);
        rootEl.append(previewWrapper);
        // ---- preview input processing ----
        const inputs = {
            start: null,
            end: null,
            oldSettings: null,
            state: null
        };
        function syncInputs() {
            xInput.value = "" + settings.x;
            yInput.value = "" + settings.y;
            widthInput.value = "" + settings.width;
            heightInput.value = "" + settings.height;
        }
        const keyListener = new (0, _bb.BB).KeyListener({});
        previewWrapper.oncontextmenu = function() {
            return false;
        };
        previewInnerWrapper.style.touchAction = "none";
        const pointerListener = new (0, _bb.BB).PointerListener({
            target: previewInnerWrapper,
            onPointer: (event)=>{
                if (previewMode === 0) {
                    if (event.type === "pointerdown") {
                        if (!inputs.state) {
                            inputs.oldSettings = (0, _bb.BB).copyObj(settings);
                            const x = event.relX / previewFactor;
                            const y = event.relY / previewFactor;
                            if ((0, _bb.BB).isInsideRect({
                                x,
                                y
                            }, {
                                x: settings.x,
                                y: settings.y,
                                width: settings.width,
                                height: settings.height
                            })) inputs.state = "move";
                            else inputs.state = "select";
                            inputs.start = {
                                x,
                                y
                            };
                        }
                    } else if (event.type === "pointermove") {
                        const x1 = event.relX / previewFactor;
                        const y1 = event.relY / previewFactor;
                        if (inputs.state === "select") {
                            inputs.end = {
                                x: x1,
                                y: y1
                            };
                            const x11 = Math.max(0, Math.min(inputs.start.x, inputs.end.x));
                            const y11 = Math.max(0, Math.min(inputs.start.y, inputs.end.y));
                            const x2 = Math.min(width, Math.max(inputs.start.x, inputs.end.x));
                            const y2 = Math.min(height, Math.max(inputs.start.y, inputs.end.y));
                            settings.x = Math.floor(x11);
                            settings.y = Math.floor(y11);
                            settings.width = Math.min(maxSize, Math.ceil(x2 - settings.x));
                            settings.height = Math.min(maxSize, Math.ceil(y2 - settings.y));
                            if (keyListener.isPressed("shift")) {
                                settings.width = Math.min(settings.width, settings.height);
                                settings.height = Math.min(settings.width, settings.height);
                            }
                            if (settings.width === 0 || settings.height === 0) settings = (0, _bb.BB).copyObj(inputs.oldSettings);
                            syncInputs();
                            updatePreview();
                        } else if (inputs.state === "move") {
                            const dX = Math.round(x1 - inputs.start.x);
                            const dY = Math.round(y1 - inputs.start.y);
                            settings.x = (0, _bb.BB).clamp(inputs.oldSettings.x + dX, 0, width - settings.width);
                            settings.y = (0, _bb.BB).clamp(inputs.oldSettings.y + dY, 0, height - settings.height);
                            syncInputs();
                            updatePreview();
                        }
                    } else if (event.type === "pointerup") {
                        if (inputs.state) inputs.state = null;
                    }
                } else {
                    if (event.type === "pointerdown") {
                        if (!inputs.state) {
                            inputs.state = "move";
                            inputs.oldSettings = (0, _bb.BB).copyObj(settings);
                            inputs.start = {
                                x: event.relX / previewFactor,
                                y: event.relY / previewFactor
                            };
                            inputs.end = null;
                        }
                    } else if (event.type === "pointermove") {
                        if (inputs.state) {
                            inputs.end = {
                                x: event.relX / previewFactor,
                                y: event.relY / previewFactor
                            };
                            settings.offsetX = Math.round(inputs.end.x - inputs.start.x) + inputs.oldSettings.offsetX;
                            settings.offsetY = Math.round(inputs.end.y - inputs.start.y) + inputs.oldSettings.offsetY;
                            updatePreview();
                        }
                    } else if (event.type === "pointerup") {
                        if (inputs.state) {
                            if (!inputs.end) {
                                settings.offsetX = 0;
                                settings.offsetY = 0;
                                updatePreview();
                            }
                            inputs.state = null;
                        }
                    }
                }
            }
        });
        // ---------- rendering ---------------------
        const fullSizeCanvas = (0, _bb.BB).canvas(width, height);
        const fullSizeCtx = fullSizeCanvas.getContext("2d");
        function sharpStrokeRect(context, x, y, width, height) {
            const drawX = Math.round(x + 0.5) - 0.5;
            const drawY = Math.round(y + 0.5) - 0.5;
            const drawWidth = Math.round(x + width - drawX);
            const drawHeight = Math.round(y + height - drawY);
            context.strokeRect(drawX, drawY, drawWidth, drawHeight);
        }
        function updatePreview(doForce) {
            if (!doForce && lastDrawnSettings && JSON.stringify(lastDrawnSettings) === JSON.stringify(settings)) return;
            if (previewMode === 0) {
                fullSizeCtx.clearRect(0, 0, width, height);
                fullSizeCtx.drawImage(context.canvas, 0, 0);
                const previewCanvas = previewLayer.image;
                const previewCtx = previewCanvas.getContext("2d");
                previewCtx.save();
                previewCtx.clearRect(0, 0, renderW, renderH);
                previewCtx.drawImage(fullSizeCanvas, 0, 0, renderW, renderH);
                previewCtx.restore();
                const pW = settings.width * previewFactor;
                const pH = settings.height * previewFactor;
                const overlayCtx = overlayCanvas.getContext("2d");
                overlayCtx.save();
                overlayCtx.clearRect(0, 0, w, h);
                overlayCtx.strokeStyle = "#fff";
                sharpStrokeRect(overlayCtx, settings.x * previewFactor, settings.y * previewFactor, pW, pH);
                if (settings.blend > 0.05) {
                    overlayCtx.strokeStyle = "#f0f";
                    sharpStrokeRect(overlayCtx, settings.x * previewFactor - pW / 2 * settings.blend, settings.y * previewFactor - pH / 2 * settings.blend, pW * (1 + settings.blend), pH * (1 + settings.blend));
                }
                overlayCtx.restore();
            } else {
                fullSizeCtx.clearRect(0, 0, width, height);
                fullSizeCtx.drawImage(context.canvas, 0, 0);
                drawPattern(fullSizeCtx, settings);
                const previewCanvas1 = previewLayer.image;
                const previewCtx1 = previewCanvas1.getContext("2d");
                previewCtx1.clearRect(0, 0, renderW, renderH);
                previewCtx1.drawImage(fullSizeCanvas, 0, 0, renderW, renderH);
            }
            klCanvasPreview.render();
            lastDrawnSettings = (0, _bb.BB).copyObj(settings);
        }
        updatePreview();
        // ----- result -------------------
        const result = {
            element: rootEl,
            destroy: ()=>{
                blendSlider.destroy();
                keyListener.destroy();
                pointerListener.destroy();
            },
            getInput: ()=>(0, _bb.BB).copyObj(settings)
        };
        if (!isSmall) result.width = 500;
        return result;
    },
    apply (params) {
        const klCanvas = params.klCanvas;
        const ctx = params.context;
        const history = params.history;
        if (!klCanvas || !history) return false;
        history.pause(true);
        drawPattern(ctx, params.input);
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "pattern"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","../ui/base-components/input":"bsfIT","../ui/base-components/kl-slider":"6YGce","../../language/language":"iiYGN","./filters-consts":"7Xzbl","../canvas-ui/canvas-preview":"gRZnS","../ui/components/two-tabs":"edCwK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dW7B1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterDistort", ()=>filterDistort);
var _bb = require("../../bb/bb");
var _klSlider = require("../ui/base-components/kl-slider");
var _language = require("../../language/language");
var _filtersConsts = require("./filters-consts");
var _canvasPreview = require("../canvas-ui/canvas-preview");
var _sharedGlFx = require("./shared-gl-fx");
var _options = require("../ui/base-components/options");
var _checkbox = require("../ui/base-components/checkbox");
const filterDistort = {
    getDialog (params) {
        const isSmall = window.innerWidth < 550;
        const rootEl = (0, _bb.BB).el({
            content: (0, _language.LANG)("filter-distort-description") + "<br><br>"
        });
        const context = params.context;
        const width = context.canvas.width;
        const height = context.canvas.height;
        let isSynced = true;
        let settings = {
            distortType: 0,
            scale: {
                x: 100,
                y: 100
            },
            strength: {
                x: 20,
                y: 20
            },
            phase: {
                x: 0,
                y: 0
            },
            stepSize: 1
        };
        // let lastDrawnSettings = null;
        // ---- thumb -------
        const thumbImgArr = [];
        const thumbSize = 32;
        {
            const canvas = (0, _bb.BB).canvas(thumbSize, thumbSize);
            const ctx = canvas.getContext("2d");
            ctx.beginPath();
            ctx.arc(thumbSize / 2, thumbSize / 2, thumbSize / 2.5, 0, Math.PI * 2);
            ctx.fill();
            let gradient = ctx.createLinearGradient(0, 0, thumbSize, thumbSize);
            gradient.addColorStop(0, "#00f");
            gradient.addColorStop(0.5, "#f00");
            gradient.addColorStop(1, "#fff");
            ctx.fillStyle = gradient;
            ctx.globalCompositeOperation = "source-atop";
            ctx.fillRect(0, 0, thumbSize, thumbSize);
            gradient = ctx.createLinearGradient(thumbSize, 0, 0, thumbSize);
            gradient.addColorStop(0, "#000");
            gradient.addColorStop(1, "#000");
            ctx.fillStyle = gradient;
            ctx.globalCompositeOperation = "destination-atop";
            ctx.fillRect(0, 0, thumbSize, thumbSize);
            const glCanvas = (0, _sharedGlFx.getSharedFx)();
            const texture = glCanvas.texture(canvas);
            glCanvas.draw(texture).update(); // update glCanvas size
            const scaleFactor = 20;
            [
                0,
                1,
                2
            ].forEach((item)=>{
                const thumbImg = new Image();
                const settingsCopy = (0, _bb.BB).copyObj(settings);
                settingsCopy.distortType = item;
                settingsCopy.scale.x /= scaleFactor;
                settingsCopy.scale.y /= scaleFactor;
                settingsCopy.strength.x /= scaleFactor;
                settingsCopy.strength.y /= scaleFactor;
                glCanvas.draw(texture).multiplyAlpha().distort(settingsCopy).unmultiplyAlpha().update();
                ctx.clearRect(0, 0, thumbSize, thumbSize);
                ctx.drawImage(glCanvas, 0, 0);
                thumbImg.src = canvas.toDataURL("image/png");
                thumbImgArr.push(thumbImg);
            });
            texture.destroy();
        }
        // ---- controls ----
        const topRowEl = (0, _bb.BB).el({
            parent: rootEl,
            css: {
                display: "flex",
                alignItems: "center"
            }
        });
        const typeOptions = new (0, _options.Options)({
            optionArr: thumbImgArr.map((img, index)=>{
                (0, _bb.BB).css(img, {
                    margin: "1px",
                    borderRadius: "3px",
                    transition: "all 0.1s ease-in-out"
                });
                return {
                    id: "" + index,
                    label: img
                };
            }),
            initialId: "0",
            onChange: (id)=>{
                settings.distortType = Number(id);
                updatePreview();
            }
        });
        function sync(from) {
            if (from === "x") {
                settings.scale.y = settings.scale.x;
                settings.strength.y = settings.strength.x;
                settings.phase.y = settings.phase.x;
                sliderArr[3].setValue(settings.scale.y);
                sliderArr[4].setValue(settings.strength.y);
                sliderArr[5].setValue(settings.phase.y);
            } else {
                settings.scale.x = settings.scale.y;
                settings.strength.x = settings.strength.y;
                settings.phase.x = settings.phase.y;
                sliderArr[0].setValue(settings.scale.x);
                sliderArr[1].setValue(settings.strength.x);
                sliderArr[2].setValue(settings.phase.x);
            }
            updatePreview();
        }
        const syncToggle = new (0, _checkbox.Checkbox)({
            init: true,
            label: (0, _language.LANG)("filter-distort-sync-xy"),
            callback: (val)=>{
                isSynced = val;
                if (isSynced) sync("x");
            }
        });
        topRowEl.append(typeOptions.getElement(), (0, _bb.BB).el({
            css: {
                flexGrow: "1"
            }
        }), syncToggle.getElement());
        const xyRowEl = (0, _bb.BB).el({
            parent: rootEl,
            css: {
                display: "flex",
                flexWrap: "wrap"
            }
        });
        const leftCol = (0, _bb.BB).el({
            parent: xyRowEl,
            css: {
                marginRight: "10px"
            }
        });
        const rightCol = (0, _bb.BB).el({
            parent: xyRowEl
        });
        const sliderWidth = isSmall ? 300 : 245;
        const sliderArr = [];
        [
            "x",
            "y"
        ].forEach((item, index)=>{
            const targetEl = index === 0 ? leftCol : rightCol;
            const scaleSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("filter-noise-scale") + " " + item.toUpperCase(),
                width: sliderWidth,
                height: 30,
                min: 1,
                max: 1000,
                curve: "quadratic",
                value: settings.scale[item],
                eventResMs: (0, _filtersConsts.eventResMs),
                onChange: (val)=>{
                    settings.scale[item] = val;
                    if (isSynced) sync(item);
                    else updatePreview();
                }
            });
            scaleSlider.getElement().style.marginTop = "20px";
            targetEl.append(scaleSlider.getElement());
            const strengthSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("filter-unsharp-mask-strength") + " " + item.toUpperCase(),
                width: sliderWidth,
                height: 30,
                min: 0,
                max: 200,
                curve: "quadratic",
                value: settings.strength[item],
                eventResMs: (0, _filtersConsts.eventResMs),
                onChange: (val)=>{
                    settings.strength[item] = val;
                    if (isSynced) sync(item);
                    else updatePreview();
                }
            });
            strengthSlider.getElement().style.marginTop = "10px";
            targetEl.append(strengthSlider.getElement());
            const phaseSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("filter-distort-phase") + " " + item.toUpperCase(),
                width: sliderWidth,
                height: 30,
                min: 0,
                max: 1,
                value: settings.phase[item],
                manualInputRoundDigits: 2,
                eventResMs: (0, _filtersConsts.eventResMs),
                formatFunc: (val)=>(0, _bb.BB).round(val, 2),
                onChange: (val)=>{
                    settings.phase[item] = val;
                    if (isSynced) sync(item);
                    else updatePreview();
                }
            });
            phaseSlider.getElement().style.marginTop = "10px";
            targetEl.append(phaseSlider.getElement());
            sliderArr.push(scaleSlider);
            sliderArr.push(strengthSlider);
            sliderArr.push(phaseSlider);
        });
        const stepSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)("filter-distort-stepsize"),
            width: 300,
            height: 30,
            min: 1,
            max: 300,
            curve: "quadratic",
            value: settings.stepSize,
            eventResMs: (0, _filtersConsts.eventResMs),
            onChange: (val)=>{
                settings.stepSize = Math.round(val);
                updatePreview();
            }
        });
        stepSlider.getElement().style.marginTop = "20px";
        rootEl.append(stepSlider.getElement());
        // ---- preview ----
        const klCanvas = params.klCanvas;
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        const fit = (0, _bb.BB).fitInto(context.canvas.width, context.canvas.height, isSmall ? 280 : 490, isSmall ? 200 : 240, 1);
        const w = parseInt("" + fit.width), h = parseInt("" + fit.height);
        const renderW = Math.min(w, context.canvas.width);
        const renderH = Math.min(h, context.canvas.height);
        const renderFactor = renderW / context.canvas.width;
        const previewFactor = w / context.canvas.width;
        const previewWrapper = (0, _bb.BB).el({
            css: {
                width: isSmall ? "340px" : "540px",
                marginLeft: "-20px",
                height: isSmall ? "260px" : "300px",
                backgroundColor: "#9e9e9e",
                boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
                overflow: "hidden",
                position: "relative",
                userSelect: "none",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                colorScheme: "only light",
                marginTop: "10px"
            }
        });
        let glCanvas1 = (0, _sharedGlFx.getSharedFx)();
        if (!glCanvas1) return; // todo throw?
        let texture1 = glCanvas1.texture(context.canvas);
        glCanvas1.draw(texture1).update(); // update glCanvas size
        const previewLayer = {
            image: glCanvas1,
            opacity: layers[selectedLayerIndex].opacity,
            mixModeStr: layers[selectedLayerIndex].mixModeStr
        };
        const previewLayerArr = layers.map((item, i)=>{
            if (i === selectedLayerIndex) return previewLayer;
            else return {
                image: item.context.canvas,
                opacity: item.opacity,
                mixModeStr: item.mixModeStr
            };
        });
        const klCanvasPreview = new (0, _canvasPreview.KlCanvasPreview)({
            width: Math.round(w),
            height: Math.round(h),
            layers: previewLayerArr
        });
        const previewInnerWrapper = (0, _bb.BB).el({
            css: {
                position: "relative",
                boxShadow: "0 0 5px rgba(0,0,0,0.5)",
                width: parseInt("" + w) + "px",
                height: parseInt("" + h) + "px"
            }
        });
        previewInnerWrapper.append(klCanvasPreview.getElement());
        previewWrapper.append(previewInnerWrapper);
        rootEl.append(previewWrapper);
        // ---------- rendering ---------------------
        function updatePreview() {
            glCanvas1.draw(texture1).multiplyAlpha().distort(settings).unmultiplyAlpha().update();
            klCanvasPreview.render();
        }
        updatePreview();
        // ----- result -------------------
        const result = {
            element: rootEl,
            destroy: ()=>{
                typeOptions.destroy();
                sliderArr.forEach((item)=>item.destroy());
                stepSlider.destroy();
                syncToggle.destroy();
                texture1.destroy();
            },
            getInput: ()=>(0, _bb.BB).copyObj(settings)
        };
        if (!isSmall) result.width = 500;
        return result;
    },
    apply (params) {
        const klCanvas = params.klCanvas;
        const context = params.context;
        const history = params.history;
        if (!klCanvas || !history) return false;
        history.pause(true);
        let glCanvas = (0, _sharedGlFx.getSharedFx)();
        if (!glCanvas) return false; // todo more specific error?
        let texture = glCanvas.texture(context.canvas);
        glCanvas.draw(texture).multiplyAlpha().distort(params.input).unmultiplyAlpha().update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(glCanvas, 0, 0);
        texture.destroy();
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "distort"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","../ui/base-components/kl-slider":"6YGce","../../language/language":"iiYGN","./filters-consts":"7Xzbl","../canvas-ui/canvas-preview":"gRZnS","./shared-gl-fx":"4bJZi","../ui/base-components/options":"huqRY","../ui/base-components/checkbox":"kPAwM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ftQ30":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterVanishPoint", ()=>filterVanishPoint);
var _bb = require("../../bb/bb");
var _canvasPreview = require("../canvas-ui/canvas-preview");
var _language = require("../../language/language");
var _input = require("../ui/base-components/input");
var _colorOptions = require("../ui/base-components/color-options");
var _drawVanishPoint = require("../image-operations/draw-vanish-point");
var _klSlider = require("../ui/base-components/kl-slider");
var _filtersConsts = require("./filters-consts");
const filterVanishPoint = {
    getDialog (params) {
        let context = params.context;
        let klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        let layers = klCanvas.getLayers();
        let selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        let fit = (0, _bb.BB).fitInto(context.canvas.width, context.canvas.height, 280, 200, 1);
        let w = parseInt("" + fit.width), h = parseInt("" + fit.height);
        const renderW = Math.min(w, context.canvas.width);
        const renderH = Math.min(h, context.canvas.height);
        const renderFactor = renderW / context.canvas.width;
        const previewFactor = w / context.canvas.width;
        let div = document.createElement("div");
        let result = {
            element: div
        };
        div.innerHTML = (0, _language.LANG)("filter-vanish-point-description") + "<br/><br/>";
        const settingsObj = {
            x: context.canvas.width / 2,
            y: context.canvas.height / 2,
            lines: 8,
            thickness: 2,
            color: {
                r: 0,
                g: 0,
                b: 0
            },
            opacity: 1
        };
        const linesSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)("filter-vanish-point-lines"),
            width: 300,
            height: 30,
            min: 2,
            max: 20,
            value: settingsObj.lines,
            curve: "quadratic",
            eventResMs: (0, _filtersConsts.eventResMs),
            onChange: function(val) {
                settingsObj.lines = Math.round(val);
                updatePreview();
            }
        });
        linesSlider.getElement().style.marginBottom = "10px";
        div.append(linesSlider.getElement());
        let line1 = (0, _bb.BB).el({
            parent: div,
            css: {
                display: "flex",
                alignItems: "center"
            }
        });
        let line2 = (0, _bb.BB).el({
            parent: div,
            css: {
                display: "flex",
                alignItems: "center",
                marginTop: "10px"
            }
        });
        const xInput = (0, _input.input)({
            init: settingsObj.x,
            type: "number",
            css: {
                width: "75px",
                marginRight: "20px"
            },
            callback: function(v) {
                settingsObj.x = parseFloat(v);
                updatePreview();
            }
        });
        const yInput = (0, _input.input)({
            init: settingsObj.y,
            type: "number",
            css: {
                width: "75px",
                marginRight: "20px"
            },
            callback: function(v) {
                settingsObj.y = parseFloat(v);
                updatePreview();
            }
        });
        const thicknessInput = (0, _input.input)({
            init: 2,
            type: "number",
            min: 1,
            css: {
                width: "75px",
                marginRight: "20px"
            },
            callback: function(v) {
                settingsObj.thickness = parseFloat(v);
                updatePreview();
            }
        });
        let selectedRgbaObj = {
            r: 0,
            g: 0,
            b: 0,
            a: 1
        };
        const colorOptionsArr = [
            {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            },
            {
                r: 255,
                g: 255,
                b: 255,
                a: 1
            }, 
        ];
        colorOptionsArr.push({
            r: params.currentColorRgb.r,
            g: params.currentColorRgb.g,
            b: params.currentColorRgb.b,
            a: 1
        });
        colorOptionsArr.push({
            r: params.secondaryColorRgb.r,
            g: params.secondaryColorRgb.g,
            b: params.secondaryColorRgb.b,
            a: 1
        });
        settingsObj.color = (0, _bb.BB).copyObj(selectedRgbaObj);
        const colorOptions = new (0, _colorOptions.ColorOptions)({
            label: (0, _language.LANG)("shape-stroke"),
            colorArr: colorOptionsArr,
            onChange: function(rgbaObj) {
                selectedRgbaObj = rgbaObj;
                settingsObj.color = (0, _bb.BB).copyObj(selectedRgbaObj);
                updatePreview();
            }
        });
        const labelStyle = {
            display: "inline-block",
            marginRight: "5px"
        };
        line1.append((0, _bb.BB).el({
            content: "X:",
            css: labelStyle
        }), xInput, (0, _bb.BB).el({
            content: "Y:",
            css: labelStyle
        }), yInput);
        line2.append((0, _bb.BB).el({
            content: (0, _language.LANG)("shape-line-width") + ":",
            css: labelStyle
        }), thicknessInput, (0, _bb.BB).el({
            css: {
                flexGrow: "1"
            }
        }), colorOptions.getElement());
        let previewWrapper = document.createElement("div");
        (0, _bb.BB).css(previewWrapper, {
            width: "340px",
            marginLeft: "-20px",
            height: "220px",
            backgroundColor: "#9e9e9e",
            marginTop: "10px",
            boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
            overflow: "hidden",
            position: "relative",
            userSelect: "none",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            colorScheme: "only light"
        });
        let previewLayer = {
            image: (0, _bb.BB).canvas(renderW, renderH),
            opacity: layers[selectedLayerIndex].opacity,
            mixModeStr: layers[selectedLayerIndex].mixModeStr
        };
        let klCanvasPreview = new (0, _canvasPreview.KlCanvasPreview)({
            width: Math.round(w),
            height: Math.round(h),
            layers: layers.map((item, i)=>{
                if (i === selectedLayerIndex) return previewLayer;
                else return {
                    image: item.context.canvas,
                    opacity: item.opacity,
                    mixModeStr: item.mixModeStr
                };
            })
        });
        let previewInnerWrapper = (0, _bb.BB).el({
            css: {
                position: "relative",
                boxShadow: "0 0 5px rgba(0,0,0,0.5)",
                width: parseInt("" + w) + "px",
                height: parseInt("" + h) + "px",
                cursor: "move"
            }
        });
        previewInnerWrapper.appendChild(klCanvasPreview.getElement());
        previewWrapper.appendChild(previewInnerWrapper);
        // ---- preview input processing ----
        const inputs = {
            start: null,
            end: null,
            state: null,
            oldSettings: null
        };
        function syncInputs() {
            xInput.value = "" + settingsObj.x;
            yInput.value = "" + settingsObj.y;
        }
        previewWrapper.oncontextmenu = function() {
            return false;
        };
        previewInnerWrapper.style.touchAction = "none";
        const pointerListener = new (0, _bb.BB).PointerListener({
            target: previewInnerWrapper,
            onPointer: (event)=>{
                if (event.type === "pointerdown") {
                    if (!inputs.state) {
                        inputs.state = "move";
                        inputs.oldSettings = (0, _bb.BB).copyObj(settingsObj);
                        inputs.start = {
                            x: event.relX / previewFactor,
                            y: event.relY / previewFactor
                        };
                        inputs.end = null;
                    }
                } else if (event.type === "pointermove") {
                    if (inputs.state) {
                        inputs.end = {
                            x: event.relX / previewFactor,
                            y: event.relY / previewFactor
                        };
                        settingsObj.x = Math.round(inputs.end.x - inputs.start.x + inputs.oldSettings.x);
                        settingsObj.y = Math.round(inputs.end.y - inputs.start.y + inputs.oldSettings.y);
                        syncInputs();
                        updatePreview();
                    }
                } else if (event.type === "pointerup") {
                    if (inputs.state) inputs.state = null;
                }
            }
        });
        function updatePreview() {
            let ctx = previewLayer.image.getContext("2d");
            ctx.save();
            ctx.clearRect(0, 0, renderW, renderH);
            ctx.drawImage(context.canvas, 0, 0, renderW, renderH);
            (0, _drawVanishPoint.drawVanishPoint)(ctx, settingsObj.x * renderFactor, settingsObj.y * renderFactor, settingsObj.lines, Math.max(settingsObj.thickness * renderFactor, 1), settingsObj.color, settingsObj.opacity);
            ctx.restore();
            klCanvasPreview.render();
        }
        setTimeout(updatePreview, 0);
        div.appendChild(previewWrapper);
        result.destroy = ()=>{
            linesSlider.destroy();
            pointerListener.destroy();
        };
        result.getInput = function() {
            result.destroy();
            return (0, _bb.BB).copyObj(settingsObj);
        };
        return result;
    },
    apply (params) {
        let context = params.context;
        let klCanvas = params.klCanvas;
        let history = params.history;
        if (!context || !klCanvas || !history) return false;
        history.pause(true);
        (0, _drawVanishPoint.drawVanishPoint)(context, params.input.x, params.input.y, params.input.lines, params.input.thickness, params.input.color, params.input.opacity);
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "vanishPoint"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","../canvas-ui/canvas-preview":"gRZnS","../../language/language":"iiYGN","../ui/base-components/input":"bsfIT","../ui/base-components/color-options":"e85vi","../image-operations/draw-vanish-point":"gsRRw","../ui/base-components/kl-slider":"6YGce","./filters-consts":"7Xzbl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gsRRw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "drawVanishPoint", ()=>drawVanishPoint);
var _shapeTool = require("./shape-tool");
var _bb = require("../../bb/bb");
function drawVanishPoint(ctx, x, y, lines, thickness, color, opacity) {
    ctx.save();
    const degIncrement = 180 / lines;
    for(let deg = 0; deg < 180; deg += degIncrement){
        const p2 = (0, _bb.BB).rotateAround({
            x,
            y
        }, {
            x: x + 9999,
            y
        }, deg);
        (0, _shapeTool.drawShape)(ctx, {
            type: "line",
            x1: x,
            y1: y,
            x2: p2.x,
            y2: p2.y,
            //angleRad: 0,
            isOutwards: true,
            opacity,
            //isEraser: false,
            strokeRgb: color,
            lineWidth: thickness
        });
    }
    ctx.restore();
}

},{"./shape-tool":"90Wty","../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gh8aB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "klCanvasToPsdBlob", ()=>klCanvasToPsdBlob);
var _kl = require("../kl");
async function klCanvasToPsdBlob(klCanvas) {
    let layerArr = klCanvas.getLayersFast();
    let psdConfig = {
        width: klCanvas.getWidth(),
        height: klCanvas.getHeight(),
        //canvas: klCanvas.getCompleteCanvas(1), // preview, can be skipped
        children: []
    };
    for(let i = 0; i < layerArr.length; i++){
        // todo - can be optimized if layer mostly empty
        let item = layerArr[i];
        psdConfig.children.push({
            name: item.name,
            opacity: item.opacity,
            canvas: item.canvas,
            blendMode: (0, _kl.KL).PSD.blendKlToPsd(item.mixModeStr),
            left: 0,
            top: 0
        });
    }
    let agPsd = await require("259995e5c86c70f1");
    let buffer = agPsd.writePsdBuffer(psdConfig);
    return new Blob([
        buffer
    ], {
        type: "application/octet-stream"
    });
}

},{"../kl":"8nmWp","259995e5c86c70f1":"75zf2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"czJ1u":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "tab-settings.3ce93070.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}],"dKFwY":[function(require,module,exports) {
module.exports = require("./helpers/bundle-url").getBundleURL("d3gnI") + "tab-layers.45ddc8d0.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"lgJ39"}]},["aYHqc","c1sIO"], "c1sIO", "parcelRequire94c2")

//# sourceMappingURL=index.9aa0ef6a.js.map
